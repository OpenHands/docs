---
title: SDLC Integration
description: How OpenHands fits into your software development lifecycle
---

## Overview

OpenHands integrates throughout your software development lifecycle (SDLC), from planning to deployment. This guide explains where and how to use OpenHands effectively at each stage.

## Development Phases

### 1. Planning & Analysis

Use OpenHands to accelerate the planning phase:

**Codebase Exploration**
```
"Analyze the codebase and explain how the authentication system works"
"List all API endpoints and their purposes"
"Find all places where we connect to the database"
```

**Task Scoping**
```
"What files would need to change to add a new user role?"
"Estimate the complexity of migrating from REST to GraphQL"
"Identify dependencies that might be affected by upgrading Node.js"
```

**Architecture Review**
```
"Review the current architecture and suggest improvements"
"Identify potential security vulnerabilities in the user module"
"Find code that doesn't follow our coding standards"
```

<Tip>
Use OpenHands for codebase exploration when onboarding new team members or investigating unfamiliar parts of your system.
</Tip>

### 2. Development

The primary use case for OpenHands—implementing features and fixes:

**Feature Implementation**
```
"Implement a password reset feature with email verification"
"Add pagination to the /api/products endpoint"
"Create a dashboard component that displays user statistics"
```

**Bug Fixes**
```
"Fix the race condition in the checkout process"
"Resolve the memory leak in the image processing service"
"Fix the failing test in UserService.test.js"
```

**Refactoring**
```
"Refactor the payment module to use the strategy pattern"
"Convert the callback-based API to async/await"
"Split the monolithic UserController into smaller services"
```

**Code Generation**
```
"Generate TypeScript interfaces from this JSON schema"
"Create database migration for the new orders table"
"Generate API client code from the OpenAPI spec"
```

### 3. Testing

Improve test coverage and quality:

**Unit Tests**
```
"Write unit tests for the OrderService class with 80% coverage"
"Add tests for edge cases in the validation module"
"Create mock implementations for external service dependencies"
```

**Integration Tests**
```
"Write integration tests for the authentication flow"
"Create API tests for all CRUD operations"
"Add end-to-end tests for the checkout process"
```

**Test Maintenance**
```
"Fix all failing tests after the refactoring"
"Update tests to work with the new API response format"
"Remove outdated test fixtures"
```

<Tip>
OpenHands excels at writing tests because it can analyze your existing code and test patterns to maintain consistency.
</Tip>

### 4. Code Review

Use OpenHands to assist with code reviews:

**Automated PR Review**
```
"Review this PR for potential issues and suggest improvements"
"Check if this code follows our coding standards"
"Identify any security concerns in these changes"
```

**PR Creation**
When OpenHands completes a task, it can create a pull request with:
- Clear description of changes
- Summary of files modified
- Testing instructions

**Documentation Updates**
```
"Update the README to reflect the new API changes"
"Add inline comments explaining the complex algorithm"
"Generate API documentation for the new endpoints"
```

### 5. Deployment & Operations

Support operational tasks:

**Configuration**
```
"Create Kubernetes deployment manifests for the new service"
"Set up GitHub Actions workflow for CI/CD"
"Configure environment variables for production"
```

**Troubleshooting**
```
"Analyze these error logs and suggest fixes"
"Find the root cause of the performance degradation"
"Identify what changed between these two deployments"
```

**Monitoring**
```
"Add health check endpoints to all services"
"Implement structured logging throughout the application"
"Create Prometheus metrics for key operations"
```

## Integration Patterns

### Parallel Execution

Run multiple OpenHands sessions for independent tasks:

```
Session 1: "Implement the user profile feature"
Session 2: "Write tests for the existing auth module"
Session 3: "Update documentation for the API"
```

<Warning>
Avoid running parallel sessions that modify the same files to prevent merge conflicts.
</Warning>

### Sequential Workflows

Chain tasks for dependent work:

```
1. "Create the database schema for the new orders feature"
2. "Implement the Order model and repository"
3. "Create API endpoints for order management"
4. "Write tests for the order functionality"
5. "Update the API documentation"
```

### Review-and-Refine

Iterative development approach:

```
1. "Implement a basic version of the search feature"
   → Review the output
2. "Add fuzzy matching to the search"
   → Review the output
3. "Optimize the search performance for large datasets"
   → Final review
```

## Team Integration

### Workflow Recommendations

| Team Size | Recommended Approach |
|-----------|---------------------|
| Solo Developer | Direct integration, use for all suitable tasks |
| Small Team (2-5) | Shared best practices, consistent prompting patterns |
| Larger Teams | Establish guidelines, use Skills for consistency |

### Coordination Strategies

**Ticket Assignment**
- Use OpenHands for well-defined tickets
- Include necessary context in ticket descriptions
- Reference relevant files and patterns

**Branch Management**
- Create feature branches before starting tasks
- Use consistent naming conventions
- Review changes before merging

**Code Standards**
Use [Skills](/overview/skills) to encode your team's standards:
- Coding conventions
- Testing requirements
- Documentation patterns
- Security guidelines

## Best Practices

### 1. Task Sizing

| Task Size | Suitability | Example |
|-----------|-------------|---------|
| Small (1-2 files) | ✅ Excellent | Add a new API endpoint |
| Medium (3-10 files) | ✅ Good | Implement a feature module |
| Large (10+ files) | ⚠️ Break down | System-wide refactoring |

### 2. Context Provision

Provide relevant context for better results:

```
"Add caching to the product service.
- Use Redis (already configured in config/redis.js)
- Cache for 5 minutes
- Invalidate on product updates
- Follow the pattern in services/userService.js"
```

### 3. Verification Steps

Always verify OpenHands' work:

1. **Run tests**: `npm test` or your test command
2. **Check linting**: `npm run lint`
3. **Review changes**: Use `git diff` to see all modifications
4. **Manual testing**: Test the feature manually when appropriate

### 4. Documentation

Keep track of what OpenHands does:

- Review generated commit messages
- Update tickets with implementation details
- Note any manual follow-up needed

## Measuring Success

Track these metrics to measure OpenHands' impact:

- **Time to completion**: Compare task completion times
- **Code quality**: Monitor test coverage and lint errors
- **Iteration count**: Track how many clarifications are needed
- **Adoption rate**: Measure team usage over time

## Common Patterns

### The Exploration-Then-Execute Pattern

```
1. "Explore the codebase and explain how payments are processed"
2. [Review the explanation]
3. "Now add support for PayPal using the same patterns"
```

### The Test-First Pattern

```
1. "Write failing tests for a user registration feature"
2. [Review the tests]
3. "Now implement the feature to make the tests pass"
```

### The Incremental Refactoring Pattern

```
1. "Identify all technical debt in the auth module"
2. [Review and prioritize]
3. "Refactor the highest priority item: the session management"
4. [Verify and repeat]
```

## See Also

- [When to Use OpenHands](/openhands/usage/tips/when-to-use-openhands)
- [Writing Effective Instructions](/openhands/usage/tips/effective-instructions)
- [Repository Customization](/openhands/usage/customization/repository)
- [Skills](/overview/skills)
