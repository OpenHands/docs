---
title: COBOL Modernization
description: Modernizing legacy COBOL systems with OpenHands
---

Legacy COBOL systems power critical business operations across banking, insurance, government, and retail. OpenHands can help you understand, document, and modernize these systems while preserving their essential business logic.

<Note>
This guide is based on our blog post [Refactoring COBOL to Java with AI Agents](https://openhands.dev/blog/20251218-cobol-to-java-refactoring).
</Note>

## The COBOL Modernization Challenge

[COBOL](https://en.wikipedia.org/wiki/COBOL) modernization is one of the most pressing challenges facing enterprises today. Gartner estimated there were over 200 billion lines of COBOL code in existence, running 80% of the world's business systems. As of 2020, COBOL was still running background processes for 95% of credit and debit card transactions.

The challenge is acute: [47% of organizations](https://softwaremodernizationservices.com/mainframe-modernization) struggle to fill COBOL roles, with salaries rising 25% annually. By 2027, 92% of remaining COBOL developers will have retired. Traditional modernization approaches have seen high failure rates, with COBOL's specialized nature requiring a unique skill set that makes it difficult for human teams alone.

## Overview

COBOL modernization is a complex undertaking. Every modernization effort is unique and requires careful planning, execution, and validation to ensure the modernized code behaves identically to the original. The migration needs to be driven by an experienced team of developers and domain experts, but even that isn't sufficient to ensure the job is done quickly or cost-effectively. This is where OpenHands comes in.

OpenHands is a powerful agent that assists in modernizing COBOL code along every step of the process:

1. **Understanding**: Analyze and document existing COBOL code
2. **Translation**: Convert COBOL to modern languages like Java, Python, or C#
3. **Validation**: Ensure the modernized code behaves identically to the original

In this document, we will explore the different ways OpenHands contributes to COBOL modernization, with example prompts and techniques to use in your own efforts. While the examples are specific to COBOL, the principles laid out here can help with any legacy system modernization.

## Understanding

A significant challenge in modernization is understanding the business function of the code. Developers have practice determining the "how" of the code, even in legacy systems with unfamiliar syntax and keywords, but understanding the "why" is more important to ensure that business logic is preserved accurately. The difficulty then comes from the fact that business function is only implicitly represented in the code and requires external documentation or domain expertise to untangle.

Fortunately, agents like OpenHands are able to understand source code _and_ process-oriented documentation, and this simultaneous view lets them link the two together in a way that makes every downstream process more transparent and predictable. Your COBOL source might already have some structure or comments that make this link clear, but if not OpenHands can help. If your COBOL source is in `/src` and your process-oriented documentation is in `/docs`, the following prompt will establish a link between the two and save it for future reference:

```
For each COBOL program in `/src`, identify which business functions it supports. Search through the documentation in `/docs` to find all relevant sections describing that business function, and generate a summary of how the program supports that function.

Save the results in `business_functions.json` in the following format:

{
  ...,
  "COBIL00C.cbl": {
    "function": "Bill payment -- pay account balance in full and a transaction action for the online payment",
    "references": [
      "docs/billing.md#bill-payment",
      "docs/transactions.md#transaction-action"
    ],
  },
  ...
}
```

OpenHands uses tools like `grep`, `sed`, and `awk` to navigate files and pull in context. This is natural for source code and also works well for process-oriented documentation, but in some cases exposing the latter using a _semantic search engine_ instead will yield better results. Semantic search engines can understand the meaning behind words and phrases, making it easier to find relevant information.

## Translation

OpenHands can assist with translating COBOL to modern languages:

<Tabs>
  <Tab title="Java">
    **Best for**: Enterprise applications, existing Java ecosystems
    
    ```
    Translate CUSTMGMT.cbl to Java, following these guidelines:
    - Use Java 17 features where appropriate
    - Create separate classes for data structures and business logic
    - Use BigDecimal for all monetary calculations
    - Add JavaDoc comments explaining the original COBOL structure
    - Create a mapping document showing COBOL to Java correspondence
    ```
  </Tab>
  <Tab title="Python">
    **Best for**: Data processing, analytics, rapid prototyping
    
    ```
    Translate RPTGEN.cbl to Python, following these guidelines:
    - Use Python 3.11+ features
    - Use dataclasses for record structures
    - Use Decimal for monetary calculations
    - Preserve the original program's logic flow
    - Add type hints throughout
    ```
  </Tab>
  <Tab title="C#">
    **Best for**: Windows environments, .NET ecosystems
    
    ```
    Translate INVPROC.cbl to C#, following these guidelines:
    - Target .NET 8
    - Use records for data structures
    - Use decimal for monetary values
    - Follow Microsoft naming conventions
    - Add XML documentation comments
    ```
  </Tab>
</Tabs>

### Example Transformation

Here's a COBOL customer management program:

```cobol
1000-MAIN-PROCESS.
    DISPLAY "CUSTOMER MANAGEMENT SYSTEM"
    EVALUATE TRUE
        WHEN OP-ADD
            PERFORM 2000-ADD-CUSTOMER
        WHEN OP-UPDATE
            PERFORM 3000-UPDATE-CUSTOMER
        WHEN OP-DELETE
            PERFORM 4000-DELETE-CUSTOMER
    END-EVALUATE.
```

The agent converts this to idiomatic Java:

```java
public class CustomerManagement {
    public void mainProcess() {
        System.out.println("CUSTOMER MANAGEMENT SYSTEM");
        switch (operation) {
            case ADD -> addCustomer();
            case UPDATE -> updateCustomer();
            case DELETE -> deleteCustomer();
            default -> System.out.println("INVALID OPERATION");
        }
    }
}
```


## Validation


### Behavior Preservation

Ensure modernized code produces identical results:

- **Golden file testing**: Capture COBOL outputs as test expectations
- **Comparison testing**: Run both versions with identical inputs
- **Edge case coverage**: Test boundary conditions and error paths
- **Performance validation**: Verify acceptable performance characteristics

**Example prompt:**
```
Create a test suite to validate the Java translation of PAYROLL.cbl:
1. Extract 100 representative test cases from production data
2. Run both COBOL and Java versions with these inputs
3. Compare outputs field by field
4. Generate a report of any discrepancies
```

### Output Validation

Validate that modernized code produces correct output:

- **Field-level comparison**: Match every output field
- **Format verification**: Ensure reports and files match expected formats
- **Decimal precision**: Verify monetary calculations are exact
- **Date handling**: Confirm date conversions are correct

## Scaling Up

The largest challenge in scaling modernization efforts is dealing with agents' limited attention span. Asking a single agent to handle the entire migration process in one go will almost certainly lead to errors and low-quality code as the context window is filled and flushed again and again. One way to address this is by tying translation and validation together in an iterative refinement loop.

The idea is straightforward: one agent migrates some amount of code, and another agent critiques the migration. If the quality doesn't meet the standards of the critic, the first agent is given some actionable feedback and the process repeats. Here's what that looks like using the [OpenHands SDK](https://github.com/OpenHands/software-agent-sdk):

```python
while current_score < QUALITY_THRESHOLD and iteration < MAX_ITERATIONS:
    # Migrating agent converts COBOL to Java
    migration_conversation.send_message(migration_prompt)
    migration_conversation.run()
    
    # Critiquing agent evaluates the conversion
    critique_conversation.send_message(critique_prompt)
    critique_conversation.run()
    
    # Parse the score and decide whether to continue
    current_score = parse_critique_score(critique_file)
```

By tweaking the critic's prompt and scoring rubric, you can fine-tune the evaluation process to better align with your needs. For example, you might have code quality standards that are difficult to detect with static analysis tools or architectural patterns that are unique to your organization. The following prompt can be easily modified to support a wide range of requirements:

```
Evaluate the quality of the COBOL to Java migration in `/src`.

For each Java file, assess using the following criteria:
1. Correctness: Does the Java code preserve the original business logic (see `business_functions.json`)?
2. Code Quality: Is the code clean, readable, and following Java 17 conventions?
3. Completeness: Are all COBOL features properly converted?
4. Best Practices: Does it use proper OOP, error handling, and documentation?

For each instance of a criteria not met, deduct a point.

Then generate a report containing actionable feedback for each file. The feedback, if addressed, should improve the score.

Save the results in `critique.json` in the following format:

{
  "total_score": -12,
  "files": [
    {
      "cobol": "COBIL00C.cbl",
      "java": "bill_payment.java",
      "scores": {
        "correctness": 0,
        "code_quality": 0,
        "completeness": -1,
        "best_practices": -2
      },
      "feedback": [
        "Rename single-letter variables to meaningful names.",
        "Ensure all COBOL functionality is translated -- the transaction action for the bill payment is missing.",
      ],
    },
    ...
  ]
}
```

In future iterations, the migration agent should be given the file `critique.json` and be prompted to act on the feedback.

This iterative refinement pattern works well for medium-sized projects with a moderate level of complexity. For legacy systems that span hundreds of files, however, the migration and critique processes need to be further decomposed to prevent agents from being overwhelmed. A natural way to do so is to break the system into smaller components, each with its own migration and critique processes. This process can be automated by using the OpenHands large codebase SDK, which combines agentic intelligence with static analysis tools to decompose large projects and orchestrate parallel agents in a dependency-aware manner.

## Try It Yourself

The full iterative refinement example is available in the OpenHands SDK:

```bash
export LLM_API_KEY="your-api-key"
cd software-agent-sdk
uv run python examples/01_standalone_sdk/31_iterative_refinement.py
```

For real-world COBOL files, you can use the [AWS CardDemo application](https://github.com/aws-samples/aws-mainframe-modernization-carddemo/tree/main/app/cbl), which provides a representative mainframe application for testing modernization approaches.


## Related Resources

- [OpenHands SDK Repository](https://github.com/OpenHands/software-agent-sdk) - Build custom AI agents
- [AWS CardDemo Application](https://github.com/aws-samples/aws-mainframe-modernization-carddemo/tree/main/app/cbl) - Sample COBOL application for testing
- [Prompting Best Practices](/openhands/usage/tips/prompting-best-practices) - Write effective prompts
