---
title: TODO-Vulnerability Remediation
description: Using OpenHands to identify and fix security vulnerabilities in your codebase
---

Security vulnerabilities in your code can lead to data breaches, system compromises, and compliance failures. OpenHands can help you identify vulnerabilities, understand their impact, and implement secure fixes quickly and effectively.

## Overview

OpenHands assists with vulnerability remediation by:

- **Identifying vulnerabilities**: Analyzing code for common security issues
- **Understanding impact**: Explaining the risk and exploitation potential
- **Implementing fixes**: Generating secure code to address vulnerabilities
- **Validating remediation**: Verifying fixes are effective and complete

## Identifying Vulnerabilities

### Security Scanning Integration

Use OpenHands to analyze security scanner output:

```
We ran a security scan and found these issues. Analyze each one:

1. SQL Injection in src/api/users.py:45
2. XSS in src/templates/profile.html:23
3. Hardcoded credential in src/config/database.py:12
4. Path traversal in src/handlers/files.py:67

For each vulnerability:
- Explain what the vulnerability is
- Show how it could be exploited
- Rate the severity (Critical/High/Medium/Low)
- Suggest a fix
```

### Vulnerability Detection Workflows

Ask OpenHands to scan for specific vulnerability types:

```
Scan this codebase for OWASP Top 10 vulnerabilities:

1. Injection flaws (SQL, NoSQL, OS command, LDAP)
2. Broken authentication
3. Sensitive data exposure
4. XML external entities (XXE)
5. Broken access control
6. Security misconfiguration
7. Cross-site scripting (XSS)
8. Insecure deserialization
9. Using components with known vulnerabilities
10. Insufficient logging and monitoring

Report findings with file locations and severity ratings.
```

### Common Vulnerability Patterns

OpenHands can detect these common vulnerability patterns:

| Vulnerability | Pattern | Example |
|--------------|---------|---------|
| SQL Injection | String concatenation in queries | `query = "SELECT * FROM users WHERE id=" + user_id` |
| XSS | Unescaped user input in HTML | `<div>${user_comment}</div>` |
| Path Traversal | Unvalidated file paths | `open(user_supplied_path)` |
| Command Injection | Shell commands with user input | `os.system("ping " + hostname)` |
| Hardcoded Secrets | Credentials in source code | `password = "admin123"` |

**Detection prompt:**

```
Search this repository for:
1. Hardcoded passwords, API keys, or secrets
2. SQL queries using string concatenation
3. Shell commands using user input
4. File operations with unvalidated paths
5. HTML output without proper escaping

List all findings with file locations.
```

## Automated Remediation

### Applying Security Patches

Fix identified vulnerabilities:

<Tabs>
  <Tab title="SQL Injection">
    ```
    Fix the SQL injection vulnerability in src/api/users.py:
    
    Current code:
    query = f"SELECT * FROM users WHERE id = {user_id}"
    cursor.execute(query)
    
    Requirements:
    1. Use parameterized queries
    2. Add input validation
    3. Maintain the same functionality
    4. Add a test case for the fix
    ```
    
    **Fixed code:**
    ```python
    # Using parameterized query
    query = "SELECT * FROM users WHERE id = %s"
    cursor.execute(query, (user_id,))
    ```
  </Tab>
  <Tab title="XSS">
    ```
    Fix the XSS vulnerability in src/templates/profile.html:
    
    Current code:
    <div class="bio">${user.bio}</div>
    
    Requirements:
    1. Properly escape user content
    2. Consider Content Security Policy
    3. Handle rich text if needed
    4. Test with malicious input
    ```
    
    **Fixed code:**
    ```html
    <!-- Using auto-escaping template engine -->
    <div class="bio">{{ user.bio | escape }}</div>
    ```
  </Tab>
  <Tab title="Command Injection">
    ```
    Fix the command injection in src/utils/network.py:
    
    Current code:
    def ping_host(hostname):
        os.system(f"ping -c 1 {hostname}")
    
    Requirements:
    1. Use safe subprocess calls
    2. Validate input format
    3. Avoid shell=True
    4. Handle errors properly
    ```
    
    **Fixed code:**
    ```python
    import subprocess
    import re
    
    def ping_host(hostname):
        # Validate hostname format
        if not re.match(r'^[a-zA-Z0-9.-]+$', hostname):
            raise ValueError("Invalid hostname")
        
        # Use subprocess without shell
        result = subprocess.run(
            ["ping", "-c", "1", hostname],
            capture_output=True,
            text=True
        )
        return result.returncode == 0
    ```
  </Tab>
</Tabs>

### Dependency Updates for Security Fixes

Address vulnerable dependencies:

```
We have CVE-2023-12345 affecting lodash < 4.17.21.

1. Check our current lodash version
2. Identify all files importing lodash
3. Update to the patched version
4. Check for breaking changes
5. Run tests to verify nothing broke
6. Update package-lock.json
```

### Code-Level Vulnerability Fixes

Fix application-level security issues:

```
Fix the broken access control in our API:

Issue: Users can access other users' data by changing the ID in the URL.

Current code:
@app.get("/api/users/{user_id}/documents")
def get_documents(user_id: int):
    return db.get_documents(user_id)

Requirements:
1. Add authorization check
2. Verify requesting user matches or is admin
3. Return 403 for unauthorized access
4. Log access attempts
5. Add tests for authorization
```

**Fixed code:**

```python
@app.get("/api/users/{user_id}/documents")
def get_documents(user_id: int, current_user: User = Depends(get_current_user)):
    # Check authorization
    if current_user.id != user_id and not current_user.is_admin:
        logger.warning(f"Unauthorized access attempt: user {current_user.id} tried to access user {user_id}'s documents")
        raise HTTPException(status_code=403, detail="Not authorized")
    
    return db.get_documents(user_id)
```

## Best Practices

### Security Testing

Test your fixes thoroughly:

```
Create security tests for the SQL injection fix:

1. Test with normal input
2. Test with SQL injection payloads:
   - ' OR '1'='1
   - '; DROP TABLE users; --
   - UNION SELECT * FROM passwords
3. Test with special characters
4. Test with null/empty input
5. Verify error handling doesn't leak information
```

**Example test suite:**

```python
import pytest

class TestSQLInjectionPrevention:
    def test_normal_query(self):
        result = get_user(1)
        assert result.id == 1
    
    def test_injection_attempt_or(self):
        # Should return no results, not all users
        result = get_user("1 OR 1=1")
        assert result is None
    
    def test_injection_attempt_union(self):
        result = get_user("1 UNION SELECT * FROM passwords")
        assert result is None
    
    def test_injection_attempt_comment(self):
        result = get_user("1; DROP TABLE users; --")
        # Table should still exist
        assert User.query.count() > 0
```

### Validation Approaches

Verify your remediation is complete:

```
Validate that the XSS fix is effective:

1. Test common XSS payloads:
   - <script>alert('xss')</script>
   - <img src=x onerror=alert('xss')>
   - javascript:alert('xss')
   - <svg onload=alert('xss')>

2. Test encoding bypass attempts:
   - &#60;script&#62;
   - \u003cscript\u003e
   - %3Cscript%3E

3. Test context-specific attacks:
   - Attribute injection
   - Event handler injection
   - URL scheme injection

4. Verify Content Security Policy is set
5. Confirm X-XSS-Protection header is present
```

### Continuous Monitoring

Set up ongoing security monitoring:

```
Create a security monitoring workflow:

1. Add SAST (Static Application Security Testing) to CI:
   - Run on every pull request
   - Block merge on critical findings
   - Report all findings to security team

2. Add dependency scanning:
   - Check for vulnerable dependencies daily
   - Create tickets for new vulnerabilities
   - Auto-create PRs for safe updates

3. Add secrets scanning:
   - Pre-commit hook for secret detection
   - Block commits containing secrets
   - Alert on any secrets found in history

4. Create security dashboard:
   - Track vulnerability counts over time
   - Monitor mean time to remediation
   - Track security test coverage
```

## Vulnerability Categories

### Injection Vulnerabilities

```
Audit this codebase for injection vulnerabilities:

Check for:
1. SQL injection (parameterized queries?)
2. NoSQL injection (MongoDB query injection?)
3. Command injection (shell command building?)
4. LDAP injection (LDAP query construction?)
5. Expression Language injection (template injection?)
6. Header injection (CRLF in headers?)

For each finding:
- Show the vulnerable code
- Explain the attack vector
- Provide the fix
- Add a regression test
```

### Authentication Issues

```
Review authentication implementation for vulnerabilities:

Check for:
1. Weak password policies
2. Missing brute force protection
3. Session fixation vulnerabilities
4. Insecure password storage (not bcrypt/argon2?)
5. Missing multi-factor authentication
6. Insecure "remember me" implementation
7. Password reset vulnerabilities

Provide recommendations for each issue found.
```

### Authorization Flaws

```
Audit authorization controls:

Check for:
1. Broken access control (IDOR)
2. Missing function-level access control
3. Privilege escalation paths
4. JWT vulnerabilities (algorithm confusion, weak secrets)
5. OAuth misconfigurations
6. CORS misconfigurations

Test each endpoint for unauthorized access.
```

### Data Exposure

```
Check for sensitive data exposure:

1. Are secrets hardcoded anywhere?
2. Is sensitive data logged?
3. Is PII properly encrypted at rest?
4. Is data encrypted in transit (TLS)?
5. Are error messages leaking information?
6. Is sensitive data in URLs (logged by proxies)?
7. Are backups encrypted?

List all findings with severity ratings.
```

## Examples

### Critical Vulnerability Fix

```
We have a critical remote code execution vulnerability:

File: src/api/upload.py
Issue: Arbitrary file upload allows code execution

Current code:
def upload_file(file):
    filename = file.filename
    file.save(os.path.join(UPLOAD_DIR, filename))
    return {"message": "Upload successful"}

Fix this vulnerability:
1. Validate file extension against whitelist
2. Sanitize filename (remove path traversal)
3. Generate random filename
4. Scan file content for malicious patterns
5. Store outside web root
6. Add proper error handling
```

### Comprehensive Security Audit

```
Perform a comprehensive security audit of our authentication system:

Files to review:
- src/auth/login.py
- src/auth/session.py
- src/auth/password.py
- src/middleware/auth.py

Check for:
1. OWASP Authentication Cheat Sheet compliance
2. Password storage best practices
3. Session management security
4. Brute force protection
5. Account lockout mechanisms
6. Secure cookie settings
7. CSRF protection

Provide a report with findings and fixes.
```

### Automated Remediation Pipeline

```
Create an automated vulnerability remediation pipeline:

1. Parse Snyk/Dependabot/CodeQL alerts
2. Categorize by severity and type
3. For each vulnerability:
   - Create a branch
   - Apply the fix
   - Run tests
   - Create a PR with:
     - Description of vulnerability
     - Fix applied
     - Test results
4. Request review from security team
5. Auto-merge low-risk fixes after tests pass
```

## Related Resources

- [Security](/openhands/usage/admin/security) - Comprehensive security overview
- [Dependency Upgrades](/openhands/usage/use-cases/dependency-upgrades) - Updating vulnerable dependencies
- [Prompting Best Practices](/openhands/usage/tips/prompting-best-practices) - Write effective prompts
