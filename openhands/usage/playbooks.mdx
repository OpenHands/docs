---
title: Playbooks & Reusable Prompts
description: Create and use reusable prompt templates for common tasks
---

## Overview

Playbooks are reusable prompt templates that help you consistently execute common tasks. By creating playbooks, you can ensure quality, save time, and share best practices with your team.

## What is a Playbook?

A playbook is a structured prompt template that:
- Defines a repeatable task
- Includes necessary context
- Specifies expected outcomes
- Can be customized for specific use cases

### Playbook vs. One-Off Prompt

| One-Off Prompt | Playbook |
|----------------|----------|
| Written for immediate use | Designed for reuse |
| Includes all context inline | Parameterized for flexibility |
| Variable quality | Consistent structure |
| Individual knowledge | Team-shared knowledge |

## Creating Effective Playbooks

### Basic Structure

A good playbook includes:

```markdown
## [Playbook Name]

### Purpose
What this playbook accomplishes

### Prerequisites
- Required setup
- Necessary files or access

### Parameters
- `{param1}`: Description
- `{param2}`: Description

### Prompt Template
The actual prompt with parameters

### Expected Outcome
What success looks like

### Verification Steps
How to verify completion
```

### Example: Add API Endpoint Playbook

```markdown
## Add REST API Endpoint

### Purpose
Add a new REST API endpoint following project conventions

### Prerequisites
- Express.js route structure in place
- Database models defined
- Test framework configured

### Parameters
- `{resource}`: The resource name (e.g., "users", "products")
- `{method}`: HTTP method (GET, POST, PUT, DELETE)
- `{path}`: The endpoint path
- `{description}`: What the endpoint does

### Prompt Template
Add a {method} endpoint at {path} for {resource}.

Requirements:
- Follow the existing route patterns in src/routes/
- Add input validation using our validation middleware
- Include proper error handling following patterns in src/utils/errors.js
- Add corresponding test in src/tests/routes/
- Update the API documentation in docs/api.md

The endpoint should {description}.

### Expected Outcome
- New route handler in appropriate file
- Input validation implemented
- Error handling in place
- Passing test coverage
- Documentation updated

### Verification Steps
1. Run `npm test` - all tests pass
2. Run `npm run lint` - no errors
3. Manual test with curl/Postman
4. Review generated documentation
```

## Common Playbook Templates

### 1. Bug Fix Playbook

```markdown
## Bug Fix

### Parameters
- `{issue}`: Bug description or issue number
- `{file}`: Affected file(s) if known
- `{reproduction}`: Steps to reproduce

### Prompt Template
Fix the bug: {issue}

Context:
- Affected files: {file}
- Reproduction steps: {reproduction}

Requirements:
1. First, reproduce the bug to confirm understanding
2. Identify the root cause
3. Implement the fix with minimal changes
4. Add a regression test
5. Verify existing tests still pass
6. Document what was changed and why

### Verification Steps
1. Run the reproduction steps - bug no longer occurs
2. Run `npm test` - all tests pass including new regression test
3. Run `npm run lint` - no new warnings
```

### 2. Add Test Coverage Playbook

```markdown
## Add Test Coverage

### Parameters
- `{module}`: The module/file to test
- `{coverage_target}`: Desired coverage percentage

### Prompt Template
Write comprehensive tests for {module} to achieve {coverage_target}% coverage.

Requirements:
1. Analyze the existing code to understand all code paths
2. Write tests for:
   - Happy path scenarios
   - Edge cases
   - Error conditions
   - Boundary values
3. Follow existing test patterns in the codebase
4. Use meaningful test descriptions
5. Avoid testing implementation details

### Verification Steps
1. Run coverage report: `npm run test:coverage`
2. Verify {coverage_target}% coverage achieved
3. Review tests for quality, not just quantity
```

### 3. Code Refactoring Playbook

```markdown
## Refactor Module

### Parameters
- `{target}`: File or function to refactor
- `{goal}`: What improvement to achieve
- `{pattern}`: Desired pattern or approach

### Prompt Template
Refactor {target} to {goal}.

Use the {pattern} pattern where appropriate.

Requirements:
1. First, write tests for existing behavior if not present
2. Make changes incrementally
3. Ensure all existing tests pass after each change
4. Improve code readability and maintainability
5. Do not change external interfaces without discussion
6. Document any non-obvious decisions

### Verification Steps
1. All existing tests pass
2. No new lint warnings
3. Code review checklist:
   - [ ] Logic is correct
   - [ ] Code is readable
   - [ ] No duplication introduced
   - [ ] Follows project patterns
```

### 4. Documentation Playbook

```markdown
## Add Documentation

### Parameters
- `{target}`: File or module to document
- `{type}`: Type of documentation (JSDoc, README, API docs)

### Prompt Template
Add {type} documentation to {target}.

Requirements:
1. Document all public functions/methods
2. Include:
   - Description of purpose
   - Parameter descriptions with types
   - Return value description
   - Example usage where helpful
3. Follow existing documentation style in the codebase
4. Keep explanations clear and concise

### Verification Steps
1. Documentation lint passes (if applicable)
2. Generated docs render correctly
3. Examples are accurate and runnable
```

### 5. Database Migration Playbook

```markdown
## Create Database Migration

### Parameters
- `{change}`: Description of schema change
- `{tables}`: Affected tables

### Prompt Template
Create a database migration to {change}.

Affected tables: {tables}

Requirements:
1. Create both up and down migrations
2. Handle existing data appropriately
3. Consider performance on large tables
4. Add comments explaining the migration
5. Update relevant model files
6. Add or update tests for affected models

### Verification Steps
1. Migration runs successfully: `npm run db:migrate`
2. Rollback works: `npm run db:rollback`
3. Data integrity maintained
4. Model tests pass
```

## Using Playbooks

### Direct Use

Copy the prompt template, fill in parameters:

```
Add a GET endpoint at /api/v1/products/{id} for products.

Requirements:
- Follow the existing route patterns in src/routes/
- Add input validation using our validation middleware
- Include proper error handling following patterns in src/utils/errors.js
- Add corresponding test in src/tests/routes/
- Update the API documentation in docs/api.md

The endpoint should return a single product by ID with all its details.
```

### With Skills

Store playbooks in your repository Skills for automatic context:

```markdown
<!-- .openhands/microagents/repo.md -->

# Standard Playbooks

## When adding API endpoints:
1. Follow route patterns in src/routes/
2. Add validation middleware
3. Include error handling from src/utils/errors.js
4. Write tests in src/tests/routes/
5. Update docs/api.md

## When fixing bugs:
1. Reproduce first
2. Add failing test
3. Implement fix
4. Verify test passes
```

## Building a Playbook Library

### Organize by Category

```
playbooks/
├── api/
│   ├── add-endpoint.md
│   ├── add-authentication.md
│   └── versioning.md
├── testing/
│   ├── unit-tests.md
│   ├── integration-tests.md
│   └── e2e-tests.md
├── refactoring/
│   ├── extract-function.md
│   ├── rename-module.md
│   └── split-component.md
└── documentation/
    ├── jsdoc.md
    ├── readme.md
    └── api-docs.md
```

### Version and Iterate

Track playbook effectiveness:
- Which playbooks work best?
- What clarifications are commonly needed?
- How can prompts be improved?

### Share with Team

Establish team playbooks:
1. Start with individual playbooks
2. Share successful ones
3. Standardize common tasks
4. Store in shared documentation

## Best Practices

### 1. Be Specific About Patterns

Instead of:
```
❌ "Follow best practices"
```

Specify:
```
✅ "Follow the error handling pattern in src/utils/errors.js"
✅ "Use the same test structure as UserService.test.js"
```

### 2. Include Verification

Always include how to verify success:
```
### Verification Steps
1. Run tests: `npm test`
2. Check linting: `npm run lint`
3. Manual verification: [specific steps]
```

### 3. Reference Existing Code

Point to examples in your codebase:
```
"Follow the same patterns as the existing UserController"
"Use the validation approach from src/middleware/validation.js"
```

### 4. Keep Playbooks Updated

Review and update playbooks when:
- Project patterns change
- New conventions are adopted
- Common issues are discovered
- Better approaches are found

## Example Playbooks Collection

### Quick Reference

| Task | Key Points |
|------|------------|
| **Add Feature** | Specify files, follow patterns, include tests |
| **Fix Bug** | Reproduce first, add regression test |
| **Add Tests** | Target coverage, test edge cases |
| **Refactor** | Tests first, incremental changes |
| **Document** | Follow style, include examples |
| **Migrate DB** | Up/down migrations, handle data |

### Starter Playbook Set

Download our [starter playbook templates](https://github.com/OpenHands/playbook-templates) to begin building your library.

## See Also

- [Skills](/overview/skills) - Permanent repository context
- [Writing Effective Instructions](/openhands/usage/tips/effective-instructions)
- [Repository Customization](/openhands/usage/customization/repository)
- [Prompting Best Practices](/openhands/usage/tips/prompting-best-practices)
