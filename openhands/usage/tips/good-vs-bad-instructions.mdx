---
title: "Good vs Bad Instructions"
sidebarTitle: "Good vs Bad Instructions"
description: "Examples of effective and ineffective instructions for OpenHands"
---

# Good vs Bad Instructions

Learn from real examples what makes instructions effective—and what causes them to fail.

## Bug Fixing Examples

### Example 1: Login Error

<Tabs>
  <Tab title="❌ Bad">
    ```
    The login is broken, fix it
    ```
    
    **Why it fails:**
    - No description of the actual problem
    - No reproduction steps
    - No indication of where to look
    - No way to verify the fix
  </Tab>
  <Tab title="✅ Good">
    ```
    Fix the login authentication error.

    Problem: Users receive "Invalid credentials" even with correct 
    username/password. The issue started after commit abc123.

    To reproduce:
    1. Go to /login
    2. Enter: test@example.com / password123
    3. Click "Sign In"
    4. Error appears even though credentials are valid in the database

    Suspected cause: The password hashing was changed but the 
    comparison logic wasn't updated.

    Files to check:
    - src/auth/login.py
    - src/utils/password.py

    Verify fix by:
    1. Running: pytest tests/test_auth.py
    2. Manually testing login with test credentials
    ```
  </Tab>
</Tabs>

### Example 2: API Response Error

<Tabs>
  <Tab title="❌ Bad">
    ```
    The API returns wrong data sometimes
    ```
  </Tab>
  <Tab title="✅ Good">
    ```
    Fix inconsistent API response format for /api/users/{id}

    Current behavior:
    - Sometimes returns: {"user": {"id": 1, "name": "John"}}
    - Sometimes returns: {"id": 1, "name": "John"}

    Expected behavior:
    - Always return: {"user": {"id": 1, "name": "John"}}

    The inconsistency happens because some code paths use 
    user.to_dict() directly while others wrap it in {"user": ...}

    Fix by ensuring all return paths in src/api/users.py use 
    the UserResponse schema from src/schemas/user.py
    ```
  </Tab>
</Tabs>

## Feature Implementation Examples

### Example 3: Adding a Feature

<Tabs>
  <Tab title="❌ Bad">
    ```
    Add email notifications
    ```
    
    **Why it fails:**
    - No specification of what triggers notifications
    - No template requirements
    - No indication of email service to use
    - No scope boundaries
  </Tab>
  <Tab title="✅ Good">
    ```
    Add email notification when a user's order ships.

    Requirements:
    1. Send email when order status changes to "shipped"
    2. Use the existing EmailService in src/services/email.py
    3. Email should include:
       - Order number
       - Tracking number
       - Estimated delivery date
       - List of items

    Template location: Create new template at 
    templates/emails/order_shipped.html

    Trigger: Add to the update_order_status() method in 
    src/services/order.py

    Configuration: Use existing SMTP settings from config.py

    Tests: Add tests in tests/test_order_notifications.py
    
    Do NOT modify:
    - The Order model
    - Existing email templates
    - The email service itself
    ```
  </Tab>
</Tabs>

### Example 4: UI Component

<Tabs>
  <Tab title="❌ Bad">
    ```
    Make a nice dashboard
    ```
  </Tab>
  <Tab title="✅ Good">
    ```
    Create a sales dashboard component showing monthly metrics.

    Component: src/components/SalesDashboard.tsx

    Required sections:
    1. Summary cards showing:
       - Total revenue (from /api/metrics/revenue)
       - Order count (from /api/metrics/orders)
       - Average order value (calculated)
    
    2. Line chart showing daily sales for the current month
       - Use the existing Chart component from src/components/Chart
       - Data from /api/metrics/daily-sales

    Styling:
    - Follow existing Tailwind patterns in other dashboard components
    - Use the Card component from src/components/ui/Card
    - Responsive: stack on mobile, grid on desktop

    Loading states:
    - Show skeleton loaders while data fetches
    - Show error state if API calls fail

    Tests: Add component tests in __tests__/SalesDashboard.test.tsx
    ```
  </Tab>
</Tabs>

## Refactoring Examples

### Example 5: Code Cleanup

<Tabs>
  <Tab title="❌ Bad">
    ```
    Clean up the utils folder
    ```
  </Tab>
  <Tab title="✅ Good">
    ```
    Refactor src/utils/ to remove duplicate helper functions.

    Analysis needed:
    1. Find duplicate or near-duplicate functions across:
       - src/utils/string.py
       - src/utils/format.py
       - src/utils/helpers.py

    Actions:
    1. Consolidate string formatting functions into src/utils/string.py
    2. Remove duplicates, keeping the most complete implementation
    3. Update all imports in the codebase
    4. Add type hints to all consolidated functions
    5. Add docstrings following Google style

    Constraints:
    - Maintain backward compatibility (keep function signatures)
    - All existing tests must pass
    - Do not rename any public functions

    Verify:
    - Run: pytest tests/
    - Run: mypy src/utils/
    ```
  </Tab>
</Tabs>

### Example 6: Architecture Change

<Tabs>
  <Tab title="❌ Bad">
    ```
    We need to use TypeScript now
    ```
  </Tab>
  <Tab title="✅ Good">
    ```
    Migrate src/components/Button.jsx to TypeScript.

    Steps:
    1. Rename Button.jsx to Button.tsx
    2. Add TypeScript types for all props:
       - variant: 'primary' | 'secondary' | 'danger'
       - size: 'sm' | 'md' | 'lg'
       - disabled: boolean
       - onClick: (event: MouseEvent) => void
       - children: ReactNode

    3. Export the Props type as ButtonProps
    4. Update imports in files that use Button
    5. Run type checking: npx tsc --noEmit

    Follow the pattern established in src/components/Input.tsx 
    for type definitions.

    Do NOT migrate other components in this task.
    ```
  </Tab>
</Tabs>

## Test Writing Examples

### Example 7: Adding Tests

<Tabs>
  <Tab title="❌ Bad">
    ```
    Add tests for the user module
    ```
  </Tab>
  <Tab title="✅ Good">
    ```
    Add unit tests for UserService.create_user() method.

    Location: tests/services/test_user_service.py

    Test cases to cover:
    1. Successful user creation with valid data
    2. Failure when email already exists (expect DuplicateEmailError)
    3. Failure when password is too short (expect ValidationError)
    4. Failure when required fields are missing
    5. Verify password is hashed before storing

    Test setup:
    - Use pytest fixtures from conftest.py
    - Mock the database with the existing mock_db fixture
    - Use factory_boy for test data (see tests/factories.py)

    Assertions should verify:
    - Return value matches expected user object
    - Database method was called with correct arguments
    - Appropriate exceptions are raised with correct messages
    ```
  </Tab>
</Tabs>

## Common Patterns

### The Context-Task-Verify Pattern

Structure your instructions with these three sections:

```markdown
## Context
[Background information, relevant files, existing patterns]

## Task
[Specific changes to make, with clear scope]

## Verify
[How to confirm the task is complete and correct]
```

### The Problem-Solution-Constraints Pattern

For bug fixes:

```markdown
## Problem
[What's wrong, how to reproduce]

## Solution
[Expected fix approach or outcome]

## Constraints
[What should NOT change, compatibility requirements]
```

## Quick Reference

| Aspect | ❌ Avoid | ✅ Do |
|--------|---------|-------|
| Scope | "Fix everything" | "Fix X in file Y" |
| Details | "Make it better" | "Change A to B because C" |
| Verification | (none) | "Run tests, check output" |
| Context | Assumptions | Explicit file paths, patterns |
| Boundaries | Open-ended | "Only modify these files" |

## Next Steps

<CardGroup cols={2}>
  <Card title="Prompting Best Practices" icon="lightbulb" href="/openhands/usage/tips/prompting-best-practices">
    More tips for effective prompting
  </Card>
  <Card title="When to Use OpenHands" icon="clock" href="/openhands/usage/tips/when-to-use-openhands">
    Learn which tasks work best with OpenHands
  </Card>
</CardGroup>
