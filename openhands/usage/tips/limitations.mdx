---
title: Limitations & Best Fit Tasks
description: Understanding what OpenHands excels at and current limitations
---

## Overview

Understanding OpenHands' strengths and limitations helps you choose the right tasks and set appropriate expectations. This guide provides an honest assessment of current capabilities.

## What OpenHands Excels At

### ✅ Well-Defined Code Changes

OpenHands performs best with clear, specific tasks:

| Task Type | Why It Works Well |
|-----------|-------------------|
| Adding new endpoints | Clear requirements, testable output |
| Writing tests | Analyzable patterns, verifiable results |
| Bug fixes with reproduction | Clear success criteria |
| Refactoring specific code | Bounded scope, measurable improvement |
| Documentation updates | Straightforward content creation |

**Examples of Excellent Tasks:**
```
✅ "Add a GET /api/users/:id endpoint that returns user details"
✅ "Write unit tests for the PaymentService class"
✅ "Fix the null pointer exception in the login handler"
✅ "Convert callback-based functions in utils.js to async/await"
✅ "Add JSDoc comments to all exported functions"
```

### ✅ Code That Follows Patterns

Tasks involving established patterns are handled effectively:
- Following existing code style
- Implementing similar features to existing ones
- Creating files matching existing templates
- Adding to established test suites

### ✅ Single-Repository Tasks

OpenHands works within one repository at a time:
- All necessary files are accessible
- Context is contained and manageable
- Changes can be tested in isolation

### ✅ Tasks with Clear Success Criteria

The agent performs better when it can verify its work:
- Tests pass/fail
- Linting succeeds
- Build completes
- Expected output is produced

## Current Limitations

### ⚠️ Complex Multi-Step Reasoning

Tasks requiring extensive planning across many files may need guidance:

```
⚠️ "Redesign the entire authentication system to use OAuth2"

Better approach:
1. "Analyze the current auth system and list all affected files"
2. "Create the OAuth2 provider configuration"
3. "Update the login endpoint to support OAuth2"
4. "Migrate the session management"
5. "Update all affected tests"
```

### ⚠️ Highly Ambiguous Requirements

Vague tasks lead to uncertain results:

```
❌ "Make the code better"
❌ "Improve performance"
❌ "Clean up the codebase"

✅ "Refactor the processOrders function to reduce complexity"
✅ "Add database query caching to the product list endpoint"
✅ "Remove unused imports and dead code from the utils folder"
```

### ⚠️ Cross-Repository Changes

OpenHands operates in a single repository context:
- Can't modify multiple repositories simultaneously
- Can't coordinate changes across microservices
- External API dependencies need to be mocked or available

**Workaround:** Make changes in each repository separately, coordinating manually.

### ⚠️ Real-Time External Services

Tasks requiring live external services may face challenges:
- Third-party APIs with authentication
- Live database migrations on production
- Services requiring network access not available in the sandbox

**Workaround:** Use mocks, test environments, or configure the sandbox appropriately.

### ⚠️ Long-Running Processes

Tasks that require extended execution time:
- Complete test suites that take hours
- Large data migrations
- Extended build processes

**Workaround:** Break into smaller, verifiable chunks.

### ⚠️ UI/Visual Design Tasks

While OpenHands can write UI code, it has limitations in:
- Judging visual aesthetics
- Pixel-perfect implementations
- Complex responsive design

**Workaround:** Provide specific design specs, use the browser preview for verification.

## Task Complexity Guidelines

### Simple Tasks (High Success Rate)

Single-file changes, clear requirements:
- Add a function
- Fix a specific bug
- Update documentation
- Add test cases

Estimated time: 2-5 minutes

### Medium Tasks (Good Success Rate)

Multiple related files, clear patterns:
- Add a new feature module
- Implement an API endpoint with tests
- Refactor a specific component
- Set up a new configuration

Estimated time: 5-15 minutes

### Complex Tasks (Requires Guidance)

System-wide changes, architectural decisions:
- Major refactoring
- New architectural patterns
- Multi-component features
- Migration projects

Estimated time: 15+ minutes, often broken into steps

## Best Fit Task Examples

### Ideal for OpenHands

| Task | Why It's Ideal |
|------|----------------|
| "Add input validation to the registration form" | Bounded scope, clear requirements |
| "Write integration tests for the order API" | Pattern-following, verifiable |
| "Migrate from Moment.js to Day.js" | Clear transformation rules |
| "Add error handling to all API endpoints" | Repetitive, well-defined |
| "Create TypeScript types for the API responses" | Generatable from existing code |

### Use with Guidance

| Task | How to Approach |
|------|-----------------|
| "Implement user authentication" | Break into: login, session, middleware |
| "Optimize database queries" | First: "Identify slow queries", then fix each |
| "Set up CI/CD pipeline" | Step-by-step: config, tests, deploy |

### Better Done Manually

| Task | Why |
|------|-----|
| Initial project architecture decisions | Requires human judgment and discussion |
| Sensitive security configurations | Needs careful human review |
| Production database migrations | Risk too high for automation |
| Complex business logic decisions | Requires domain expertise |

## Scoping Tasks Appropriately

### The SMART Framework for Tasks

**S - Specific:** Clear, unambiguous description
```
❌ "Fix the bug"
✅ "Fix the TypeError on line 45 of userService.js"
```

**M - Measurable:** Verifiable success criteria
```
❌ "Improve test coverage"
✅ "Add tests to achieve 80% coverage for authModule"
```

**A - Achievable:** Within OpenHands' capabilities
```
❌ "Rewrite the entire application"
✅ "Rewrite the authentication module using the new patterns"
```

**R - Relevant:** Appropriate files are accessible
```
❌ "Update the mobile app too"
✅ "Update the web API that the mobile app calls"
```

**T - Time-bounded:** Reasonable scope
```
❌ "Fix all the bugs"
✅ "Fix the three bugs in the current sprint"
```

### Breaking Down Large Tasks

**Original (Too Large):**
```
"Implement a complete e-commerce checkout system"
```

**Broken Down (Appropriate):**
```
1. "Create the Cart model and database schema"
2. "Add API endpoints for cart operations (add, remove, update)"
3. "Implement the checkout flow service"
4. "Add payment gateway integration"
5. "Create order confirmation and email notifications"
6. "Write tests for the checkout flow"
```

## Setting Expectations

### What to Expect

| Expectation | Reality |
|-------------|---------|
| Perfect code on first try | Often needs 1-2 iterations |
| Understanding all context | May need clarification |
| Following all conventions | Works better with Skills/guidance |
| Handling all edge cases | Benefits from specific instructions |

### Iteration is Normal

Most tasks follow this pattern:
1. Initial implementation (80% correct)
2. Review and feedback
3. Refinement (95% correct)
4. Final polish (done)

This iterative process is normal and efficient.

## Maximizing Success

### Before Starting

1. **Check task fit:** Is this appropriate for OpenHands?
2. **Gather context:** What does the agent need to know?
3. **Define success:** How will you verify completion?

### During Execution

1. **Monitor progress:** Watch for early issues
2. **Provide feedback:** Redirect if needed
3. **Break down:** Split complex tasks if stuck

### After Completion

1. **Review changes:** Check all modified files
2. **Run tests:** Verify nothing is broken
3. **Test manually:** Spot-check functionality

## See Also

- [When to Use OpenHands](/openhands/usage/tips/when-to-use-openhands)
- [Writing Effective Instructions](/openhands/usage/tips/effective-instructions)
- [Good vs Bad Instructions](/openhands/usage/tips/good-vs-bad-instructions)
- [SDLC Integration](/openhands/usage/sdlc-integration)
