---
title: Custom Visualizer
description: Customize conversation visualization with custom highlighting patterns and display options.
---

<Note>
This example is available on GitHub: [examples/01_standalone_sdk/26_custom_visualizer.py](https://github.com/OpenHands/software-agent-sdk/blob/main/examples/01_standalone_sdk/26_custom_visualizer.py)
</Note>

Learn how to create effective custom visualizers by understanding the event system and implementing your own visualization logic. This guide teaches you to build visualizers that range from simple highlighting to complete custom interfaces.

The comprehensive example below demonstrates a production-ready custom visualizer that tracks conversation progress with minimal output. We'll break down the key concepts and best practices used in this implementation.

```python icon="python" expandable examples/01_standalone_sdk/26_custom_visualizer.py
"""Custom Visualizer Example

This example demonstrates how to create and use a custom visualizer by subclassing
ConversationVisualizer. This approach provides:
- Clean, testable code with class-based state management
- Direct configuration (just pass the visualizer instance to visualize parameter)
- Reusable visualizer that can be shared across conversations
- Better separation of concerns compared to callback functions

The MinimalProgressVisualizer produces concise output showing:
- LLM call completions
- Tool execution steps with command/path details
- Agent thinking indicators
- Error messages

This demonstrates the new API improvement where you can pass a ConversationVisualizer
instance directly to the visualize parameter instead of using callbacks.
"""

import logging
import os

from pydantic import SecretStr

from openhands.sdk import LLM, Conversation
from openhands.sdk.conversation.visualizer import ConversationVisualizer
from openhands.sdk.event import (
    ActionEvent,
    AgentErrorEvent,
    MessageEvent,
    ObservationEvent,
)
from openhands.tools.preset.default import get_default_agent


class MinimalProgressVisualizer(ConversationVisualizer):
    """A minimal progress visualizer that shows step counts and tool names.

    This visualizer produces concise output showing:
    - LLM call completions
    - Tool execution steps with command/path details
    - Agent thinking indicators
    - Error messages

    Example output:
        ü§ñ LLM call completed
        Step 1: Executing str_replace_editor (view: .../FACTS.txt)... ‚úì
        üí≠ Agent thinking...
        ü§ñ LLM call completed
        Step 2: Executing str_replace_editor (str_replace: .../FACTS.txt)... ‚úì
        ‚ùå Error: File not found
    """

    def __init__(self, **kwargs):
        """Initialize the minimal progress visualizer.

        Args:
            **kwargs: Additional arguments passed to ConversationVisualizer.
                     Note: We override visualization, so most ConversationVisualizer
                     parameters are ignored, but we keep the signature for
                     compatibility.
        """
        # Initialize parent but we'll override on_event
        # We don't need the console/panels from the parent
        super().__init__(**kwargs)

        # Track state for our custom visualization
        self.step_count = 0
        self.current_action = None
        self.logger = logging.getLogger(__name__)

    def on_event(self, event):
        """Handle conversation events with minimal progress display."""
        try:
            if isinstance(event, MessageEvent):
                if event.source == "agent":
                    print("ü§ñ LLM call completed")
                elif event.source == "user":
                    print(f"üë§ User: {event.content}")

            elif isinstance(event, ActionEvent):
                self.step_count += 1
                action_name = event.action.__class__.__name__

                # Extract useful details from common actions
                details = ""
                if hasattr(event.action, "command"):
                    details = f"command: {event.action.command[:50]}..."
                elif hasattr(event.action, "path"):
                    path = event.action.path
                    if hasattr(event.action, "command"):
                        details = f"{event.action.command}: {path}"
                    else:
                        details = f"path: {path}"

                if details:
                    print(f"Step {self.step_count}: Executing {action_name} ({details})...", end=" ", flush=True)
                else:
                    print(f"Step {self.step_count}: Executing {action_name}...", end=" ", flush=True)

                self.current_action = action_name

            elif isinstance(event, ObservationEvent):
                if self.current_action:
                    # Simple success/error indication
                    if hasattr(event.observation, "error") and event.observation.error:
                        print("‚ùå")
                        print(f"‚ùå Error: {event.observation.error}")
                    else:
                        print("‚úì")
                    self.current_action = None
                else:
                    print("üí≠ Agent thinking...")

            elif isinstance(event, AgentErrorEvent):
                print(f"‚ùå Agent Error: {event.message}")

        except Exception as e:
            # Fallback to prevent visualization errors from breaking the conversation
            self.logger.warning(f"Visualization error: {e}")


def main():
    """Demonstrate the custom visualizer with a simple task."""
    # Get API key from environment
    api_key = os.environ.get("LLM_API_KEY")
    if not api_key:
        raise ValueError("LLM_API_KEY environment variable is not set")

    # Create LLM and Agent with default tools
    llm = LLM(model="gpt-4o-mini", api_key=SecretStr(api_key))
    agent = get_default_agent(llm=llm)

    # Create our custom visualizer
    custom_visualizer = MinimalProgressVisualizer()

    print("üöÄ Starting conversation with custom visualizer...")
    print("=" * 60)

    # NEW API: Pass the visualizer instance directly!
    # This is much cleaner than: visualize=False, callbacks=[custom_visualizer.on_event]
    conversation = Conversation(
        agent=agent,
        workspace="./workspace",
        visualize=custom_visualizer,  # Direct and intuitive!
    )

    # Send a message and run
    conversation.send_message(
        "Create a file called FACTS.txt with 3 interesting facts about Python programming."
    )
    conversation.run()

    print("=" * 60)
    print("‚úÖ Example completed!")
    print(f"üìä Total steps executed: {custom_visualizer.step_count}")
    print("\nThe conversation used our custom MinimalProgressVisualizer!")
    print("Compare this to the default visualizer to see the difference.")


if __name__ == "__main__":
    main()
```

```bash Running the Example
export LLM_API_KEY="your-api-key"
cd agent-sdk
uv run python examples/01_standalone_sdk/26_custom_visualizer.py
```

## Understanding Custom Visualizers

Custom visualizers give you complete control over how conversation events are displayed. There are two main approaches, each suited for different needs.

### Approach 1: Configure the Built-in Visualizer

The built-in `ConversationVisualizer` uses Rich panels and provides extensive customization through configuration:

```python
from openhands.sdk.conversation.visualizer import ConversationVisualizer

# Configure highlighting patterns using regex
custom_visualizer = ConversationVisualizer(
    highlight_regex={
        r"^Reasoning:": "bold cyan",      # Lines starting with "Reasoning:"
        r"^Thought:": "bold green",       # Lines starting with "Thought:"
        r"^Action:": "bold yellow",       # Lines starting with "Action:"
        r"\[ERROR\]": "bold red",         # Error markers anywhere
        r"\*\*(.*?)\*\*": "bold",         # Markdown bold **text**
    },
    skip_user_messages=False,             # Show user messages
    name_for_visualization="MyAgent",     # Prefix panel titles
)
```

**When to use**: Perfect for customizing colors and highlighting without changing the overall panel-based layout.

### Approach 2: Subclass for Complete Control

For entirely different visualization approaches, subclass `ConversationVisualizer` and override the `on_event` method:

```python
from openhands.sdk.conversation.visualizer import ConversationVisualizer
from openhands.sdk.event import ActionEvent, MessageEvent, ObservationEvent, AgentErrorEvent

class MinimalProgressVisualizer(ConversationVisualizer):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.step_count = 0
        self.pending_action = False
    
    def on_event(self, event):
        if isinstance(event, ActionEvent):
            self.step_count += 1
            tool_name = event.tool_name or "unknown"
            print(f"Step {self.step_count}: Executing {tool_name}...", end="", flush=True)
            self.pending_action = True
            
        elif isinstance(event, ObservationEvent):
            if self.pending_action:
                print(" ‚úì")
                self.pending_action = False
                
        elif isinstance(event, AgentErrorEvent):
            print(f"‚ùå Error: {event.error}")
```

**When to use**: When you need completely different output format, custom state tracking, or integration with external systems.

## Key Event Types

Understanding the event system is crucial for effective custom visualizers:

### ActionEvent
Fired when the agent decides to use a tool or take an action.

```python
def handle_action(self, event: ActionEvent):
    # Access tool information
    tool_name = event.tool_name  # e.g., "str_replace_editor"
    action = event.action        # The actual action object
    
    # Track LLM calls
    if event.llm_response_id:
        print(f"ü§ñ LLM call {event.llm_response_id}")
    
    # Extract action details
    if hasattr(action, 'command'):
        print(f"Command: {action.command}")
    if hasattr(action, 'path'):
        print(f"File: {action.path}")
```

### ObservationEvent
Fired when a tool execution completes and returns results.

```python
def handle_observation(self, event: ObservationEvent):
    # Check for errors
    if hasattr(event.observation, 'error') and event.observation.error:
        print(f"‚ùå Tool failed: {event.observation.error}")
    else:
        print("‚úÖ Tool completed successfully")
    
    # Access results
    if hasattr(event.observation, 'content'):
        content = event.observation.content
        print(f"Result: {content[:100]}...")  # Show first 100 chars
```

### MessageEvent
Fired for LLM messages (both user input and agent responses).

```python
def handle_message(self, event: MessageEvent):
    if event.source == "user":
        print(f"üë§ User: {event.content}")
    elif event.source == "agent":
        print(f"ü§ñ Agent: {event.content}")
    
    # Track LLM response IDs to avoid duplicates
    if event.llm_response_id:
        self.seen_responses.add(event.llm_response_id)
```

### AgentErrorEvent
Fired when the agent encounters an error.

```python
def handle_error(self, event: AgentErrorEvent):
    print(f"üö® Agent Error: {event.error}")
    # Optionally log to external systems
    self.logger.error(f"Agent failed: {event.error}")
```

## Best Practices

### 1. State Management
Track conversation state to provide meaningful progress indicators:

```python
class StatefulVisualizer(ConversationVisualizer):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.step_count = 0
        self.pending_action = False
        self.seen_llm_responses = set()
        self.start_time = time.time()
    
    def on_event(self, event):
        # Use state to provide context
        elapsed = time.time() - self.start_time
        print(f"[{elapsed:.1f}s] ", end="")
        # ... handle event
```

### 2. Error Handling
Always include error handling to prevent visualization issues from breaking conversations:

```python
def on_event(self, event):
    try:
        # Your visualization logic
        self._handle_event(event)
    except Exception as e:
        # Fallback to prevent breaking the conversation
        print(f"Visualization error: {e}")
        # Optionally log for debugging
        logging.warning(f"Visualizer failed: {e}")
```

### 3. Performance Considerations
For high-frequency events, optimize your visualization:

```python
def on_event(self, event):
    # Skip verbose events if needed
    if isinstance(event, SomeVerboseEvent) and not self.verbose_mode:
        return
    
    # Batch updates for better performance
    if self.should_batch_updates():
        self.pending_updates.append(event)
        return
    
    self._render_event(event)
```

### 4. Flexible Output
Design visualizers that work in different environments:

```python
class AdaptiveVisualizer(ConversationVisualizer):
    def __init__(self, output_format="console", **kwargs):
        super().__init__(**kwargs)
        self.output_format = output_format
        
        if output_format == "json":
            self.output_handler = self._json_output
        elif output_format == "markdown":
            self.output_handler = self._markdown_output
        else:
            self.output_handler = self._console_output
    
    def on_event(self, event):
        self.output_handler(event)
```

### 5. Integration with External Systems
Custom visualizers can integrate with logging, monitoring, or notification systems:

```python
class IntegratedVisualizer(ConversationVisualizer):
    def __init__(self, webhook_url=None, **kwargs):
        super().__init__(**kwargs)
        self.webhook_url = webhook_url
        self.metrics = {"actions": 0, "errors": 0}
    
    def on_event(self, event):
        # Update metrics
        if isinstance(event, ActionEvent):
            self.metrics["actions"] += 1
        elif isinstance(event, AgentErrorEvent):
            self.metrics["errors"] += 1
            
        # Send to external system
        if self.webhook_url and isinstance(event, AgentErrorEvent):
            self._send_alert(event)
    
    def _send_alert(self, event):
        # Send webhook notification for errors
        payload = {"error": event.error, "timestamp": time.time()}
        requests.post(self.webhook_url, json=payload)
```

## Using Your Custom Visualizer

### Direct Assignment (Recommended)

Pass your visualizer instance directly to the `visualize` parameter:

```python
# Create your custom visualizer
custom_visualizer = MinimalProgressVisualizer()

# Use it directly - clean and intuitive
conversation = Conversation(
    agent=agent,
    workspace="./workspace",
    visualize=custom_visualizer,  # Direct assignment
)
```

### Visualization Options

The `visualize` parameter accepts three types:

- **`True`** (default): Use the default Rich panel visualizer
- **`False` or `None`**: Disable visualization entirely  
- **`ConversationVisualizer` instance**: Use your custom visualizer

### Combining with Additional Callbacks

Custom visualizers work alongside other event callbacks:

```python
def metrics_callback(event):
    # Track metrics separately from visualization
    if isinstance(event, ActionEvent):
        metrics.increment("actions_taken")

conversation = Conversation(
    agent=agent,
    workspace="./workspace", 
    visualize=custom_visualizer,      # Handle visualization
    callbacks=[metrics_callback],     # Handle other concerns
)
```

## Built-in Visualizer Reference

### Default Highlighting Patterns

The built-in visualizer includes these default patterns:

```python
DEFAULT_HIGHLIGHT_REGEX = {
    r"^Reasoning:": "bold bright_black",
    r"^Thought:": "bold bright_black", 
    r"^Action:": "bold blue",
    r"^Arguments:": "bold blue",
    r"^Tool:": "bold yellow",
    r"^Result:": "bold yellow",
    r"^Rejection Reason:": "bold red",
    r"\*\*(.*?)\*\*": "bold",          # Markdown bold
    r"\*(.*?)\*": "italic",            # Markdown italic
}
```

### Available Colors and Styles

**Colors**: `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, `white`, `bright_black`, `bright_red`, etc.

**Styles**: `bold`, `dim`, `italic`, `underline`

**Combinations**: `"bold cyan"`, `"underline red"`, `"bold italic green"`

### Configuration Options

```python
ConversationVisualizer(
    highlight_regex=custom_patterns,      # Your highlighting rules
    skip_user_messages=False,             # Show user input (default: False)
    name_for_visualization="MyAgent",     # Prefix for panel titles
    conversation_stats=stats_tracker,     # Show token/cost metrics
)
```

## Next Steps

- **[Callbacks](/sdk/guides/convo-async)** - Learn about custom event callbacks
- **[Persistence](/sdk/guides/convo-persistence)** - Save and restore conversation state
- **[Pause and Resume](/sdk/guides/convo-pause-and-resume)** - Control agent execution flow
