---
title: Custom Visualizer
description: Customize conversation visualization by creating custom visualizers or configuring the default visualizer.
---

<Note>
This example is available on GitHub: [examples/01_standalone_sdk/26_custom_visualizer.py](https://github.com/OpenHands/software-agent-sdk/blob/main/examples/01_standalone_sdk/26_custom_visualizer.py)
</Note>

The SDK provides flexible visualization options. You can use the default rich-formatted visualizer, customize it with highlighting patterns, or build completely custom visualizers by subclassing `ConversationVisualizerBase`.

## Basic Example

```python icon="python" expandable examples/01_standalone_sdk/26_custom_visualizer.py
"""Custom Visualizer Example

This example demonstrates how to create and use a custom visualizer by subclassing
ConversationVisualizer. This approach provides:
- Clean, testable code with class-based state management
- Direct configuration (just pass the visualizer instance to visualizer parameter)
- Reusable visualizer that can be shared across conversations
- Better separation of concerns compared to callback functions
- Event handler registration to avoid long if/elif chains

This demonstrates how you can pass a ConversationVisualizer instance directly
to the visualizer parameter for clean, reusable visualization logic.
"""

import logging
import os

from pydantic import SecretStr

from openhands.sdk import LLM, Conversation
from openhands.sdk.conversation.visualizer import ConversationVisualizerBase
from openhands.sdk.event import (
    Event,
)
from openhands.tools.preset.default import get_default_agent


class MinimalVisualizer(ConversationVisualizerBase):
    """A minimal visualizer that print the raw events as they occur."""

    def __init__(self, name: str | None = None):
        """Initialize the minimal progress visualizer.

        Args:
            name: Optional name to identify the agent/conversation.
                                  Note: This simple visualizer doesn't use it in output,
                                  but accepts it for compatibility with the base class.
        """
        # Initialize parent - state will be set later via initialize()
        super().__init__(name=name)

    def on_event(self, event: Event) -> None:
        """Handle events for minimal progress visualization."""
        print(f"\n\n[EVENT] {type(event).__name__}: {event.model_dump_json()[:200]}...")


api_key = os.getenv("LLM_API_KEY")
assert api_key is not None, "LLM_API_KEY environment variable is not set."
model = os.getenv("LLM_MODEL", "openhands/claude-sonnet-4-5-20250929")
base_url = os.getenv("LLM_BASE_URL")
llm = LLM(
    model=model,
    api_key=SecretStr(api_key),
    base_url=base_url,
    usage_id="agent",
)
agent = get_default_agent(llm=llm, cli_mode=True)

# ============================================================================
# Configure Visualization
# ============================================================================
# Set logging level to reduce verbosity
logging.getLogger().setLevel(logging.WARNING)

# Start a conversation with custom visualizer
cwd = os.getcwd()
conversation = Conversation(
    agent=agent,
    workspace=cwd,
    visualizer=MinimalVisualizer(),
)

# Send a message and let the agent run
print("Sending task to agent...")
conversation.send_message("Write 3 facts about the current project into FACTS.txt.")
conversation.run()
print("Task completed!")

# Report cost
cost = llm.metrics.accumulated_cost
print(f"EXAMPLE_COST: ${cost:.4f}")
```

```bash Running the Example
export LLM_API_KEY="your-api-key"
cd agent-sdk
uv run python examples/01_standalone_sdk/26_custom_visualizer.py
```

## Visualizer Configuration Options

The `visualizer` parameter in `Conversation` controls how events are displayed:

```python
from openhands.sdk import Conversation
from openhands.sdk.conversation import DefaultConversationVisualizer, ConversationVisualizerBase

# Option 1: Use default visualizer (enabled by default)
conversation = Conversation(agent=agent, workspace=workspace)

# Option 2: Disable visualization
conversation = Conversation(agent=agent, workspace=workspace, visualizer=None)

# Option 3: Pass a visualizer class (will be instantiated automatically)
conversation = Conversation(agent=agent, workspace=workspace, visualizer=DefaultConversationVisualizer)

# Option 4: Pass a configured visualizer instance
custom_viz = DefaultConversationVisualizer(
    name="MyAgent",
    highlight_regex={r"^Reasoning:": "bold cyan"}
)
conversation = Conversation(agent=agent, workspace=workspace, visualizer=custom_viz)

# Option 5: Use custom visualizer class
class MyVisualizer(ConversationVisualizerBase):
    def on_event(self, event):
        print(f"Event: {event}")

conversation = Conversation(agent=agent, workspace=workspace, visualizer=MyVisualizer())
```

## Customizing the Default Visualizer

`DefaultConversationVisualizer` uses Rich panels and supports customization through configuration:

```python
from openhands.sdk.conversation import DefaultConversationVisualizer

# Configure highlighting patterns using regex
custom_visualizer = DefaultConversationVisualizer(
    name="MyAgent",                       # Prefix panel titles with agent name
    highlight_regex={
        r"^Reasoning:": "bold cyan",      # Lines starting with "Reasoning:"
        r"^Thought:": "bold green",       # Lines starting with "Thought:"
        r"^Action:": "bold yellow",       # Lines starting with "Action:"
        r"\[ERROR\]": "bold red",         # Error markers anywhere
        r"\*\*(.*?)\*\*": "bold",         # Markdown bold **text**
    },
    skip_user_messages=False,             # Show user messages
)

conversation = Conversation(
    agent=agent,
    workspace=workspace,
    visualizer=custom_visualizer
)
```

**When to use**: Perfect for customizing colors and highlighting without changing the panel-based layout.

## Creating Custom Visualizers

For complete control over visualization, subclass `ConversationVisualizerBase`:

```python
from openhands.sdk.conversation import ConversationVisualizerBase
from openhands.sdk.event import ActionEvent, ObservationEvent, AgentErrorEvent, Event

class MinimalVisualizer(ConversationVisualizerBase):
    """A minimal visualizer that prints raw event information."""
    
    def __init__(self, name: str | None = None):
        super().__init__(name=name)
        self.step_count = 0
    
    def on_event(self, event: Event) -> None:
        """Handle each event."""
        if isinstance(event, ActionEvent):
            self.step_count += 1
            tool_name = event.tool_name or "unknown"
            print(f"Step {self.step_count}: {tool_name}")
            
        elif isinstance(event, ObservationEvent):
            print(f"  ‚Üí Result received")
                
        elif isinstance(event, AgentErrorEvent):
            print(f"‚ùå Error: {event.error}")

# Use your custom visualizer
conversation = Conversation(
    agent=agent,
    workspace=workspace,
    visualizer=MinimalVisualizer(name="Agent")
)
```

### Key Methods

**`__init__(self, name: str | None = None)`**
- Initialize your visualizer with optional configuration
- `name` parameter is available from the base class for agent identification
- Call `super().__init__(name=name)` to initialize the base class

**`initialize(self, state: ConversationStateProtocol)`**
- Called automatically by `Conversation` after state is created
- Provides access to conversation state and statistics via `self._state`
- Override if you need custom initialization, but call `super().initialize(state)`

**`on_event(self, event: Event)`** *(required)*
- Called for each conversation event
- Implement your visualization logic here
- Access conversation stats via `self.conversation_stats` property

**When to use**: When you need completely different output format, custom state tracking, or integration with external systems.

## Key Event Types

Understanding the event system is crucial for effective custom visualizers. Here's a comprehensive overview of all event types handled by the default visualizer:

| Event Type | Description | Key Properties | When It Occurs |
|------------|-------------|----------------|----------------|
| `SystemPromptEvent` | System-level prompts and instructions | `content`, `source` | Agent initialization, system messages |
| `ActionEvent` | Agent actions and tool calls | `action`, `tool_name`, `llm_response_id` | When agent decides to take an action |
| `ObservationEvent` | Results from executed actions | `observation`, `source` | After action execution completes |
| `MessageEvent` | LLM messages (user/assistant) | `llm_message` (role, content) | User input, agent responses |
| `AgentErrorEvent` | Error conditions and failures | `error`, `source` | When agent encounters errors |
| `PauseEvent` | User-initiated pauses | `source` | When user pauses conversation |
| `Condensation` | Memory condensation events | `content`, `source` | During conversation memory management |

### Detailed Event Descriptions

### ActionEvent
Fired when the agent decides to use a tool or take an action.

**Key Properties:**
- `thought`: Agent's reasoning before taking action (list of TextContent)
- `action`: The actual tool action (None if non-executable)
- `tool_name`: Name of the tool being called
- `tool_call_id`: Unique identifier for the tool call
- `security_risk`: LLM's assessment of action safety
- `reasoning_content`: Intermediate reasoning from reasoning models

**Default Rendering:** Blue panel titled "Agent Action" showing reasoning, thought process, and action details.

```python
def handle_action(self, event: ActionEvent):
    # Access thought process
    thought_text = " ".join([t.text for t in event.thought])
    print(f"üí≠ Thought: {thought_text}")
    
    # Check if action is executable
    if event.action:
        print(f"üîß Tool: {event.tool_name}")
        print(f"‚ö° Action: {event.action}")
    else:
        print(f"‚ö†Ô∏è Non-executable call: {event.tool_call.name}")
```

### ObservationEvent
Contains the result of an executed action.

**Key Properties:**
- `observation`: The tool execution result (varies by tool)
- `tool_name`: Name of the tool that was executed
- `tool_call_id`: ID linking back to the original action
- `action_id`: ID of the action this observation responds to

**Default Rendering:** Yellow panel titled "Observation" showing tool name and execution results.

```python
def handle_observation(self, event: ObservationEvent):
    print(f"üîß Tool: {event.tool_name}")
    print(f"üîó Action ID: {event.action_id}")
    
    # Access the observation result
    obs = event.observation
    if hasattr(obs, 'error') and obs.error:
        print(f"‚ùå Error: {obs.error}")
    elif hasattr(obs, 'content'):
        print(f"üìÑ Content: {obs.content[:100]}...")
```

### MessageEvent
Represents messages between user and agent.

**Key Properties:**
- `llm_message`: The complete LLM message (role, content, tool_calls)
- `source`: Whether from "user" or "agent"
- `activated_skills`: List of skills activated for this message
- `extended_content`: Additional content added by agent context

**Default Rendering:** Gold panel for user messages, blue panel for agent messages, with role-specific titles.

```python
def handle_message(self, event: MessageEvent):
    if event.llm_message:
        role = event.llm_message.role
        content = event.llm_message.content
        
        if role == "user":
            print(f"üë§ User: {content[0].text if content else ''}")
        elif role == "assistant":
            print(f"ü§ñ Agent: {content[0].text if content else ''}")
            
        # Check for tool calls
        if event.llm_message.tool_calls:
            print(f"üîß Tool calls: {len(event.llm_message.tool_calls)}")
```

### AgentErrorEvent
Error conditions encountered by the agent.

**Key Properties:**
- `error`: The error message from the agent/scaffold
- `tool_name`: Tool that caused the error (if applicable)
- `tool_call_id`: ID of the failed tool call (if applicable)

**Default Rendering:** Red panel titled "Agent Error" displaying error details.

```python
def handle_error(self, event: AgentErrorEvent):
    print(f"üö® Error: {event.error}")
    if event.tool_name:
        print(f"üîß Failed tool: {event.tool_name}")
    if event.tool_call_id:
        print(f"üîó Call ID: {event.tool_call_id}")
```

## Best Practices

### 1. Understanding ConversationVisualizerBase Subclassing

When subclassing `ConversationVisualizerBase`, you have access to:

**Built-in Features:**
- `self._name`: Optional agent name for identification (capitalized automatically)
- `self._state`: Conversation state (set after `initialize()` is called)
- `self.conversation_stats`: Property to access conversation statistics

**Key Methods:**
- `__init__(self, name: str | None = None)`: Initialize with optional name
- `initialize(self, state: ConversationStateProtocol)`: Called by Conversation to provide state
- `on_event(self, event: Event)`: Main event handler (must be implemented)

**Initialization Pattern:**
```python
from openhands.sdk.conversation import ConversationVisualizerBase
from openhands.sdk.event import Event

class MyVisualizer(ConversationVisualizerBase):
    def __init__(self, name: str | None = None, custom_param: str = "default"):
        # Always call super().__init__ with name parameter
        super().__init__(name=name)
        
        # Add your custom state
        self.custom_param = custom_param
        self.event_count = 0
    
    def initialize(self, state):
        # Optional: Override to add custom initialization
        super().initialize(state)  # Sets self._state
        print(f"Visualizer initialized for {self._name or 'unnamed agent'}")
        
    def on_event(self, event: Event) -> None:
        # Required: Implement your visualization logic
        self.event_count += 1
        
        if isinstance(event, ActionEvent):
            print(f"Custom action handling: {event.tool_name}")
            
        # Access conversation stats if needed
        if self.conversation_stats:
            print(f"Total cost so far: ${self.conversation_stats.accumulated_cost:.4f}")
```

### 2. State Management
Track conversation state to provide meaningful progress indicators. The example shows tracking step counts, pending actions, and LLM response IDs:

```python
def __init__(self, **kwargs):
    super().__init__(**kwargs)
    self._step_count = 0
    self._pending_action = False
    self._seen_llm_response_ids: set[str] = set()

def _handle_action_event(self, event: ActionEvent) -> None:
    # Track new LLM calls by monitoring llm_response_id
    if (
        event.llm_response_id
        and event.llm_response_id not in self._seen_llm_response_ids
    ):
        self._seen_llm_response_ids.add(event.llm_response_id)
        print("ü§ñ LLM call completed", flush=True)
    
    self._step_count += 1
    # ... handle event
```

### 3. Efficient Event Handling
For cleaner code, dispatch events to specific handler methods:

```python
from openhands.sdk.conversation import ConversationVisualizerBase
from openhands.sdk.event import Event, ActionEvent, ObservationEvent, MessageEvent

class OrganizedVisualizer(ConversationVisualizerBase):
    def on_event(self, event: Event) -> None:
        """Dispatch to specific handlers."""
        if isinstance(event, ActionEvent):
            self._handle_action(event)
        elif isinstance(event, ObservationEvent):
            self._handle_observation(event)
        elif isinstance(event, MessageEvent):
            self._handle_message(event)
    
    def _handle_action(self, event: ActionEvent) -> None:
        """Handle action events."""
        print(f"Action: {event.tool_name}")
    
    def _handle_observation(self, event: ObservationEvent) -> None:
        """Handle observation events."""
        print(f"Observation received")
    
    def _handle_message(self, event: MessageEvent) -> None:
        """Handle message events."""
        if event.llm_message:
            print(f"Message: {event.llm_message.role}")
```

This pattern provides:
- **Organized code**: Each event type has its own method
- **Type hints**: Better IDE support and type checking
- **Easy maintenance**: Add new event types without touching dispatch logic
- **Clear structure**: Easy to understand and test

### 4. Error Handling
Always include error handling to prevent visualization issues from breaking conversations:

```python
import logging

def on_event(self, event):
    try:
        # Your visualization logic
        if isinstance(event, ActionEvent):
            self._handle_action_event(event)
        elif isinstance(event, ObservationEvent):
            self._handle_observation_event(event)
        # ... other event types
    except Exception as e:
        # Fallback to prevent breaking the conversation
        print(f"‚ö†Ô∏è Visualization error: {e}", flush=True)
        # Optionally log for debugging
        logging.warning(f"Visualizer failed for {event.__class__.__name__}: {e}")
```

This pattern ensures that visualization problems never interrupt the agent's work.

### 5. Performance Considerations
For high-frequency events, consider optimizing your visualization by filtering events or using efficient output methods like `flush=True` for immediate display.

## Using Your Custom Visualizer

Pass your visualizer to the `visualizer` parameter:

```python
from openhands.sdk import Conversation

# Create your custom visualizer
custom_visualizer = MinimalVisualizer(name="Agent")

# Use it in conversation
conversation = Conversation(
    agent=agent,
    workspace="./workspace",
    visualizer=custom_visualizer,
)
```

### Visualization Options

The `visualizer` parameter accepts:

- **Visualizer class** (uninstantiated): `DefaultConversationVisualizer` (default)
- **Visualizer instance**: `MinimalVisualizer(name="Agent")`
- **`None`**: Disable visualization entirely

```python
# Default visualization (enabled by default)
conversation = Conversation(agent=agent, workspace=workspace)

# Disable visualization
conversation = Conversation(agent=agent, workspace=workspace, visualizer=None)

# Use custom visualizer instance
conversation = Conversation(agent=agent, workspace=workspace, visualizer=MinimalVisualizer())

# Pass visualizer class (will be instantiated automatically)
conversation = Conversation(agent=agent, workspace=workspace, visualizer=MinimalVisualizer)
```

### Combining with Additional Callbacks

Custom visualizers work alongside other event callbacks:

```python
from openhands.sdk.event import ActionEvent

def metrics_callback(event):
    # Track metrics separately from visualization
    if isinstance(event, ActionEvent):
        metrics.increment("actions_taken")

conversation = Conversation(
    agent=agent,
    workspace="./workspace", 
    visualizer=custom_visualizer,      # Handle visualization
    callbacks=[metrics_callback],      # Handle other concerns
)
```

## Built-in Visualizer Reference

The default visualizer (`DefaultConversationVisualizer`) provides rich-formatted output with panels. View the complete implementation: [DefaultConversationVisualizer source code](https://github.com/OpenHands/software-agent-sdk/blob/main/openhands-sdk/openhands/sdk/conversation/visualizer/default.py)

### Default Highlighting Patterns

The built-in visualizer includes these default patterns:

```python
DEFAULT_HIGHLIGHT_REGEX = {
    r"^Reasoning:": "bold bright_black",
    r"^Thought:": "bold bright_black", 
    r"^Action:": "bold blue",
    r"^Arguments:": "bold blue",
    r"^Tool:": "bold yellow",
    r"^Result:": "bold yellow",
    r"^Rejection Reason:": "bold red",
    r"\*\*(.*?)\*\*": "bold",          # Markdown bold
    r"\*(.*?)\*": "italic",            # Markdown italic
}
```

### Available Colors and Styles

**Colors**: `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, `white`, `bright_black`, `bright_red`, etc.

**Styles**: `bold`, `dim`, `italic`, `underline`

**Combinations**: `"bold cyan"`, `"underline red"`, `"bold italic green"`

### Configuration Options

```python
from openhands.sdk.conversation import DefaultConversationVisualizer

DefaultConversationVisualizer(
    name="MyAgent",                    # Prefix for panel titles
    highlight_regex=custom_patterns,   # Your highlighting rules
    skip_user_messages=False,          # Show user input (default: False)
)
```

## Next Steps

Now that you understand custom visualizers, explore these related topics:

- **[Async Conversations](/sdk/guides/convo-async)** - Learn about custom event callbacks and async processing
- **[Conversation Metrics](/sdk/guides/metrics)** - Track LLM usage, costs, and performance data
- **[Send Messages While Running](/sdk/guides/convo-send-message-while-running)** - Interactive conversations with real-time updates
- **[Pause and Resume](/sdk/guides/convo-pause-and-resume)** - Control agent execution flow with custom logic
