---
title: Docker Sandboxed Server
description: Run agents in isolated Docker containers for security and reproducibility.
---

The Docker Sandboxed Server demonstrates how to run agents in isolated Docker containers using DockerWorkspace. This provides complete isolation from the host system, making it ideal for production deployments, testing, and executing untrusted code safely.

## Basic Example

<Note>
This example is available on GitHub: [examples/02_remote_agent_server/02_convo_with_docker_sandboxed_server.py](https://github.com/OpenHands/agent-sdk/blob/main/examples/02_remote_agent_server/02_convo_with_docker_sandboxed_server.py)
</Note>

This example shows how to create a DockerWorkspace that automatically manages Docker containers for agent execution:

```python icon="python" expandable examples/02_remote_agent_server/02_convo_with_docker_sandboxed_server.py
import os
import platform
import time

from pydantic import SecretStr

from openhands.sdk import (
    LLM,
    Conversation,
    RemoteConversation,
    get_logger,
)
from openhands.tools.preset.default import get_default_agent
from openhands.workspace import DockerWorkspace


logger = get_logger(__name__)


# 1) Ensure we have LLM API key
api_key = os.getenv("LLM_API_KEY")
assert api_key is not None, "LLM_API_KEY environment variable is not set."

llm = LLM(
    usage_id="agent",
    model="litellm_proxy/anthropic/claude-sonnet-4-5-20250929",
    base_url="https://llm-proxy.eval.all-hands.dev",
    api_key=SecretStr(api_key),
)


def detect_platform():
    """Detects the correct Docker platform string."""
    machine = platform.machine().lower()
    if "arm" in machine or "aarch64" in machine:
        return "linux/arm64"
    return "linux/amd64"


# 2) Create a Docker-based remote workspace that will set up and manage
#    the Docker container automatically
with DockerWorkspace(
    # dynamically build agent-server image
    # base_image="nikolaik/python-nodejs:python3.12-nodejs22",
    # use pre-built image for faster startup
    server_image="ghcr.io/openhands/agent-server:latest-python",
    host_port=8010,
    platform=detect_platform(),
    forward_env=["LLM_API_KEY"],  # Forward API key to container
) as workspace:
    # 3) Create agent
    agent = get_default_agent(
        llm=llm,
        cli_mode=True,
    )

    # 4) Set up callback collection
    received_events: list = []
    last_event_time = {"ts": time.time()}

    def event_callback(event) -> None:
        event_type = type(event).__name__
        logger.info(f"ğŸ”” Callback received event: {event_type}\n{event}")
        received_events.append(event)
        last_event_time["ts"] = time.time()

    # 5) Test the workspace with a simple command
    result = workspace.execute_command(
        "echo 'Hello from sandboxed environment!' && pwd"
    )
    logger.info(
        f"Command '{result.command}' completed with exit code {result.exit_code}"
    )
    logger.info(f"Output: {result.stdout}")
    conversation = Conversation(
        agent=agent,
        workspace=workspace,
        callbacks=[event_callback],
        visualize=True,
    )
    assert isinstance(conversation, RemoteConversation)

    try:
        logger.info(f"\nğŸ“‹ Conversation ID: {conversation.state.id}")

        logger.info("ğŸ“ Sending first message...")
        conversation.send_message(
            "Read the current repo and write 3 facts about the project into FACTS.txt."
        )
        logger.info("ğŸš€ Running conversation...")
        conversation.run()
        logger.info("âœ… First task completed!")
        logger.info(f"Agent status: {conversation.state.agent_status}")

        # Wait for events to settle (no events for 2 seconds)
        logger.info("â³ Waiting for events to stop...")
        while time.time() - last_event_time["ts"] < 2.0:
            time.sleep(0.1)
        logger.info("âœ… Events have stopped")

        logger.info("ğŸš€ Running conversation again...")
        conversation.send_message("Great! Now delete that file.")
        conversation.run()
        logger.info("âœ… Second task completed!")
    finally:
        print("\nğŸ§¹ Cleaning up conversation...")
        conversation.close()
```

```bash Running the Example
export LLM_API_KEY="your-api-key"
cd agent-sdk
uv run python examples/02_remote_agent_server/02_convo_with_docker_sandboxed_server.py
```

## Key Concepts

### DockerWorkspace Context Manager

The `DockerWorkspace` uses a context manager to automatically handle container lifecycle:

```python highlight={42-50}
with DockerWorkspace(
    # use pre-built image for faster startup
    server_image="ghcr.io/openhands/agent-server:latest-python",
    host_port=8010,
    platform=detect_platform(),
    forward_env=["LLM_API_KEY"],  # Forward API key to container
) as workspace:
    # Container is running here
    # Work with the workspace
    pass
# Container is automatically stopped and cleaned up here
```

The workspace automatically:
- Pulls or builds the Docker image
- Starts the container with an agent server
- Waits for the server to be ready
- Cleans up the container when done

### Platform Detection

The example includes platform detection to ensure the correct Docker image is used:

```python highlight={32-37}
def detect_platform():
    """Detects the correct Docker platform string."""
    machine = platform.machine().lower()
    if "arm" in machine or "aarch64" in machine:
        return "linux/arm64"
    return "linux/amd64"
```

This ensures compatibility across different CPU architectures (Intel/AMD vs ARM/Apple Silicon).

### Environment Forwarding

You can forward environment variables from your host to the container:

```python highlight={49}
DockerWorkspace(
    server_image="ghcr.io/openhands/agent-server:latest-python",
    host_port=8010,
    platform=detect_platform(),
    forward_env=["LLM_API_KEY"],  # Forward API key to container
)
```

This allows the agent running inside the container to access necessary credentials.

### Testing the Workspace

Before creating a conversation, the example tests the workspace connection:

```python highlight={68-74}
result = workspace.execute_command(
    "echo 'Hello from sandboxed environment!' && pwd"
)
logger.info(
    f"Command '{result.command}' completed with exit code {result.exit_code}"
)
logger.info(f"Output: {result.stdout}")
```

This verifies the workspace is properly initialized and can execute commands.

### Automatic RemoteConversation

When you use a DockerWorkspace, the Conversation automatically becomes a RemoteConversation:

```python highlight={75-81}
conversation = Conversation(
    agent=agent,
    workspace=workspace,
    callbacks=[event_callback],
    visualize=True,
)
assert isinstance(conversation, RemoteConversation)
```

The SDK detects the remote workspace and uses WebSocket communication for real-time event streaming.

## When to Use Docker Sandboxed Server

Use Docker containers when you need:

- **Security**: Complete isolation from host system
- **Production**: Deploy agents in controlled environments
- **Testing**: Clean, reproducible test environments
- **Multi-tenant**: Isolate different users or workloads
- **Resource Control**: Set CPU/memory limits per container

## Configuration Options

### Pre-built vs Base Images

```python
# âœ… Fast: Use pre-built image (recommended)
DockerWorkspace(
    server_image="ghcr.io/openhands/agent-server:latest-python",
    host_port=8010,
)

# â±ï¸ Slower: Build from base image (more control)
DockerWorkspace(
    base_image="nikolaik/python-nodejs:python3.12-nodejs22",
    host_port=8010,
)
```

Pre-built images start immediately, while base images need to build the agent server first.

### Resource Limits

When running Docker containers, you can set resource limits:

```bash
docker run --memory="2g" --cpus="1.5" \
  -e LLM_API_KEY="your-api-key" \
  ghcr.io/openhands/agent-server:latest-python
```

## Next Steps

- **[Browser with Docker](/sdk/guides/agent-server/browser-with-docker)** - Add browser capabilities
- **[VS Code with Docker](/sdk/guides/agent-server/vscode-with-docker)** - Enable VS Code tools
- **[API Sandboxed Server](/sdk/guides/agent-server/api-sandboxed-server)** - Use managed hosting
