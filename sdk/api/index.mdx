---
title: Python API Reference
description: Complete API reference for the OpenHands SDK
---

# Python API Reference

This page contains the complete API reference for the OpenHands SDK, auto-generated from the source code.

**Source:** [`openhands/sdk/`](https://github.com/OpenHands/software-agent-sdk/tree/main/openhands-sdk/openhands/sdk/)

---

# Table of Contents

* [openhands.sdk](#openhands.sdk)
* [openhands.sdk.tool.registry](#openhands.sdk.tool.registry)
  * [Resolver](#openhands.sdk.tool.registry.Resolver)
* [openhands.sdk.tool.tool](#openhands.sdk.tool.tool)
  * [ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations)
  * [ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor)
    * [\_\_call\_\_](#openhands.sdk.tool.tool.ToolExecutor.__call__)
    * [close](#openhands.sdk.tool.tool.ToolExecutor.close)
  * [ExecutableTool](#openhands.sdk.tool.tool.ExecutableTool)
    * [executor](#openhands.sdk.tool.tool.ExecutableTool.executor)
    * [\_\_call\_\_](#openhands.sdk.tool.tool.ExecutableTool.__call__)
  * [ToolBase](#openhands.sdk.tool.tool.ToolBase)
    * [create](#openhands.sdk.tool.tool.ToolBase.create)
    * [set\_executor](#openhands.sdk.tool.tool.ToolBase.set_executor)
    * [as\_executable](#openhands.sdk.tool.tool.ToolBase.as_executable)
    * [action\_from\_arguments](#openhands.sdk.tool.tool.ToolBase.action_from_arguments)
    * [\_\_call\_\_](#openhands.sdk.tool.tool.ToolBase.__call__)
    * [to\_mcp\_tool](#openhands.sdk.tool.tool.ToolBase.to_mcp_tool)
    * [to\_openai\_tool](#openhands.sdk.tool.tool.ToolBase.to_openai_tool)
    * [to\_responses\_tool](#openhands.sdk.tool.tool.ToolBase.to_responses_tool)
  * [ToolDefinition](#openhands.sdk.tool.tool.ToolDefinition)
    * [create](#openhands.sdk.tool.tool.ToolDefinition.create)
* [openhands.sdk.tool](#openhands.sdk.tool)
* [openhands.sdk.tool.spec](#openhands.sdk.tool.spec)
  * [Tool](#openhands.sdk.tool.spec.Tool)
    * [validate\_name](#openhands.sdk.tool.spec.Tool.validate_name)
    * [validate\_params](#openhands.sdk.tool.spec.Tool.validate_params)
* [openhands.sdk.tool.builtins](#openhands.sdk.tool.builtins)
* [openhands.sdk.tool.builtins.finish](#openhands.sdk.tool.builtins.finish)
  * [FinishAction](#openhands.sdk.tool.builtins.finish.FinishAction)
    * [visualize](#openhands.sdk.tool.builtins.finish.FinishAction.visualize)
  * [FinishObservation](#openhands.sdk.tool.builtins.finish.FinishObservation)
    * [visualize](#openhands.sdk.tool.builtins.finish.FinishObservation.visualize)
* [openhands.sdk.tool.builtins.think](#openhands.sdk.tool.builtins.think)
  * [ThinkAction](#openhands.sdk.tool.builtins.think.ThinkAction)
    * [visualize](#openhands.sdk.tool.builtins.think.ThinkAction.visualize)
  * [ThinkObservation](#openhands.sdk.tool.builtins.think.ThinkObservation)
    * [visualize](#openhands.sdk.tool.builtins.think.ThinkObservation.visualize)
  * [THINK\_DESCRIPTION](#openhands.sdk.tool.builtins.think.THINK_DESCRIPTION)
* [openhands.sdk.tool.schema](#openhands.sdk.tool.schema)
  * [py\_type](#openhands.sdk.tool.schema.py_type)
  * [Schema](#openhands.sdk.tool.schema.Schema)
    * [to\_mcp\_schema](#openhands.sdk.tool.schema.Schema.to_mcp_schema)
    * [from\_mcp\_schema](#openhands.sdk.tool.schema.Schema.from_mcp_schema)
  * [Action](#openhands.sdk.tool.schema.Action)
    * [visualize](#openhands.sdk.tool.schema.Action.visualize)
  * [Observation](#openhands.sdk.tool.schema.Observation)
    * [to\_llm\_content](#openhands.sdk.tool.schema.Observation.to_llm_content)
    * [visualize](#openhands.sdk.tool.schema.Observation.visualize)
* [openhands.sdk.conversation.response\_utils](#openhands.sdk.conversation.response_utils)
  * [get\_agent\_final\_response](#openhands.sdk.conversation.response_utils.get_agent_final_response)
* [openhands.sdk.conversation.impl.local\_conversation](#openhands.sdk.conversation.impl.local_conversation)
  * [LocalConversation](#openhands.sdk.conversation.impl.local_conversation.LocalConversation)
    * [\_\_init\_\_](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.__init__)
    * [id](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.id)
    * [state](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.state)
    * [stuck\_detector](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.stuck_detector)
    * [send\_message](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.send_message)
    * [run](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.run)
    * [set\_confirmation\_policy](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.set_confirmation_policy)
    * [reject\_pending\_actions](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.reject_pending_actions)
    * [pause](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.pause)
    * [update\_secrets](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.update_secrets)
    * [close](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.close)
    * [generate\_title](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.generate_title)
    * [\_\_del\_\_](#openhands.sdk.conversation.impl.local_conversation.LocalConversation.__del__)
* [openhands.sdk.conversation.impl.remote\_conversation](#openhands.sdk.conversation.impl.remote_conversation)
  * [WebSocketCallbackClient](#openhands.sdk.conversation.impl.remote_conversation.WebSocketCallbackClient)
  * [RemoteEventsList](#openhands.sdk.conversation.impl.remote_conversation.RemoteEventsList)
    * [add\_event](#openhands.sdk.conversation.impl.remote_conversation.RemoteEventsList.add_event)
    * [append](#openhands.sdk.conversation.impl.remote_conversation.RemoteEventsList.append)
    * [create\_default\_callback](#openhands.sdk.conversation.impl.remote_conversation.RemoteEventsList.create_default_callback)
  * [RemoteState](#openhands.sdk.conversation.impl.remote_conversation.RemoteState)
    * [update\_state\_from\_event](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.update_state_from_event)
    * [create\_state\_update\_callback](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.create_state_update_callback)
    * [events](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.events)
    * [id](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.id)
    * [agent\_status](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.agent_status)
    * [agent\_status](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.agent_status)
    * [confirmation\_policy](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.confirmation_policy)
    * [activated\_knowledge\_skills](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.activated_knowledge_skills)
    * [agent](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.agent)
    * [workspace](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.workspace)
    * [persistence\_dir](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.persistence_dir)
    * [model\_dump](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.model_dump)
    * [model\_dump\_json](#openhands.sdk.conversation.impl.remote_conversation.RemoteState.model_dump_json)
  * [RemoteConversation](#openhands.sdk.conversation.impl.remote_conversation.RemoteConversation)
    * [\_\_init\_\_](#openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.__init__)
    * [state](#openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.state)
    * [conversation\_stats](#openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.conversation_stats)
    * [stuck\_detector](#openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.stuck_detector)
    * [generate\_title](#openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.generate_title)
* [openhands.sdk.conversation.impl](#openhands.sdk.conversation.impl)
* [openhands.sdk.conversation.types](#openhands.sdk.conversation.types)
  * [ConversationID](#openhands.sdk.conversation.types.ConversationID)
* [openhands.sdk.conversation.secret\_registry](#openhands.sdk.conversation.secret_registry)
  * [SecretRegistry](#openhands.sdk.conversation.secret_registry.SecretRegistry)
    * [update\_secrets](#openhands.sdk.conversation.secret_registry.SecretRegistry.update_secrets)
    * [find\_secrets\_in\_text](#openhands.sdk.conversation.secret_registry.SecretRegistry.find_secrets_in_text)
    * [get\_secrets\_as\_env\_vars](#openhands.sdk.conversation.secret_registry.SecretRegistry.get_secrets_as_env_vars)
    * [mask\_secrets\_in\_output](#openhands.sdk.conversation.secret_registry.SecretRegistry.mask_secrets_in_output)
* [openhands.sdk.conversation.stuck\_detector](#openhands.sdk.conversation.stuck_detector)
  * [StuckDetector](#openhands.sdk.conversation.stuck_detector.StuckDetector)
    * [is\_stuck](#openhands.sdk.conversation.stuck_detector.StuckDetector.is_stuck)
* [openhands.sdk.conversation.base](#openhands.sdk.conversation.base)
  * [ConversationStateProtocol](#openhands.sdk.conversation.base.ConversationStateProtocol)
    * [id](#openhands.sdk.conversation.base.ConversationStateProtocol.id)
    * [events](#openhands.sdk.conversation.base.ConversationStateProtocol.events)
    * [agent\_status](#openhands.sdk.conversation.base.ConversationStateProtocol.agent_status)
    * [confirmation\_policy](#openhands.sdk.conversation.base.ConversationStateProtocol.confirmation_policy)
    * [activated\_knowledge\_skills](#openhands.sdk.conversation.base.ConversationStateProtocol.activated_knowledge_skills)
    * [workspace](#openhands.sdk.conversation.base.ConversationStateProtocol.workspace)
    * [persistence\_dir](#openhands.sdk.conversation.base.ConversationStateProtocol.persistence_dir)
    * [agent](#openhands.sdk.conversation.base.ConversationStateProtocol.agent)
  * [BaseConversation](#openhands.sdk.conversation.base.BaseConversation)
    * [is\_confirmation\_mode\_active](#openhands.sdk.conversation.base.BaseConversation.is_confirmation_mode_active)
    * [generate\_title](#openhands.sdk.conversation.base.BaseConversation.generate_title)
    * [get\_persistence\_dir](#openhands.sdk.conversation.base.BaseConversation.get_persistence_dir)
    * [compose\_callbacks](#openhands.sdk.conversation.base.BaseConversation.compose_callbacks)
* [openhands.sdk.conversation.conversation\_stats](#openhands.sdk.conversation.conversation_stats)
  * [ConversationStats](#openhands.sdk.conversation.conversation_stats.ConversationStats)
* [openhands.sdk.conversation.state](#openhands.sdk.conversation.state)
  * [AgentExecutionStatus](#openhands.sdk.conversation.state.AgentExecutionStatus)
    * [IDLE](#openhands.sdk.conversation.state.AgentExecutionStatus.IDLE)
    * [RUNNING](#openhands.sdk.conversation.state.AgentExecutionStatus.RUNNING)
    * [PAUSED](#openhands.sdk.conversation.state.AgentExecutionStatus.PAUSED)
    * [FINISHED](#openhands.sdk.conversation.state.AgentExecutionStatus.FINISHED)
    * [ERROR](#openhands.sdk.conversation.state.AgentExecutionStatus.ERROR)
    * [STUCK](#openhands.sdk.conversation.state.AgentExecutionStatus.STUCK)
  * [ConversationState](#openhands.sdk.conversation.state.ConversationState)
    * [set\_on\_state\_change](#openhands.sdk.conversation.state.ConversationState.set_on_state_change)
    * [create](#openhands.sdk.conversation.state.ConversationState.create)
    * [get\_unmatched\_actions](#openhands.sdk.conversation.state.ConversationState.get_unmatched_actions)
    * [acquire](#openhands.sdk.conversation.state.ConversationState.acquire)
    * [release](#openhands.sdk.conversation.state.ConversationState.release)
    * [\_\_enter\_\_](#openhands.sdk.conversation.state.ConversationState.__enter__)
    * [\_\_exit\_\_](#openhands.sdk.conversation.state.ConversationState.__exit__)
    * [locked](#openhands.sdk.conversation.state.ConversationState.locked)
    * [owned](#openhands.sdk.conversation.state.ConversationState.owned)
* [openhands.sdk.conversation](#openhands.sdk.conversation)
* [openhands.sdk.conversation.event\_store](#openhands.sdk.conversation.event_store)
  * [EventLog](#openhands.sdk.conversation.event_store.EventLog)
    * [get\_index](#openhands.sdk.conversation.event_store.EventLog.get_index)
    * [get\_id](#openhands.sdk.conversation.event_store.EventLog.get_id)
* [openhands.sdk.conversation.persistence\_const](#openhands.sdk.conversation.persistence_const)
* [openhands.sdk.conversation.fifo\_lock](#openhands.sdk.conversation.fifo_lock)
  * [FIFOLock](#openhands.sdk.conversation.fifo_lock.FIFOLock)
    * [acquire](#openhands.sdk.conversation.fifo_lock.FIFOLock.acquire)
    * [release](#openhands.sdk.conversation.fifo_lock.FIFOLock.release)
    * [\_\_enter\_\_](#openhands.sdk.conversation.fifo_lock.FIFOLock.__enter__)
    * [\_\_exit\_\_](#openhands.sdk.conversation.fifo_lock.FIFOLock.__exit__)
    * [locked](#openhands.sdk.conversation.fifo_lock.FIFOLock.locked)
    * [owned](#openhands.sdk.conversation.fifo_lock.FIFOLock.owned)
* [openhands.sdk.conversation.conversation](#openhands.sdk.conversation.conversation)
  * [Conversation](#openhands.sdk.conversation.conversation.Conversation)
* [openhands.sdk.conversation.secret\_source](#openhands.sdk.conversation.secret_source)
  * [SecretSource](#openhands.sdk.conversation.secret_source.SecretSource)
    * [get\_value](#openhands.sdk.conversation.secret_source.SecretSource.get_value)
  * [StaticSecret](#openhands.sdk.conversation.secret_source.StaticSecret)
  * [LookupSecret](#openhands.sdk.conversation.secret_source.LookupSecret)
* [openhands.sdk.conversation.exceptions](#openhands.sdk.conversation.exceptions)
  * [ConversationRunError](#openhands.sdk.conversation.exceptions.ConversationRunError)
* [openhands.sdk.conversation.title\_utils](#openhands.sdk.conversation.title_utils)
  * [extract\_first\_user\_message](#openhands.sdk.conversation.title_utils.extract_first_user_message)
  * [generate\_title\_with\_llm](#openhands.sdk.conversation.title_utils.generate_title_with_llm)
  * [generate\_fallback\_title](#openhands.sdk.conversation.title_utils.generate_fallback_title)
  * [generate\_conversation\_title](#openhands.sdk.conversation.title_utils.generate_conversation_title)
* [openhands.sdk.conversation.events\_list\_base](#openhands.sdk.conversation.events_list_base)
  * [EventsListBase](#openhands.sdk.conversation.events_list_base.EventsListBase)
    * [append](#openhands.sdk.conversation.events_list_base.EventsListBase.append)
* [openhands.sdk.conversation.visualizer](#openhands.sdk.conversation.visualizer)
  * [ConversationVisualizer](#openhands.sdk.conversation.visualizer.ConversationVisualizer)
    * [\_\_init\_\_](#openhands.sdk.conversation.visualizer.ConversationVisualizer.__init__)
    * [on\_event](#openhands.sdk.conversation.visualizer.ConversationVisualizer.on_event)
  * [create\_default\_visualizer](#openhands.sdk.conversation.visualizer.create_default_visualizer)
* [openhands.sdk.conversation.serialization\_diff](#openhands.sdk.conversation.serialization_diff)
* [openhands.sdk.workspace.base](#openhands.sdk.workspace.base)
  * [BaseWorkspace](#openhands.sdk.workspace.base.BaseWorkspace)
    * [\_\_enter\_\_](#openhands.sdk.workspace.base.BaseWorkspace.__enter__)
    * [\_\_exit\_\_](#openhands.sdk.workspace.base.BaseWorkspace.__exit__)
    * [execute\_command](#openhands.sdk.workspace.base.BaseWorkspace.execute_command)
    * [file\_upload](#openhands.sdk.workspace.base.BaseWorkspace.file_upload)
    * [file\_download](#openhands.sdk.workspace.base.BaseWorkspace.file_download)
    * [git\_changes](#openhands.sdk.workspace.base.BaseWorkspace.git_changes)
    * [git\_diff](#openhands.sdk.workspace.base.BaseWorkspace.git_diff)
* [openhands.sdk.workspace.models](#openhands.sdk.workspace.models)
  * [CommandResult](#openhands.sdk.workspace.models.CommandResult)
  * [FileOperationResult](#openhands.sdk.workspace.models.FileOperationResult)
* [openhands.sdk.workspace](#openhands.sdk.workspace)
* [openhands.sdk.workspace.local](#openhands.sdk.workspace.local)
  * [LocalWorkspace](#openhands.sdk.workspace.local.LocalWorkspace)
    * [execute\_command](#openhands.sdk.workspace.local.LocalWorkspace.execute_command)
    * [file\_upload](#openhands.sdk.workspace.local.LocalWorkspace.file_upload)
    * [file\_download](#openhands.sdk.workspace.local.LocalWorkspace.file_download)
    * [git\_changes](#openhands.sdk.workspace.local.LocalWorkspace.git_changes)
    * [git\_diff](#openhands.sdk.workspace.local.LocalWorkspace.git_diff)
* [openhands.sdk.workspace.workspace](#openhands.sdk.workspace.workspace)
  * [Workspace](#openhands.sdk.workspace.workspace.Workspace)
* [openhands.sdk.workspace.remote.remote\_workspace\_mixin](#openhands.sdk.workspace.remote.remote_workspace_mixin)
  * [RemoteWorkspaceMixin](#openhands.sdk.workspace.remote.remote_workspace_mixin.RemoteWorkspaceMixin)
* [openhands.sdk.workspace.remote.base](#openhands.sdk.workspace.remote.base)
  * [RemoteWorkspace](#openhands.sdk.workspace.remote.base.RemoteWorkspace)
    * [execute\_command](#openhands.sdk.workspace.remote.base.RemoteWorkspace.execute_command)
    * [file\_upload](#openhands.sdk.workspace.remote.base.RemoteWorkspace.file_upload)
    * [file\_download](#openhands.sdk.workspace.remote.base.RemoteWorkspace.file_download)
    * [git\_changes](#openhands.sdk.workspace.remote.base.RemoteWorkspace.git_changes)
    * [git\_diff](#openhands.sdk.workspace.remote.base.RemoteWorkspace.git_diff)
* [openhands.sdk.workspace.remote](#openhands.sdk.workspace.remote)
* [openhands.sdk.workspace.remote.async\_remote\_workspace](#openhands.sdk.workspace.remote.async_remote_workspace)
  * [AsyncRemoteWorkspace](#openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace)
    * [execute\_command](#openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.execute_command)
    * [file\_upload](#openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.file_upload)
    * [file\_download](#openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.file_download)
    * [git\_changes](#openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.git_changes)
    * [git\_diff](#openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.git_diff)
* [openhands.sdk.utils.visualize](#openhands.sdk.utils.visualize)
  * [display\_dict](#openhands.sdk.utils.visualize.display_dict)
* [openhands.sdk.utils.models](#openhands.sdk.utils.models)
  * [rebuild\_all](#openhands.sdk.utils.models.rebuild_all)
  * [kind\_of](#openhands.sdk.utils.models.kind_of)
  * [get\_known\_concrete\_subclasses](#openhands.sdk.utils.models.get_known_concrete_subclasses)
  * [OpenHandsModel](#openhands.sdk.utils.models.OpenHandsModel)
    * [\_\_init\_subclass\_\_](#openhands.sdk.utils.models.OpenHandsModel.__init_subclass__)
  * [DiscriminatedUnionMixin](#openhands.sdk.utils.models.DiscriminatedUnionMixin)
    * [kind](#openhands.sdk.utils.models.DiscriminatedUnionMixin.kind)
    * [\_\_get\_pydantic\_core\_schema\_\_](#openhands.sdk.utils.models.DiscriminatedUnionMixin.__get_pydantic_core_schema__)
    * [\_\_get\_pydantic\_json\_schema\_\_](#openhands.sdk.utils.models.DiscriminatedUnionMixin.__get_pydantic_json_schema__)
    * [get\_serializable\_type](#openhands.sdk.utils.models.DiscriminatedUnionMixin.get_serializable_type)
* [openhands.sdk.utils.truncate](#openhands.sdk.utils.truncate)
  * [maybe\_truncate](#openhands.sdk.utils.truncate.maybe_truncate)
* [openhands.sdk.utils](#openhands.sdk.utils)
* [openhands.sdk.utils.async\_executor](#openhands.sdk.utils.async_executor)
  * [AsyncExecutor](#openhands.sdk.utils.async_executor.AsyncExecutor)
    * [run\_async](#openhands.sdk.utils.async_executor.AsyncExecutor.run_async)
    * [close](#openhands.sdk.utils.async_executor.AsyncExecutor.close)
    * [\_\_del\_\_](#openhands.sdk.utils.async_executor.AsyncExecutor.__del__)
* [openhands.sdk.utils.cipher](#openhands.sdk.utils.cipher)
  * [Cipher](#openhands.sdk.utils.cipher.Cipher)
    * [decrypt](#openhands.sdk.utils.cipher.Cipher.decrypt)
* [openhands.sdk.utils.pydantic\_secrets](#openhands.sdk.utils.pydantic_secrets)
  * [serialize\_secret](#openhands.sdk.utils.pydantic_secrets.serialize_secret)
  * [validate\_secret](#openhands.sdk.utils.pydantic_secrets.validate_secret)
* [openhands.sdk.utils.command](#openhands.sdk.utils.command)
* [openhands.sdk.utils.async\_utils](#openhands.sdk.utils.async_utils)
  * [AsyncCallbackWrapper](#openhands.sdk.utils.async_utils.AsyncCallbackWrapper)
* [openhands.sdk.utils.json](#openhands.sdk.utils.json)
  * [OpenHandsJSONEncoder](#openhands.sdk.utils.json.OpenHandsJSONEncoder)
  * [dumps](#openhands.sdk.utils.json.dumps)
  * [loads](#openhands.sdk.utils.json.loads)
* [openhands.sdk.utils.pydantic\_diff](#openhands.sdk.utils.pydantic_diff)
* [openhands.sdk.logger](#openhands.sdk.logger)
* [openhands.sdk.logger.logger](#openhands.sdk.logger.logger)
  * [disable\_logger](#openhands.sdk.logger.logger.disable_logger)
  * [setup\_logging](#openhands.sdk.logger.logger.setup_logging)
  * [get\_logger](#openhands.sdk.logger.logger.get_logger)
* [openhands.sdk.logger.rolling](#openhands.sdk.logger.rolling)
  * [rolling\_log\_view](#openhands.sdk.logger.rolling.rolling_log_view)
* [openhands.sdk.llm.mixins.fn\_call\_converter](#openhands.sdk.llm.mixins.fn_call_converter)
  * [system\_message\_suffix\_TEMPLATE](#openhands.sdk.llm.mixins.fn_call_converter.system_message_suffix_TEMPLATE)
  * [get\_example\_for\_tools](#openhands.sdk.llm.mixins.fn_call_converter.get_example_for_tools)
  * [IN\_CONTEXT\_LEARNING\_EXAMPLE\_SUFFIX](#openhands.sdk.llm.mixins.fn_call_converter.IN_CONTEXT_LEARNING_EXAMPLE_SUFFIX)
  * [convert\_tool\_call\_to\_string](#openhands.sdk.llm.mixins.fn_call_converter.convert_tool_call_to_string)
  * [convert\_fncall\_messages\_to\_non\_fncall\_messages](#openhands.sdk.llm.mixins.fn_call_converter.convert_fncall_messages_to_non_fncall_messages)
  * [convert\_non\_fncall\_messages\_to\_fncall\_messages](#openhands.sdk.llm.mixins.fn_call_converter.convert_non_fncall_messages_to_fncall_messages)
  * [convert\_from\_multiple\_tool\_calls\_to\_single\_tool\_call\_messages](#openhands.sdk.llm.mixins.fn_call_converter.convert_from_multiple_tool_calls_to_single_tool_call_messages)
* [openhands.sdk.llm.mixins.non\_native\_fc](#openhands.sdk.llm.mixins.non_native_fc)
  * [NonNativeToolCallingMixin](#openhands.sdk.llm.mixins.non_native_fc.NonNativeToolCallingMixin)
    * [pre\_request\_prompt\_mock](#openhands.sdk.llm.mixins.non_native_fc.NonNativeToolCallingMixin.pre_request_prompt_mock)
* [openhands.sdk.llm.llm\_response](#openhands.sdk.llm.llm_response)
  * [LLMResponse](#openhands.sdk.llm.llm_response.LLMResponse)
    * [id](#openhands.sdk.llm.llm_response.LLMResponse.id)
* [openhands.sdk.llm](#openhands.sdk.llm)
* [openhands.sdk.llm.llm](#openhands.sdk.llm.llm)
  * [LLM](#openhands.sdk.llm.llm.LLM)
    * [completion](#openhands.sdk.llm.llm.LLM.completion)
    * [responses](#openhands.sdk.llm.llm.LLM.responses)
    * [is\_caching\_prompt\_active](#openhands.sdk.llm.llm.LLM.is_caching_prompt_active)
    * [uses\_responses\_api](#openhands.sdk.llm.llm.LLM.uses_responses_api)
    * [model\_info](#openhands.sdk.llm.llm.LLM.model_info)
    * [format\_messages\_for\_llm](#openhands.sdk.llm.llm.LLM.format_messages_for_llm)
    * [format\_messages\_for\_responses](#openhands.sdk.llm.llm.LLM.format_messages_for_responses)
    * [resolve\_diff\_from\_deserialized](#openhands.sdk.llm.llm.LLM.resolve_diff_from_deserialized)
    * [is\_context\_window\_exceeded\_exception](#openhands.sdk.llm.llm.LLM.is_context_window_exceeded_exception)
* [openhands.sdk.llm.utils.verified\_models](#openhands.sdk.llm.utils.verified_models)
* [openhands.sdk.llm.utils.metrics](#openhands.sdk.llm.utils.metrics)
  * [ResponseLatency](#openhands.sdk.llm.utils.metrics.ResponseLatency)
  * [TokenUsage](#openhands.sdk.llm.utils.metrics.TokenUsage)
    * [\_\_add\_\_](#openhands.sdk.llm.utils.metrics.TokenUsage.__add__)
  * [MetricsSnapshot](#openhands.sdk.llm.utils.metrics.MetricsSnapshot)
  * [Metrics](#openhands.sdk.llm.utils.metrics.Metrics)
    * [get\_snapshot](#openhands.sdk.llm.utils.metrics.Metrics.get_snapshot)
    * [add\_token\_usage](#openhands.sdk.llm.utils.metrics.Metrics.add_token_usage)
    * [merge](#openhands.sdk.llm.utils.metrics.Metrics.merge)
    * [get](#openhands.sdk.llm.utils.metrics.Metrics.get)
    * [log](#openhands.sdk.llm.utils.metrics.Metrics.log)
    * [deep\_copy](#openhands.sdk.llm.utils.metrics.Metrics.deep_copy)
    * [diff](#openhands.sdk.llm.utils.metrics.Metrics.diff)
* [openhands.sdk.llm.utils.model\_features](#openhands.sdk.llm.utils.model_features)
  * [model\_matches](#openhands.sdk.llm.utils.model_features.model_matches)
  * [get\_features](#openhands.sdk.llm.utils.model_features.get_features)
* [openhands.sdk.llm.utils.retry\_mixin](#openhands.sdk.llm.utils.retry_mixin)
  * [RetryMixin](#openhands.sdk.llm.utils.retry_mixin.RetryMixin)
    * [retry\_decorator](#openhands.sdk.llm.utils.retry_mixin.RetryMixin.retry_decorator)
    * [log\_retry\_attempt](#openhands.sdk.llm.utils.retry_mixin.RetryMixin.log_retry_attempt)
* [openhands.sdk.llm.utils.unverified\_models](#openhands.sdk.llm.utils.unverified_models)
  * [get\_supported\_llm\_models](#openhands.sdk.llm.utils.unverified_models.get_supported_llm_models)
  * [get\_unverified\_models](#openhands.sdk.llm.utils.unverified_models.get_unverified_models)
* [openhands.sdk.llm.utils.telemetry](#openhands.sdk.llm.utils.telemetry)
  * [Telemetry](#openhands.sdk.llm.utils.telemetry.Telemetry)
    * [on\_response](#openhands.sdk.llm.utils.telemetry.Telemetry.on_response)
* [openhands.sdk.llm.message](#openhands.sdk.llm.message)
  * [MessageToolCall](#openhands.sdk.llm.message.MessageToolCall)
    * [from\_chat\_tool\_call](#openhands.sdk.llm.message.MessageToolCall.from_chat_tool_call)
    * [from\_responses\_function\_call](#openhands.sdk.llm.message.MessageToolCall.from_responses_function_call)
    * [to\_chat\_dict](#openhands.sdk.llm.message.MessageToolCall.to_chat_dict)
    * [to\_responses\_dict](#openhands.sdk.llm.message.MessageToolCall.to_responses_dict)
  * [ThinkingBlock](#openhands.sdk.llm.message.ThinkingBlock)
  * [RedactedThinkingBlock](#openhands.sdk.llm.message.RedactedThinkingBlock)
  * [ReasoningItemModel](#openhands.sdk.llm.message.ReasoningItemModel)
  * [BaseContent](#openhands.sdk.llm.message.BaseContent)
    * [to\_llm\_dict](#openhands.sdk.llm.message.BaseContent.to_llm_dict)
  * [TextContent](#openhands.sdk.llm.message.TextContent)
    * [to\_llm\_dict](#openhands.sdk.llm.message.TextContent.to_llm_dict)
  * [ImageContent](#openhands.sdk.llm.message.ImageContent)
    * [to\_llm\_dict](#openhands.sdk.llm.message.ImageContent.to_llm_dict)
  * [Message](#openhands.sdk.llm.message.Message)
    * [name](#openhands.sdk.llm.message.Message.name)
    * [to\_chat\_dict](#openhands.sdk.llm.message.Message.to_chat_dict)
    * [to\_responses\_value](#openhands.sdk.llm.message.Message.to_responses_value)
    * [to\_responses\_dict](#openhands.sdk.llm.message.Message.to_responses_dict)
    * [from\_llm\_chat\_message](#openhands.sdk.llm.message.Message.from_llm_chat_message)
    * [from\_llm\_responses\_output](#openhands.sdk.llm.message.Message.from_llm_responses_output)
  * [content\_to\_str](#openhands.sdk.llm.message.content_to_str)
* [openhands.sdk.llm.exceptions](#openhands.sdk.llm.exceptions)
  * [LLMError](#openhands.sdk.llm.exceptions.LLMError)
  * [LLMMalformedActionError](#openhands.sdk.llm.exceptions.LLMMalformedActionError)
  * [LLMNoActionError](#openhands.sdk.llm.exceptions.LLMNoActionError)
  * [LLMResponseError](#openhands.sdk.llm.exceptions.LLMResponseError)
  * [LLMNoResponseError](#openhands.sdk.llm.exceptions.LLMNoResponseError)
  * [FunctionCallConversionError](#openhands.sdk.llm.exceptions.FunctionCallConversionError)
  * [FunctionCallValidationError](#openhands.sdk.llm.exceptions.FunctionCallValidationError)
  * [FunctionCallNotExistsError](#openhands.sdk.llm.exceptions.FunctionCallNotExistsError)
  * [OperationCancelled](#openhands.sdk.llm.exceptions.OperationCancelled)
* [openhands.sdk.llm.llm\_registry](#openhands.sdk.llm.llm_registry)
  * [LLMRegistry](#openhands.sdk.llm.llm_registry.LLMRegistry)
    * [\_\_init\_\_](#openhands.sdk.llm.llm_registry.LLMRegistry.__init__)
    * [subscribe](#openhands.sdk.llm.llm_registry.LLMRegistry.subscribe)
    * [notify](#openhands.sdk.llm.llm_registry.LLMRegistry.notify)
    * [usage\_to\_llm](#openhands.sdk.llm.llm_registry.LLMRegistry.usage_to_llm)
    * [add](#openhands.sdk.llm.llm_registry.LLMRegistry.add)
    * [get](#openhands.sdk.llm.llm_registry.LLMRegistry.get)
    * [list\_usage\_ids](#openhands.sdk.llm.llm_registry.LLMRegistry.list_usage_ids)
    * [list\_services](#openhands.sdk.llm.llm_registry.LLMRegistry.list_services)
* [openhands.sdk.llm.options.common](#openhands.sdk.llm.options.common)
  * [apply\_defaults\_if\_absent](#openhands.sdk.llm.options.common.apply_defaults_if_absent)
* [openhands.sdk.llm.options](#openhands.sdk.llm.options)
* [openhands.sdk.llm.options.chat\_options](#openhands.sdk.llm.options.chat_options)
  * [select\_chat\_options](#openhands.sdk.llm.options.chat_options.select_chat_options)
* [openhands.sdk.llm.options.responses\_options](#openhands.sdk.llm.options.responses_options)
  * [select\_responses\_options](#openhands.sdk.llm.options.responses_options.select_responses_options)
* [openhands.sdk.llm.router.impl.random](#openhands.sdk.llm.router.impl.random)
  * [RandomRouter](#openhands.sdk.llm.router.impl.random.RandomRouter)
* [openhands.sdk.llm.router.impl.multimodal](#openhands.sdk.llm.router.impl.multimodal)
  * [MultimodalRouter](#openhands.sdk.llm.router.impl.multimodal.MultimodalRouter)
    * [select\_llm](#openhands.sdk.llm.router.impl.multimodal.MultimodalRouter.select_llm)
* [openhands.sdk.llm.router.base](#openhands.sdk.llm.router.base)
  * [RouterLLM](#openhands.sdk.llm.router.base.RouterLLM)
    * [llms\_for\_routing](#openhands.sdk.llm.router.base.RouterLLM.llms_for_routing)
    * [completion](#openhands.sdk.llm.router.base.RouterLLM.completion)
    * [select\_llm](#openhands.sdk.llm.router.base.RouterLLM.select_llm)
    * [\_\_getattr\_\_](#openhands.sdk.llm.router.base.RouterLLM.__getattr__)
    * [\_\_str\_\_](#openhands.sdk.llm.router.base.RouterLLM.__str__)
    * [set\_placeholder\_model](#openhands.sdk.llm.router.base.RouterLLM.set_placeholder_model)
* [openhands.sdk.llm.router](#openhands.sdk.llm.router)
* [openhands.sdk.security.llm\_analyzer](#openhands.sdk.security.llm_analyzer)
  * [LLMSecurityAnalyzer](#openhands.sdk.security.llm_analyzer.LLMSecurityAnalyzer)
    * [security\_risk](#openhands.sdk.security.llm_analyzer.LLMSecurityAnalyzer.security_risk)
* [openhands.sdk.security.analyzer](#openhands.sdk.security.analyzer)
  * [SecurityAnalyzerBase](#openhands.sdk.security.analyzer.SecurityAnalyzerBase)
    * [security\_risk](#openhands.sdk.security.analyzer.SecurityAnalyzerBase.security_risk)
    * [analyze\_event](#openhands.sdk.security.analyzer.SecurityAnalyzerBase.analyze_event)
    * [should\_require\_confirmation](#openhands.sdk.security.analyzer.SecurityAnalyzerBase.should_require_confirmation)
    * [analyze\_pending\_actions](#openhands.sdk.security.analyzer.SecurityAnalyzerBase.analyze_pending_actions)
* [openhands.sdk.security.confirmation\_policy](#openhands.sdk.security.confirmation_policy)
  * [ConfirmationPolicyBase](#openhands.sdk.security.confirmation_policy.ConfirmationPolicyBase)
    * [should\_confirm](#openhands.sdk.security.confirmation_policy.ConfirmationPolicyBase.should_confirm)
* [openhands.sdk.security](#openhands.sdk.security)
* [openhands.sdk.security.risk](#openhands.sdk.security.risk)
  * [SecurityRisk](#openhands.sdk.security.risk.SecurityRisk)
    * [description](#openhands.sdk.security.risk.SecurityRisk.description)
    * [get\_color](#openhands.sdk.security.risk.SecurityRisk.get_color)
    * [visualize](#openhands.sdk.security.risk.SecurityRisk.visualize)
    * [is\_riskier](#openhands.sdk.security.risk.SecurityRisk.is_riskier)
* [openhands.sdk.context](#openhands.sdk.context)
* [openhands.sdk.context.agent\_context](#openhands.sdk.context.agent_context)
  * [AgentContext](#openhands.sdk.context.agent_context.AgentContext)
    * [get\_system\_message\_suffix](#openhands.sdk.context.agent_context.AgentContext.get_system_message_suffix)
    * [get\_user\_message\_suffix](#openhands.sdk.context.agent_context.AgentContext.get_user_message_suffix)
* [openhands.sdk.context.view](#openhands.sdk.context.view)
  * [View](#openhands.sdk.context.view.View)
    * [unhandled\_condensation\_request](#openhands.sdk.context.view.View.unhandled_condensation_request)
    * [condensations](#openhands.sdk.context.view.View.condensations)
    * [most\_recent\_condensation](#openhands.sdk.context.view.View.most_recent_condensation)
    * [summary\_event\_index](#openhands.sdk.context.view.View.summary_event_index)
    * [summary\_event](#openhands.sdk.context.view.View.summary_event)
    * [filter\_unmatched\_tool\_calls](#openhands.sdk.context.view.View.filter_unmatched_tool_calls)
    * [from\_events](#openhands.sdk.context.view.View.from_events)
* [openhands.sdk.context.prompts](#openhands.sdk.context.prompts)
* [openhands.sdk.context.prompts.prompt](#openhands.sdk.context.prompts.prompt)
  * [render\_template](#openhands.sdk.context.prompts.prompt.render_template)
* [openhands.sdk.context.condenser.no\_op\_condenser](#openhands.sdk.context.condenser.no_op_condenser)
  * [NoOpCondenser](#openhands.sdk.context.condenser.no_op_condenser.NoOpCondenser)
* [openhands.sdk.context.condenser.llm\_summarizing\_condenser](#openhands.sdk.context.condenser.llm_summarizing_condenser)
* [openhands.sdk.context.condenser.base](#openhands.sdk.context.condenser.base)
  * [CondenserBase](#openhands.sdk.context.condenser.base.CondenserBase)
    * [condense](#openhands.sdk.context.condenser.base.CondenserBase.condense)
    * [handles\_condensation\_requests](#openhands.sdk.context.condenser.base.CondenserBase.handles_condensation_requests)
  * [PipelinableCondenserBase](#openhands.sdk.context.condenser.base.PipelinableCondenserBase)
  * [RollingCondenser](#openhands.sdk.context.condenser.base.RollingCondenser)
    * [should\_condense](#openhands.sdk.context.condenser.base.RollingCondenser.should_condense)
    * [get\_condensation](#openhands.sdk.context.condenser.base.RollingCondenser.get_condensation)
* [openhands.sdk.context.condenser](#openhands.sdk.context.condenser)
* [openhands.sdk.context.condenser.pipeline\_condenser](#openhands.sdk.context.condenser.pipeline_condenser)
  * [PipelineCondenser](#openhands.sdk.context.condenser.pipeline_condenser.PipelineCondenser)
    * [condensers](#openhands.sdk.context.condenser.pipeline_condenser.PipelineCondenser.condensers)
* [openhands.sdk.context.skills.types](#openhands.sdk.context.skills.types)
  * [InputMetadata](#openhands.sdk.context.skills.types.InputMetadata)
  * [SkillKnowledge](#openhands.sdk.context.skills.types.SkillKnowledge)
  * [SkillResponse](#openhands.sdk.context.skills.types.SkillResponse)
  * [SkillContentResponse](#openhands.sdk.context.skills.types.SkillContentResponse)
* [openhands.sdk.context.skills.trigger](#openhands.sdk.context.skills.trigger)
  * [BaseTrigger](#openhands.sdk.context.skills.trigger.BaseTrigger)
  * [KeywordTrigger](#openhands.sdk.context.skills.trigger.KeywordTrigger)
  * [TaskTrigger](#openhands.sdk.context.skills.trigger.TaskTrigger)
* [openhands.sdk.context.skills](#openhands.sdk.context.skills)
* [openhands.sdk.context.skills.skill](#openhands.sdk.context.skills.skill)
  * [Skill](#openhands.sdk.context.skills.skill.Skill)
    * [load](#openhands.sdk.context.skills.skill.Skill.load)
    * [match\_trigger](#openhands.sdk.context.skills.skill.Skill.match_trigger)
    * [extract\_variables](#openhands.sdk.context.skills.skill.Skill.extract_variables)
    * [requires\_user\_input](#openhands.sdk.context.skills.skill.Skill.requires_user_input)
  * [load\_skills\_from\_dir](#openhands.sdk.context.skills.skill.load_skills_from_dir)
* [openhands.sdk.context.skills.exceptions](#openhands.sdk.context.skills.exceptions)
  * [SkillError](#openhands.sdk.context.skills.exceptions.SkillError)
  * [SkillValidationError](#openhands.sdk.context.skills.exceptions.SkillValidationError)
* [openhands.sdk.agent.base](#openhands.sdk.agent.base)
  * [AgentBase](#openhands.sdk.agent.base.AgentBase)
    * [prompt\_dir](#openhands.sdk.agent.base.AgentBase.prompt_dir)
    * [name](#openhands.sdk.agent.base.AgentBase.name)
    * [system\_message](#openhands.sdk.agent.base.AgentBase.system_message)
    * [init\_state](#openhands.sdk.agent.base.AgentBase.init_state)
    * [step](#openhands.sdk.agent.base.AgentBase.step)
    * [resolve\_diff\_from\_deserialized](#openhands.sdk.agent.base.AgentBase.resolve_diff_from_deserialized)
    * [model\_dump\_succint](#openhands.sdk.agent.base.AgentBase.model_dump_succint)
    * [get\_all\_llms](#openhands.sdk.agent.base.AgentBase.get_all_llms)
    * [tools\_map](#openhands.sdk.agent.base.AgentBase.tools_map)
* [openhands.sdk.agent](#openhands.sdk.agent)
* [openhands.sdk.agent.agent](#openhands.sdk.agent.agent)
* [openhands.sdk.mcp.tool](#openhands.sdk.mcp.tool)
  * [MCPToolExecutor](#openhands.sdk.mcp.tool.MCPToolExecutor)
    * [\_\_call\_\_](#openhands.sdk.mcp.tool.MCPToolExecutor.__call__)
  * [MCPToolDefinition](#openhands.sdk.mcp.tool.MCPToolDefinition)
    * [\_\_call\_\_](#openhands.sdk.mcp.tool.MCPToolDefinition.__call__)
    * [action\_from\_arguments](#openhands.sdk.mcp.tool.MCPToolDefinition.action_from_arguments)
    * [to\_openai\_tool](#openhands.sdk.mcp.tool.MCPToolDefinition.to_openai_tool)
* [openhands.sdk.mcp](#openhands.sdk.mcp)
* [openhands.sdk.mcp.definition](#openhands.sdk.mcp.definition)
  * [MCPToolAction](#openhands.sdk.mcp.definition.MCPToolAction)
    * [to\_mcp\_arguments](#openhands.sdk.mcp.definition.MCPToolAction.to_mcp_arguments)
  * [MCPToolObservation](#openhands.sdk.mcp.definition.MCPToolObservation)
    * [from\_call\_tool\_result](#openhands.sdk.mcp.definition.MCPToolObservation.from_call_tool_result)
    * [to\_llm\_content](#openhands.sdk.mcp.definition.MCPToolObservation.to_llm_content)
    * [visualize](#openhands.sdk.mcp.definition.MCPToolObservation.visualize)
* [openhands.sdk.mcp.utils](#openhands.sdk.mcp.utils)
  * [log\_handler](#openhands.sdk.mcp.utils.log_handler)
  * [create\_mcp\_tools](#openhands.sdk.mcp.utils.create_mcp_tools)
* [openhands.sdk.mcp.client](#openhands.sdk.mcp.client)
  * [MCPClient](#openhands.sdk.mcp.client.MCPClient)
    * [call\_async\_from\_sync](#openhands.sdk.mcp.client.MCPClient.call_async_from_sync)
    * [call\_sync\_from\_async](#openhands.sdk.mcp.client.MCPClient.call_sync_from_async)
    * [sync\_close](#openhands.sdk.mcp.client.MCPClient.sync_close)
    * [\_\_del\_\_](#openhands.sdk.mcp.client.MCPClient.__del__)
* [openhands.sdk.git.models](#openhands.sdk.git.models)
* [openhands.sdk.git.git\_diff](#openhands.sdk.git.git_diff)
  * [MAX\_FILE\_SIZE\_FOR\_GIT\_DIFF](#openhands.sdk.git.git_diff.MAX_FILE_SIZE_FOR_GIT_DIFF)
  * [get\_closest\_git\_repo](#openhands.sdk.git.git_diff.get_closest_git_repo)
  * [get\_git\_diff](#openhands.sdk.git.git_diff.get_git_diff)
* [openhands.sdk.git.utils](#openhands.sdk.git.utils)
  * [run\_git\_command](#openhands.sdk.git.utils.run_git_command)
  * [get\_valid\_ref](#openhands.sdk.git.utils.get_valid_ref)
  * [validate\_git\_repository](#openhands.sdk.git.utils.validate_git_repository)
* [openhands.sdk.git.exceptions](#openhands.sdk.git.exceptions)
  * [GitError](#openhands.sdk.git.exceptions.GitError)
  * [GitRepositoryError](#openhands.sdk.git.exceptions.GitRepositoryError)
  * [GitCommandError](#openhands.sdk.git.exceptions.GitCommandError)
  * [GitPathError](#openhands.sdk.git.exceptions.GitPathError)
* [openhands.sdk.git.git\_changes](#openhands.sdk.git.git_changes)
  * [get\_changes\_in\_repo](#openhands.sdk.git.git_changes.get_changes_in_repo)
* [openhands.sdk.io.base](#openhands.sdk.io.base)
  * [FileStore](#openhands.sdk.io.base.FileStore)
    * [write](#openhands.sdk.io.base.FileStore.write)
    * [read](#openhands.sdk.io.base.FileStore.read)
    * [list](#openhands.sdk.io.base.FileStore.list)
    * [delete](#openhands.sdk.io.base.FileStore.delete)
* [openhands.sdk.io](#openhands.sdk.io)
* [openhands.sdk.io.local](#openhands.sdk.io.local)
* [openhands.sdk.io.memory](#openhands.sdk.io.memory)
* [openhands.sdk.event.condenser](#openhands.sdk.event.condenser)
  * [Condensation](#openhands.sdk.event.condenser.Condensation)
  * [CondensationRequest](#openhands.sdk.event.condenser.CondensationRequest)
  * [CondensationSummaryEvent](#openhands.sdk.event.condenser.CondensationSummaryEvent)
    * [summary](#openhands.sdk.event.condenser.CondensationSummaryEvent.summary)
* [openhands.sdk.event.types](#openhands.sdk.event.types)
  * [EventID](#openhands.sdk.event.types.EventID)
  * [ToolCallID](#openhands.sdk.event.types.ToolCallID)
* [openhands.sdk.event.base](#openhands.sdk.event.base)
  * [Event](#openhands.sdk.event.base.Event)
    * [timestamp](#openhands.sdk.event.base.Event.timestamp)
    * [visualize](#openhands.sdk.event.base.Event.visualize)
    * [\_\_str\_\_](#openhands.sdk.event.base.Event.__str__)
    * [\_\_repr\_\_](#openhands.sdk.event.base.Event.__repr__)
  * [LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)
    * [\_\_str\_\_](#openhands.sdk.event.base.LLMConvertibleEvent.__str__)
    * [events\_to\_messages](#openhands.sdk.event.base.LLMConvertibleEvent.events_to_messages)
* [openhands.sdk.event](#openhands.sdk.event)
* [openhands.sdk.event.llm\_convertible.action](#openhands.sdk.event.llm_convertible.action)
  * [ActionEvent](#openhands.sdk.event.llm_convertible.action.ActionEvent)
    * [visualize](#openhands.sdk.event.llm_convertible.action.ActionEvent.visualize)
    * [to\_llm\_message](#openhands.sdk.event.llm_convertible.action.ActionEvent.to_llm_message)
    * [\_\_str\_\_](#openhands.sdk.event.llm_convertible.action.ActionEvent.__str__)
* [openhands.sdk.event.llm\_convertible](#openhands.sdk.event.llm_convertible)
* [openhands.sdk.event.llm\_convertible.observation](#openhands.sdk.event.llm_convertible.observation)
  * [ObservationBaseEvent](#openhands.sdk.event.llm_convertible.observation.ObservationBaseEvent)
  * [ObservationEvent](#openhands.sdk.event.llm_convertible.observation.ObservationEvent)
    * [visualize](#openhands.sdk.event.llm_convertible.observation.ObservationEvent.visualize)
    * [\_\_str\_\_](#openhands.sdk.event.llm_convertible.observation.ObservationEvent.__str__)
  * [UserRejectObservation](#openhands.sdk.event.llm_convertible.observation.UserRejectObservation)
    * [visualize](#openhands.sdk.event.llm_convertible.observation.UserRejectObservation.visualize)
    * [\_\_str\_\_](#openhands.sdk.event.llm_convertible.observation.UserRejectObservation.__str__)
  * [AgentErrorEvent](#openhands.sdk.event.llm_convertible.observation.AgentErrorEvent)
    * [visualize](#openhands.sdk.event.llm_convertible.observation.AgentErrorEvent.visualize)
    * [\_\_str\_\_](#openhands.sdk.event.llm_convertible.observation.AgentErrorEvent.__str__)
* [openhands.sdk.event.llm\_convertible.message](#openhands.sdk.event.llm_convertible.message)
  * [MessageEvent](#openhands.sdk.event.llm_convertible.message.MessageEvent)
    * [thinking\_blocks](#openhands.sdk.event.llm_convertible.message.MessageEvent.thinking_blocks)
    * [visualize](#openhands.sdk.event.llm_convertible.message.MessageEvent.visualize)
    * [\_\_str\_\_](#openhands.sdk.event.llm_convertible.message.MessageEvent.__str__)
* [openhands.sdk.event.llm\_convertible.system](#openhands.sdk.event.llm_convertible.system)
  * [SystemPromptEvent](#openhands.sdk.event.llm_convertible.system.SystemPromptEvent)
    * [visualize](#openhands.sdk.event.llm_convertible.system.SystemPromptEvent.visualize)
    * [\_\_str\_\_](#openhands.sdk.event.llm_convertible.system.SystemPromptEvent.__str__)
* [openhands.sdk.event.conversation\_state](#openhands.sdk.event.conversation_state)
  * [ConversationStateUpdateEvent](#openhands.sdk.event.conversation_state.ConversationStateUpdateEvent)
    * [from\_conversation\_state](#openhands.sdk.event.conversation_state.ConversationStateUpdateEvent.from_conversation_state)
* [openhands.sdk.event.user\_action](#openhands.sdk.event.user_action)
  * [PauseEvent](#openhands.sdk.event.user_action.PauseEvent)
    * [visualize](#openhands.sdk.event.user_action.PauseEvent.visualize)
    * [\_\_str\_\_](#openhands.sdk.event.user_action.PauseEvent.__str__)

<a id="openhands.sdk"></a>

# openhands.sdk

<a id="openhands.sdk.tool.registry"></a>

# openhands.sdk.tool.registry

<a id="openhands.sdk.tool.registry.Resolver"></a>

#### Resolver

A resolver produces ToolDefinition instances for given params.

**Arguments**:

- `params` - Arbitrary parameters passed to the resolver. These are typically
  used to configure the ToolDefinition instances that are created.
- `conversation` - Optional conversation state to get directories from.
- `Returns` - A sequence of ToolDefinition instances. Most of the time this will be a
  single-item
  sequence, but in some cases a ToolDefinition.create may produce multiple tools
  (e.g., BrowserToolSet).

<a id="openhands.sdk.tool.tool"></a>

# openhands.sdk.tool.tool

<a id="openhands.sdk.tool.tool.ToolAnnotations"></a>

## ToolAnnotations Objects

```python
class ToolAnnotations(BaseModel)
```

Annotations to provide hints about the tool's behavior.

Based on Model Context Protocol (MCP) spec:
https://github.com/modelcontextprotocol/modelcontextprotocol/blob/caf3424488b10b4a7b1f8cb634244a450a1f4400/schema/2025-06-18/schema.ts#L838

<a id="openhands.sdk.tool.tool.ToolExecutor"></a>

## ToolExecutor Objects

```python
class ToolExecutor()
```

Executor function type for a Tool.

<a id="openhands.sdk.tool.tool.ToolExecutor.__call__"></a>

#### \_\_call\_\_

```python
@abstractmethod
def __call__(action: ActionT,
             conversation: "LocalConversation | None" = None) -> ObservationT
```

Execute the tool with the given action and return an observation.

**Arguments**:

- `action` - The action to execute, containing the parameters and context
  needed for the tool operation.
- `conversation` - The conversation context for the tool execution.
- `Note` - This is typed as LocalConversation (not
  BaseConversation) because all tool executions happen
  within a LocalConversation context. Even when tools are
  invoked via RemoteConversation, the remote agent server
  creates a LocalConversation instance to handle the actual
  tool execution. See https://github.com/OpenHands/agent-sdk/pull/925
  for more details.
  

**Returns**:

  An observation containing the results of the tool execution.

<a id="openhands.sdk.tool.tool.ToolExecutor.close"></a>

#### close

```python
def close() -> None
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

<a id="openhands.sdk.tool.tool.ExecutableTool"></a>

## ExecutableTool Objects

```python
class ExecutableTool(Protocol)
```

Protocol for tools that are guaranteed to have a non-None executor.

This eliminates the need for runtime None checks and type narrowing
when working with tools that are known to be executable.

<a id="openhands.sdk.tool.tool.ExecutableTool.executor"></a>

#### executor

Non-optional executor

<a id="openhands.sdk.tool.tool.ExecutableTool.__call__"></a>

#### \_\_call\_\_

```python
def __call__(action: Action,
             conversation: "LocalConversation | None" = None) -> Observation
```

Execute the tool with the given action.

<a id="openhands.sdk.tool.tool.ToolBase"></a>

## ToolBase Objects

```python
class ToolBase(DiscriminatedUnionMixin, ABC)
```

Tool that wraps an executor function with input/output validation and schema.

- Normalize input/output schemas (class or dict) into both model+schema.
- Validate inputs before execute.
- Coerce outputs only if an output model is defined; else return vanilla JSON.
- Export MCP tool description.

<a id="openhands.sdk.tool.tool.ToolBase.create"></a>

#### create

```python
@classmethod
@abstractmethod
def create(cls, *args, **kwargs) -> Sequence[Self]
```

Create a sequence of Tool instances. Placeholder for subclasses.

This can be overridden in subclasses to provide custom initialization logic
(e.g., typically initializing the executor with parameters).

**Returns**:

  A sequence of Tool instances. Even single tools are returned as a sequence
  to provide a consistent interface and eliminate union return types.

<a id="openhands.sdk.tool.tool.ToolBase.set_executor"></a>

#### set\_executor

```python
def set_executor(executor: ToolExecutor) -> Self
```

Create a new Tool instance with the given executor.

<a id="openhands.sdk.tool.tool.ToolBase.as_executable"></a>

#### as\_executable

```python
def as_executable() -> ExecutableTool
```

Return this tool as an ExecutableTool, ensuring it has an executor.

This method eliminates the need for runtime None checks by guaranteeing
that the returned tool has a non-None executor.

**Returns**:

  This tool instance, typed as ExecutableTool.
  

**Raises**:

- `NotImplementedError` - If the tool has no executor.

<a id="openhands.sdk.tool.tool.ToolBase.action_from_arguments"></a>

#### action\_from\_arguments

```python
def action_from_arguments(arguments: dict[str, Any]) -> Action
```

Create an action from parsed arguments.

This method can be overridden by subclasses to provide custom logic
for creating actions from arguments (e.g., for MCP tools).

**Arguments**:

- `arguments` - The parsed arguments from the tool call.
  

**Returns**:

  The action instance created from the arguments.

<a id="openhands.sdk.tool.tool.ToolBase.__call__"></a>

#### \_\_call\_\_

```python
def __call__(action: ActionT,
             conversation: "LocalConversation | None" = None) -> Observation
```

Validate input, execute, and coerce output.

We always return some Observation subclass, but not always the
generic ObservationT.

<a id="openhands.sdk.tool.tool.ToolBase.to_mcp_tool"></a>

#### to\_mcp\_tool

```python
def to_mcp_tool(input_schema: dict[str, Any] | None = None,
                output_schema: dict[str, Any] | None = None) -> dict[str, Any]
```

Convert a Tool to an MCP tool definition.

Allow overriding input/output schemas (usually by subclasses).

**Arguments**:

- `input_schema` - Optionally override the input schema.
- `output_schema` - Optionally override the output schema.

<a id="openhands.sdk.tool.tool.ToolBase.to_openai_tool"></a>

#### to\_openai\_tool

```python
def to_openai_tool(
        add_security_risk_prediction: bool = False,
        action_type: type[Schema] | None = None) -> ChatCompletionToolParam
```

Convert a Tool to an OpenAI tool.

**Arguments**:

- `add_security_risk_prediction` - Whether to add a `security_risk` field
  to the action schema for LLM to predict. This is useful for
  tools that may have safety risks, so the LLM can reason about
  the risk level before calling the tool.
- `action_type` - Optionally override the action_type to use for the schema.
  This is useful for MCPTool to use a dynamically created action type
  based on the tool's input schema.

<a id="openhands.sdk.tool.tool.ToolBase.to_responses_tool"></a>

#### to\_responses\_tool

```python
def to_responses_tool(
        add_security_risk_prediction: bool = False,
        action_type: type[Schema] | None = None) -> FunctionToolParam
```

Convert a Tool to a Responses API function tool (LiteLLM typed).

For Responses API, function tools expect top-level keys:
{ "type": "function", "name": ..., "description": ..., "parameters": ... }

<a id="openhands.sdk.tool.tool.ToolDefinition"></a>

## ToolDefinition Objects

```python
class ToolDefinition()
```

Concrete tool class that inherits from ToolBase.

This class serves as a concrete implementation of ToolBase for cases where
you want to create a tool instance directly without implementing a custom
subclass. Built-in tools (like FinishTool, ThinkTool) are instantiated
directly from this class, while more complex tools (like BashTool,
FileEditorTool) inherit from this class and provide their own create()
method implementations.

<a id="openhands.sdk.tool.tool.ToolDefinition.create"></a>

#### create

```python
@classmethod
def create(cls, *args, **kwargs) -> Sequence[Self]
```

Create a sequence of ToolDefinition instances.

TODO https://github.com/OpenHands/agent-sdk/issues/493
Refactor this - the ToolDefinition class should not have a concrete create()
implementation. Built-in tools should be refactored to not rely on this
method, and then this should be made abstract with @abstractmethod.

<a id="openhands.sdk.tool"></a>

# openhands.sdk.tool

OpenHands runtime package.

<a id="openhands.sdk.tool.spec"></a>

# openhands.sdk.tool.spec

<a id="openhands.sdk.tool.spec.Tool"></a>

## Tool Objects

```python
class Tool(BaseModel)
```

Defines a tool to be initialized for the agent.

This is only used in agent-sdk for type schema for server use.

<a id="openhands.sdk.tool.spec.Tool.validate_name"></a>

#### validate\_name

```python
@field_validator("name")
@classmethod
def validate_name(cls, v: str) -> str
```

Validate that name is not empty.

<a id="openhands.sdk.tool.spec.Tool.validate_params"></a>

#### validate\_params

```python
@field_validator("params", mode="before")
@classmethod
def validate_params(cls, v: dict[str, Any] | None) -> dict[str, Any]
```

Convert None params to empty dict.

<a id="openhands.sdk.tool.builtins"></a>

# openhands.sdk.tool.builtins

Implementing essential tools that doesn't interact with the environment.

These are built in and are *required* for the agent to work.

For tools that require interacting with the environment, add them to `openhands-tools`.

<a id="openhands.sdk.tool.builtins.finish"></a>

# openhands.sdk.tool.builtins.finish

<a id="openhands.sdk.tool.builtins.finish.FinishAction"></a>

## FinishAction Objects

```python
class FinishAction(Action)
```

<a id="openhands.sdk.tool.builtins.finish.FinishAction.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this action.

<a id="openhands.sdk.tool.builtins.finish.FinishObservation"></a>

## FinishObservation Objects

```python
class FinishObservation(Observation)
```

<a id="openhands.sdk.tool.builtins.finish.FinishObservation.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation - empty since action shows the message.

<a id="openhands.sdk.tool.builtins.think"></a>

# openhands.sdk.tool.builtins.think

<a id="openhands.sdk.tool.builtins.think.ThinkAction"></a>

## ThinkAction Objects

```python
class ThinkAction(Action)
```

Action for logging a thought without making any changes.

<a id="openhands.sdk.tool.builtins.think.ThinkAction.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation with thinking styling.

<a id="openhands.sdk.tool.builtins.think.ThinkObservation"></a>

## ThinkObservation Objects

```python
class ThinkObservation(Observation)
```

Observation returned after logging a thought.

<a id="openhands.sdk.tool.builtins.think.ThinkObservation.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation - empty since action shows the thought.

<a id="openhands.sdk.tool.builtins.think.THINK_DESCRIPTION"></a>

#### THINK\_DESCRIPTION

noqa: E501

<a id="openhands.sdk.tool.schema"></a>

# openhands.sdk.tool.schema

<a id="openhands.sdk.tool.schema.py_type"></a>

#### py\_type

```python
def py_type(spec: dict[str, Any]) -> Any
```

Map JSON schema types to Python types.

<a id="openhands.sdk.tool.schema.Schema"></a>

## Schema Objects

```python
class Schema(DiscriminatedUnionMixin)
```

Base schema for input action / output observation.

<a id="openhands.sdk.tool.schema.Schema.to_mcp_schema"></a>

#### to\_mcp\_schema

```python
@classmethod
def to_mcp_schema(cls) -> dict[str, Any]
```

Convert to JSON schema format compatible with MCP.

<a id="openhands.sdk.tool.schema.Schema.from_mcp_schema"></a>

#### from\_mcp\_schema

```python
@classmethod
def from_mcp_schema(cls: type[S], model_name: str,
                    schema: dict[str, Any]) -> type["S"]
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

<a id="openhands.sdk.tool.schema.Action"></a>

## Action Objects

```python
class Action(Schema, ABC)
```

Base schema for input action.

<a id="openhands.sdk.tool.schema.Action.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

<a id="openhands.sdk.tool.schema.Observation"></a>

## Observation Objects

```python
class Observation(Schema, ABC)
```

Base schema for output observation.

<a id="openhands.sdk.tool.schema.Observation.to_llm_content"></a>

#### to\_llm\_content

```python
@property
@abstractmethod
def to_llm_content() -> Sequence[TextContent | ImageContent]
```

Get the observation string to show to the agent.

<a id="openhands.sdk.tool.schema.Observation.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

<a id="openhands.sdk.conversation.response_utils"></a>

# openhands.sdk.conversation.response\_utils

Utility functions for extracting agent responses from conversation events.

<a id="openhands.sdk.conversation.response_utils.get_agent_final_response"></a>

#### get\_agent\_final\_response

```python
def get_agent_final_response(events: Sequence[Event]) -> str
```

Extract the final response from the agent.

An agent can end a conversation in two ways:
1. By calling the finish tool
2. By returning a text message with no tool calls

**Arguments**:

- `events` - List of conversation events to search through.
  

**Returns**:

  The final response message from the agent, or empty string if not found.

<a id="openhands.sdk.conversation.impl.local_conversation"></a>

# openhands.sdk.conversation.impl.local\_conversation

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation"></a>

## LocalConversation Objects

```python
class LocalConversation(BaseConversation)
```

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.__init__"></a>

#### \_\_init\_\_

```python
def __init__(agent: AgentBase,
             workspace: str | LocalWorkspace,
             persistence_dir: str | None = None,
             conversation_id: ConversationID | None = None,
             callbacks: list[ConversationCallbackType] | None = None,
             max_iteration_per_run: int = 500,
             stuck_detection: bool = True,
             visualize: bool = True,
             name_for_visualization: str | None = None,
             secrets: Mapping[str, SecretValue] | None = None,
             **_: object)
```

Initialize the conversation.

**Arguments**:

- `agent` - The agent to use for the conversation
- `workspace` - Working directory for agent operations and tool execution
- `persistence_dir` - Directory for persisting conversation state and events
- `conversation_id` - Optional ID for the conversation. If provided, will
  be used to identify the conversation. The user might want to
  suffix their persistent filestore with this ID.
- `callbacks` - Optional list of callback functions to handle events
- `max_iteration_per_run` - Maximum number of iterations per run
- `visualize` - Whether to enable default visualization. If True, adds
  a default visualizer callback. If False, relies on
  application to provide visualization through callbacks.
- `name_for_visualization` - Optional name to prefix in panel titles to identify
  which agent/conversation is speaking.
- `stuck_detection` - Whether to enable stuck detection

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.id"></a>

#### id

```python
@property
def id() -> ConversationID
```

Get the unique ID of the conversation.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.state"></a>

#### state

```python
@property
def state() -> ConversationState
```

Get the conversation state.

It returns a protocol that has a subset of ConversationState methods
and properties. We will have the ability to access the same properties
of ConversationState on a remote conversation object.
But we won't be able to access methods that mutate the state.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.stuck_detector"></a>

#### stuck\_detector

```python
@property
def stuck_detector() -> StuckDetector | None
```

Get the stuck detector instance if enabled.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.send_message"></a>

#### send\_message

```python
def send_message(message: str | Message) -> None
```

Send a message to the agent.

**Arguments**:

- `message` - Either a string (which will be converted to a user message)
  or a Message object

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.run"></a>

#### run

```python
def run() -> None
```

Runs the conversation until the agent finishes.

In confirmation mode:
- First call: creates actions but doesn't execute them, stops and waits
- Second call: executes pending actions (implicit confirmation)

In normal mode:
- Creates and executes actions immediately

Can be paused between steps

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.set_confirmation_policy"></a>

#### set\_confirmation\_policy

```python
def set_confirmation_policy(policy: ConfirmationPolicyBase) -> None
```

Set the confirmation policy and store it in conversation state.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.reject_pending_actions"></a>

#### reject\_pending\_actions

```python
def reject_pending_actions(reason: str = "User rejected the action") -> None
```

Reject all pending actions from the agent.

This is a non-invasive method to reject actions between run() calls.
Also clears the agent_waiting_for_confirmation flag.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.pause"></a>

#### pause

```python
def pause() -> None
```

Pause agent execution.

This method can be called from any thread to request that the agent
pause execution. The pause will take effect at the next iteration
of the run loop (between agent steps).

Note: If called during an LLM completion, the pause will not take
effect until the current LLM call completes.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.update_secrets"></a>

#### update\_secrets

```python
def update_secrets(secrets: Mapping[str, SecretValue]) -> None
```

Add secrets to the conversation.

**Arguments**:

- `secrets` - Dictionary mapping secret keys to values or no-arg callables.
  SecretValue = str | Callable[[], str]. Callables are invoked lazily
  when a command references the secret key.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.close"></a>

#### close

```python
def close() -> None
```

Close the conversation and clean up all tool executors.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.generate_title"></a>

#### generate\_title

```python
def generate_title(llm: LLM | None = None, max_length: int = 50) -> str
```

Generate a title for the conversation based on the first user message.

**Arguments**:

- `llm` - Optional LLM to use for title generation. If not provided,
  uses self.agent.llm.
- `max_length` - Maximum length of the generated title.
  

**Returns**:

  A generated title for the conversation.
  

**Raises**:

- `ValueError` - If no user messages are found in the conversation.

<a id="openhands.sdk.conversation.impl.local_conversation.LocalConversation.__del__"></a>

#### \_\_del\_\_

```python
def __del__() -> None
```

Ensure cleanup happens when conversation is destroyed.

<a id="openhands.sdk.conversation.impl.remote_conversation"></a>

# openhands.sdk.conversation.impl.remote\_conversation

<a id="openhands.sdk.conversation.impl.remote_conversation.WebSocketCallbackClient"></a>

## WebSocketCallbackClient Objects

```python
class WebSocketCallbackClient()
```

Minimal WS client: connects, forwards events, retries on error.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteEventsList"></a>

## RemoteEventsList Objects

```python
class RemoteEventsList(EventsListBase)
```

A list-like, read-only view of remote conversation events.

On first access it fetches existing events from the server. Afterwards,
it relies on the WebSocket stream to incrementally append new events.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteEventsList.add_event"></a>

#### add\_event

```python
def add_event(event: Event) -> None
```

Add a new event to the local cache (called by WebSocket callback).

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteEventsList.append"></a>

#### append

```python
def append(event: Event) -> None
```

Add a new event to the list (for compatibility with EventLog interface).

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteEventsList.create_default_callback"></a>

#### create\_default\_callback

```python
def create_default_callback() -> ConversationCallbackType
```

Create a default callback that adds events to this list.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState"></a>

## RemoteState Objects

```python
class RemoteState(ConversationStateProtocol)
```

A state-like interface for accessing remote conversation state.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.update_state_from_event"></a>

#### update\_state\_from\_event

```python
def update_state_from_event(event: ConversationStateUpdateEvent) -> None
```

Update cached state from a ConversationStateUpdateEvent.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.create_state_update_callback"></a>

#### create\_state\_update\_callback

```python
def create_state_update_callback() -> ConversationCallbackType
```

Create a callback that updates state from ConversationStateUpdateEvent.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.events"></a>

#### events

```python
@property
def events() -> RemoteEventsList
```

Access to the events list.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.id"></a>

#### id

```python
@property
def id() -> ConversationID
```

The conversation ID.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.agent_status"></a>

#### agent\_status

```python
@property
def agent_status() -> AgentExecutionStatus
```

The current agent execution status.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.agent_status"></a>

#### agent\_status

```python
@agent_status.setter
def agent_status(value: AgentExecutionStatus) -> None
```

Set agent status is No-OP for RemoteConversation.

__For remote conversations, agent status is managed server-side__

__This setter is provided for test compatibility but doesn't actually change remote state  # noqa: E501__


<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.confirmation_policy"></a>

#### confirmation\_policy

```python
@property
def confirmation_policy() -> ConfirmationPolicyBase
```

The confirmation policy.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.activated_knowledge_skills"></a>

#### activated\_knowledge\_skills

```python
@property
def activated_knowledge_skills() -> list[str]
```

List of activated knowledge skills.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.agent"></a>

#### agent

```python
@property
def agent()
```

The agent configuration (fetched from remote).

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.workspace"></a>

#### workspace

```python
@property
def workspace()
```

The working directory (fetched from remote).

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.persistence_dir"></a>

#### persistence\_dir

```python
@property
def persistence_dir()
```

The persistence directory (fetched from remote).

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.model_dump"></a>

#### model\_dump

```python
def model_dump(**_kwargs)
```

Get a dictionary representation of the remote state.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteState.model_dump_json"></a>

#### model\_dump\_json

```python
def model_dump_json(**kwargs)
```

Get a JSON representation of the remote state.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteConversation"></a>

## RemoteConversation Objects

```python
class RemoteConversation(BaseConversation)
```

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.__init__"></a>

#### \_\_init\_\_

```python
def __init__(agent: AgentBase,
             workspace: RemoteWorkspace,
             conversation_id: ConversationID | None = None,
             callbacks: list[ConversationCallbackType] | None = None,
             max_iteration_per_run: int = 500,
             stuck_detection: bool = True,
             visualize: bool = False,
             name_for_visualization: str | None = None,
             secrets: Mapping[str, SecretValue] | None = None,
             **_: object) -> None
```

Remote conversation proxy that talks to an agent server.

**Arguments**:

- `agent` - Agent configuration (will be sent to the server)
- `workspace` - The working directory for agent operations and tool execution.
- `conversation_id` - Optional existing conversation id to attach to
- `callbacks` - Optional callbacks to receive events (not yet streamed)
- `max_iteration_per_run` - Max iterations configured on server
- `stuck_detection` - Whether to enable stuck detection on server
- `visualize` - Whether to enable the default visualizer callback
- `name_for_visualization` - Optional name to prefix in panel titles to identify
  which agent/conversation is speaking.
- `secrets` - Optional secrets to initialize the conversation with

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.state"></a>

#### state

```python
@property
def state() -> RemoteState
```

Access to remote conversation state.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.conversation_stats"></a>

#### conversation\_stats

```python
@property
def conversation_stats() -> ConversationStats
```

Get conversation stats from remote server.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.stuck_detector"></a>

#### stuck\_detector

```python
@property
def stuck_detector()
```

Stuck detector for compatibility.
Not implemented for remote conversations.

<a id="openhands.sdk.conversation.impl.remote_conversation.RemoteConversation.generate_title"></a>

#### generate\_title

```python
def generate_title(llm: LLM | None = None, max_length: int = 50) -> str
```

Generate a title for the conversation based on the first user message.

**Arguments**:

- `llm` - Optional LLM to use for title generation. If provided, its usage_id
  will be sent to the server. If not provided, uses the agent's LLM.
- `max_length` - Maximum length of the generated title.
  

**Returns**:

  A generated title for the conversation.

<a id="openhands.sdk.conversation.impl"></a>

# openhands.sdk.conversation.impl

<a id="openhands.sdk.conversation.types"></a>

# openhands.sdk.conversation.types

<a id="openhands.sdk.conversation.types.ConversationID"></a>

#### ConversationID

Type alias for conversation IDs.

<a id="openhands.sdk.conversation.secret_registry"></a>

# openhands.sdk.conversation.secret\_registry

Secrets manager for handling sensitive data in conversations.

<a id="openhands.sdk.conversation.secret_registry.SecretRegistry"></a>

## SecretRegistry Objects

```python
class SecretRegistry(OpenHandsModel)
```

Manages secrets and injects them into bash commands when needed.

The secret registry stores a mapping of secret keys to SecretSources
that retrieve the actual secret values. When a bash command is about to be
executed, it scans the command for any secret keys and injects the corresponding
environment variables.

Secret sources will redact / encrypt their sensitive values as appropriate when
serializing, depending on the content of the context. If a context is present
and contains a 'cipher' object, this is used for encryption. If it contains a
boolean 'expose_secrets' flag set to True, secrets are dunped in plain text.
Otherwise secrets are redacted.

Additionally, it tracks the latest exported values to enable consistent masking
even when callable secrets fail on subsequent calls.

<a id="openhands.sdk.conversation.secret_registry.SecretRegistry.update_secrets"></a>

#### update\_secrets

```python
def update_secrets(secrets: Mapping[str, SecretValue]) -> None
```

Add or update secrets in the manager.

**Arguments**:

- `secrets` - Dictionary mapping secret keys to either string values
  or callable functions that return string values

<a id="openhands.sdk.conversation.secret_registry.SecretRegistry.find_secrets_in_text"></a>

#### find\_secrets\_in\_text

```python
def find_secrets_in_text(text: str) -> set[str]
```

Find all secret keys mentioned in the given text.

**Arguments**:

- `text` - The text to search for secret keys
  

**Returns**:

  Set of secret keys found in the text

<a id="openhands.sdk.conversation.secret_registry.SecretRegistry.get_secrets_as_env_vars"></a>

#### get\_secrets\_as\_env\_vars

```python
def get_secrets_as_env_vars(command: str) -> dict[str, str]
```

Get secrets that should be exported as environment variables for a command.

**Arguments**:

- `command` - The bash command to check for secret references
  

**Returns**:

  Dictionary of environment variables to export (key -> value)

<a id="openhands.sdk.conversation.secret_registry.SecretRegistry.mask_secrets_in_output"></a>

#### mask\_secrets\_in\_output

```python
def mask_secrets_in_output(text: str) -> str
```

Mask secret values in the given text.

This method uses both the current exported values and attempts to get
fresh values from callables to ensure comprehensive masking.

**Arguments**:

- `text` - The text to mask secrets in
  

**Returns**:

  Text with secret values replaced by <secret-hidden>

<a id="openhands.sdk.conversation.stuck_detector"></a>

# openhands.sdk.conversation.stuck\_detector

<a id="openhands.sdk.conversation.stuck_detector.StuckDetector"></a>

## StuckDetector Objects

```python
class StuckDetector()
```

Detects when an agent is stuck in repetitive or unproductive patterns.

This detector analyzes the conversation history to identify various stuck patterns:
1. Repeating action-observation cycles
2. Repeating action-error cycles
3. Agent monologue (repeated messages without user input)
4. Repeating alternating action-observation patterns
5. Context window errors indicating memory issues

<a id="openhands.sdk.conversation.stuck_detector.StuckDetector.is_stuck"></a>

#### is\_stuck

```python
def is_stuck() -> bool
```

Check if the agent is currently stuck.

<a id="openhands.sdk.conversation.base"></a>

# openhands.sdk.conversation.base

<a id="openhands.sdk.conversation.base.ConversationStateProtocol"></a>

## ConversationStateProtocol Objects

```python
class ConversationStateProtocol(Protocol)
```

Protocol defining the interface for conversation state objects.

<a id="openhands.sdk.conversation.base.ConversationStateProtocol.id"></a>

#### id

```python
@property
def id() -> ConversationID
```

The conversation ID.

<a id="openhands.sdk.conversation.base.ConversationStateProtocol.events"></a>

#### events

```python
@property
def events() -> EventsListBase
```

Access to the events list.

<a id="openhands.sdk.conversation.base.ConversationStateProtocol.agent_status"></a>

#### agent\_status

```python
@property
def agent_status() -> "AgentExecutionStatus"
```

The current agent execution status.

<a id="openhands.sdk.conversation.base.ConversationStateProtocol.confirmation_policy"></a>

#### confirmation\_policy

```python
@property
def confirmation_policy() -> ConfirmationPolicyBase
```

The confirmation policy.

<a id="openhands.sdk.conversation.base.ConversationStateProtocol.activated_knowledge_skills"></a>

#### activated\_knowledge\_skills

```python
@property
def activated_knowledge_skills() -> list[str]
```

List of activated knowledge skills.

<a id="openhands.sdk.conversation.base.ConversationStateProtocol.workspace"></a>

#### workspace

```python
@property
def workspace() -> BaseWorkspace
```

The workspace for agent operations and tool execution.

<a id="openhands.sdk.conversation.base.ConversationStateProtocol.persistence_dir"></a>

#### persistence\_dir

```python
@property
def persistence_dir() -> str | None
```

The persistence directory from the FileStore.

If None, it means the conversation is not being persisted.

<a id="openhands.sdk.conversation.base.ConversationStateProtocol.agent"></a>

#### agent

```python
@property
def agent() -> "AgentBase"
```

The agent running in the conversation.

<a id="openhands.sdk.conversation.base.BaseConversation"></a>

## BaseConversation Objects

```python
class BaseConversation(ABC)
```

<a id="openhands.sdk.conversation.base.BaseConversation.is_confirmation_mode_active"></a>

#### is\_confirmation\_mode\_active

```python
@property
def is_confirmation_mode_active() -> bool
```

Check if confirmation mode is active.

Returns True if BOTH conditions are met:
1. The agent has a security analyzer set (not None)
2. The confirmation policy is active

<a id="openhands.sdk.conversation.base.BaseConversation.generate_title"></a>

#### generate\_title

```python
@abstractmethod
def generate_title(llm: LLM | None = None, max_length: int = 50) -> str
```

Generate a title for the conversation based on the first user message.

**Arguments**:

- `llm` - Optional LLM to use for title generation. If not provided,
  uses the agent's LLM.
- `max_length` - Maximum length of the generated title.
  

**Returns**:

  A generated title for the conversation.
  

**Raises**:

- `ValueError` - If no user messages are found in the conversation.

<a id="openhands.sdk.conversation.base.BaseConversation.get_persistence_dir"></a>

#### get\_persistence\_dir

```python
@staticmethod
def get_persistence_dir(persistence_base_dir: str,
                        conversation_id: ConversationID) -> str
```

Get the persistence directory for the conversation.

<a id="openhands.sdk.conversation.base.BaseConversation.compose_callbacks"></a>

#### compose\_callbacks

```python
@staticmethod
def compose_callbacks(
        callbacks: Iterable[ConversationCallbackType]
) -> ConversationCallbackType
```

Compose multiple callbacks into a single callback function.

**Arguments**:

- `callbacks` - An iterable of callback functions
  

**Returns**:

  A single callback function that calls all provided callbacks

<a id="openhands.sdk.conversation.conversation_stats"></a>

# openhands.sdk.conversation.conversation\_stats

<a id="openhands.sdk.conversation.conversation_stats.ConversationStats"></a>

## ConversationStats Objects

```python
class ConversationStats(BaseModel)
```

Track per-LLM usage metrics observed during conversations.

<a id="openhands.sdk.conversation.state"></a>

# openhands.sdk.conversation.state

<a id="openhands.sdk.conversation.state.AgentExecutionStatus"></a>

## AgentExecutionStatus Objects

```python
class AgentExecutionStatus(str, Enum)
```

Enum representing the current execution state of the agent.

<a id="openhands.sdk.conversation.state.AgentExecutionStatus.IDLE"></a>

#### IDLE

Agent is ready to receive tasks

<a id="openhands.sdk.conversation.state.AgentExecutionStatus.RUNNING"></a>

#### RUNNING

Agent is actively processing

<a id="openhands.sdk.conversation.state.AgentExecutionStatus.PAUSED"></a>

#### PAUSED

Agent execution is paused by user

<a id="openhands.sdk.conversation.state.AgentExecutionStatus.FINISHED"></a>

#### FINISHED

Agent has completed the current task

<a id="openhands.sdk.conversation.state.AgentExecutionStatus.ERROR"></a>

#### ERROR

Agent encountered an error (optional for future use)

<a id="openhands.sdk.conversation.state.AgentExecutionStatus.STUCK"></a>

#### STUCK

Agent is stuck in a loop or unable to proceed

<a id="openhands.sdk.conversation.state.ConversationState"></a>

## ConversationState Objects

```python
class ConversationState(OpenHandsModel)
```

<a id="openhands.sdk.conversation.state.ConversationState.set_on_state_change"></a>

#### set\_on\_state\_change

```python
def set_on_state_change(callback: ConversationCallbackType | None) -> None
```

Set a callback to be called when state changes.

**Arguments**:

- `callback` - A function that takes an Event (ConversationStateUpdateEvent)
  or None to remove the callback

<a id="openhands.sdk.conversation.state.ConversationState.create"></a>

#### create

```python
@classmethod
def create(cls: type["ConversationState"],
           id: ConversationID,
           agent: AgentBase,
           workspace: BaseWorkspace,
           persistence_dir: str | None = None,
           max_iterations: int = 500,
           stuck_detection: bool = True) -> "ConversationState"
```

If base_state.json exists: resume (attach EventLog,
    reconcile agent, enforce id).
Else: create fresh (agent required), persist base, and return.

<a id="openhands.sdk.conversation.state.ConversationState.get_unmatched_actions"></a>

#### get\_unmatched\_actions

```python
@staticmethod
def get_unmatched_actions(events: Sequence[Event]) -> list[ActionEvent]
```

Find actions in the event history that don't have matching observations.

This method identifies ActionEvents that don't have corresponding
ObservationEvents or UserRejectObservations, which typically indicates
actions that are pending confirmation or execution.

**Arguments**:

- `events` - List of events to search through
  

**Returns**:

  List of ActionEvent objects that don't have corresponding observations,
  in chronological order

<a id="openhands.sdk.conversation.state.ConversationState.acquire"></a>

#### acquire

```python
def acquire(blocking: bool = True, timeout: float = -1) -> bool
```

Acquire the lock.

**Arguments**:

- `blocking` - If True, block until lock is acquired. If False, return
  immediately.
- `timeout` - Maximum time to wait for lock (ignored if blocking=False).
  -1 means wait indefinitely.
  

**Returns**:

  True if lock was acquired, False otherwise.

<a id="openhands.sdk.conversation.state.ConversationState.release"></a>

#### release

```python
def release() -> None
```

Release the lock.

**Raises**:

- `RuntimeError` - If the current thread doesn't own the lock.

<a id="openhands.sdk.conversation.state.ConversationState.__enter__"></a>

#### \_\_enter\_\_

```python
def __enter__() -> Self
```

Context manager entry.

<a id="openhands.sdk.conversation.state.ConversationState.__exit__"></a>

#### \_\_exit\_\_

```python
def __exit__(exc_type: Any, exc_val: Any, exc_tb: Any) -> None
```

Context manager exit.

<a id="openhands.sdk.conversation.state.ConversationState.locked"></a>

#### locked

```python
def locked() -> bool
```

Return True if the lock is currently held by any thread.

<a id="openhands.sdk.conversation.state.ConversationState.owned"></a>

#### owned

```python
def owned() -> bool
```

Return True if the lock is currently held by the calling thread.

<a id="openhands.sdk.conversation"></a>

# openhands.sdk.conversation

<a id="openhands.sdk.conversation.event_store"></a>

# openhands.sdk.conversation.event\_store

<a id="openhands.sdk.conversation.event_store.EventLog"></a>

## EventLog Objects

```python
class EventLog(EventsListBase)
```

<a id="openhands.sdk.conversation.event_store.EventLog.get_index"></a>

#### get\_index

```python
def get_index(event_id: EventID) -> int
```

Return the integer index for a given event_id.

<a id="openhands.sdk.conversation.event_store.EventLog.get_id"></a>

#### get\_id

```python
def get_id(idx: int) -> EventID
```

Return the event_id for a given index.

<a id="openhands.sdk.conversation.persistence_const"></a>

# openhands.sdk.conversation.persistence\_const

<a id="openhands.sdk.conversation.fifo_lock"></a>

# openhands.sdk.conversation.fifo\_lock

FIFO Lock implementation that guarantees first-in-first-out access ordering.

This provides fair lock access where threads acquire the lock in the exact order
they requested it, preventing starvation that can occur with standard RLock.

<a id="openhands.sdk.conversation.fifo_lock.FIFOLock"></a>

## FIFOLock Objects

```python
class FIFOLock()
```

A reentrant lock that guarantees FIFO (first-in-first-out) access ordering.

Unlike Python's standard RLock, this lock ensures that threads acquire
the lock in the exact order they requested it, providing fairness and
preventing lock starvation.

Features:
- Reentrant: Same thread can acquire multiple times
- FIFO ordering: Threads get lock in request order
- Context manager support: Use with 'with' statement
- Thread-safe: Safe for concurrent access

<a id="openhands.sdk.conversation.fifo_lock.FIFOLock.acquire"></a>

#### acquire

```python
def acquire(blocking: bool = True, timeout: float = -1) -> bool
```

Acquire the lock.

**Arguments**:

- `blocking` - If True, block until lock is acquired. If False, return
  immediately.
- `timeout` - Maximum time to wait for lock (ignored if blocking=False).
  -1 means wait indefinitely.
  

**Returns**:

  True if lock was acquired, False otherwise.

<a id="openhands.sdk.conversation.fifo_lock.FIFOLock.release"></a>

#### release

```python
def release() -> None
```

Release the lock.

**Raises**:

- `RuntimeError` - If the current thread doesn't own the lock.

<a id="openhands.sdk.conversation.fifo_lock.FIFOLock.__enter__"></a>

#### \_\_enter\_\_

```python
def __enter__() -> Self
```

Context manager entry.

<a id="openhands.sdk.conversation.fifo_lock.FIFOLock.__exit__"></a>

#### \_\_exit\_\_

```python
def __exit__(exc_type: Any, exc_val: Any, exc_tb: Any) -> None
```

Context manager exit.

<a id="openhands.sdk.conversation.fifo_lock.FIFOLock.locked"></a>

#### locked

```python
def locked() -> bool
```

Return True if the lock is currently held by any thread.

<a id="openhands.sdk.conversation.fifo_lock.FIFOLock.owned"></a>

#### owned

```python
def owned() -> bool
```

Return True if the lock is currently held by the calling thread.

<a id="openhands.sdk.conversation.conversation"></a>

# openhands.sdk.conversation.conversation

<a id="openhands.sdk.conversation.conversation.Conversation"></a>

## Conversation Objects

```python
class Conversation()
```

Factory entrypoint that returns a LocalConversation or RemoteConversation.

Usage:
    - Conversation(agent=...) -> LocalConversation
    - Conversation(agent=..., host="http://...") -> RemoteConversation

<a id="openhands.sdk.conversation.secret_source"></a>

# openhands.sdk.conversation.secret\_source

<a id="openhands.sdk.conversation.secret_source.SecretSource"></a>

## SecretSource Objects

```python
class SecretSource(DiscriminatedUnionMixin, ABC)
```

Source for a named secret which may be obtained dynamically

<a id="openhands.sdk.conversation.secret_source.SecretSource.get_value"></a>

#### get\_value

```python
@abstractmethod
def get_value() -> str | None
```

Get the value of a secret in plain text

<a id="openhands.sdk.conversation.secret_source.StaticSecret"></a>

## StaticSecret Objects

```python
class StaticSecret(SecretSource)
```

A secret stored locally

<a id="openhands.sdk.conversation.secret_source.LookupSecret"></a>

## LookupSecret Objects

```python
class LookupSecret(SecretSource)
```

A secret looked up from some external url

<a id="openhands.sdk.conversation.exceptions"></a>

# openhands.sdk.conversation.exceptions

<a id="openhands.sdk.conversation.exceptions.ConversationRunError"></a>

## ConversationRunError Objects

```python
class ConversationRunError(RuntimeError)
```

Raised when a conversation run fails.

Carries the conversation_id to make resuming/debugging easier while
preserving the original exception via exception chaining.

<a id="openhands.sdk.conversation.title_utils"></a>

# openhands.sdk.conversation.title\_utils

Utility functions for generating conversation titles.

<a id="openhands.sdk.conversation.title_utils.extract_first_user_message"></a>

#### extract\_first\_user\_message

```python
def extract_first_user_message(events: Sequence[Event]) -> str | None
```

Extract the first user message from conversation events.

**Arguments**:

- `events` - List of conversation events.
  

**Returns**:

  The first user message text, or None if no user message is found.

<a id="openhands.sdk.conversation.title_utils.generate_title_with_llm"></a>

#### generate\_title\_with\_llm

```python
def generate_title_with_llm(message: str,
                            llm: LLM,
                            max_length: int = 50) -> str | None
```

Generate a conversation title using LLM.

**Arguments**:

- `message` - The first user message to generate title from.
- `llm` - The LLM to use for title generation.
- `max_length` - Maximum length of the generated title.
  

**Returns**:

  Generated title, or None if LLM fails or returns empty response.

<a id="openhands.sdk.conversation.title_utils.generate_fallback_title"></a>

#### generate\_fallback\_title

```python
def generate_fallback_title(message: str, max_length: int = 50) -> str
```

Generate a fallback title by truncating the first user message.

**Arguments**:

- `message` - The first user message.
- `max_length` - Maximum length of the title.
  

**Returns**:

  A truncated title.

<a id="openhands.sdk.conversation.title_utils.generate_conversation_title"></a>

#### generate\_conversation\_title

```python
def generate_conversation_title(events: Sequence[Event],
                                llm: LLM | None = None,
                                max_length: int = 50) -> str
```

Generate a title for a conversation based on the first user message.

This is the main utility function that orchestrates the title generation process:
1. Extract the first user message from events
2. Try to generate title using LLM
3. Fall back to simple truncation if LLM fails

**Arguments**:

- `events` - List of conversation events.
- `llm` - Optional LLM to use for title generation.
- `max_length` - Maximum length of the generated title.
  

**Returns**:

  A generated title for the conversation.
  

**Raises**:

- `ValueError` - If no user messages are found in the conversation events.

<a id="openhands.sdk.conversation.events_list_base"></a>

# openhands.sdk.conversation.events\_list\_base

<a id="openhands.sdk.conversation.events_list_base.EventsListBase"></a>

## EventsListBase Objects

```python
class EventsListBase(Sequence[Event], ABC)
```

Abstract base class for event lists that can be appended to.

This provides a common interface for both local EventLog and remote
RemoteEventsList implementations, avoiding circular imports in protocols.

<a id="openhands.sdk.conversation.events_list_base.EventsListBase.append"></a>

#### append

```python
@abstractmethod
def append(event: Event) -> None
```

Add a new event to the list.

<a id="openhands.sdk.conversation.visualizer"></a>

# openhands.sdk.conversation.visualizer

<a id="openhands.sdk.conversation.visualizer.ConversationVisualizer"></a>

## ConversationVisualizer Objects

```python
class ConversationVisualizer()
```

Handles visualization of conversation events with Rich formatting.

Provides Rich-formatted output with panels and complete content display.

<a id="openhands.sdk.conversation.visualizer.ConversationVisualizer.__init__"></a>

#### \_\_init\_\_

```python
def __init__(highlight_regex: dict[str, str] | None = None,
             skip_user_messages: bool = False,
             conversation_stats: "ConversationStats | None" = None,
             name_for_visualization: str | None = None)
```

Initialize the visualizer.

**Arguments**:

- `highlight_regex` - Dictionary mapping regex patterns to Rich color styles
  for highlighting keywords in the visualizer.
  For example: {"Reasoning:": "bold blue",
- `"Thought:"` - "bold green"}
- `skip_user_messages` - If True, skip displaying user messages. Useful for
  scenarios where user input is not relevant to show.
- `conversation_stats` - ConversationStats object to display metrics information.
- `name_for_visualization` - Optional name to prefix in panel titles to identify
  which agent/conversation is speaking.

<a id="openhands.sdk.conversation.visualizer.ConversationVisualizer.on_event"></a>

#### on\_event

```python
def on_event(event: Event) -> None
```

Main event handler that displays events with Rich formatting.

<a id="openhands.sdk.conversation.visualizer.create_default_visualizer"></a>

#### create\_default\_visualizer

```python
def create_default_visualizer(
        highlight_regex: dict[str, str] | None = None,
        conversation_stats: "ConversationStats | None" = None,
        name_for_visualization: str | None = None,
        **kwargs) -> ConversationVisualizer
```

Create a default conversation visualizer instance.

**Arguments**:

- `highlight_regex` - Dictionary mapping regex patterns to Rich color styles
  for highlighting keywords in the visualizer.
  For example: {"Reasoning:": "bold blue",
- `"Thought:"` - "bold green"}
- `conversation_stats` - ConversationStats object to display metrics information.
- `name_for_visualization` - Optional name to prefix in panel titles to identify
  which agent/conversation is speaking.

<a id="openhands.sdk.conversation.serialization_diff"></a>

# openhands.sdk.conversation.serialization\_diff

<a id="openhands.sdk.workspace.base"></a>

# openhands.sdk.workspace.base

<a id="openhands.sdk.workspace.base.BaseWorkspace"></a>

## BaseWorkspace Objects

```python
class BaseWorkspace(DiscriminatedUnionMixin, ABC)
```

Abstract base mixin for workspace.

All workspace implementations support the context manager protocol,
allowing safe resource management:

    with workspace:
        workspace.execute_command("echo 'hello'")

<a id="openhands.sdk.workspace.base.BaseWorkspace.__enter__"></a>

#### \_\_enter\_\_

```python
def __enter__() -> "BaseWorkspace"
```

Enter the workspace context.

**Returns**:

  Self for use in with statements

<a id="openhands.sdk.workspace.base.BaseWorkspace.__exit__"></a>

#### \_\_exit\_\_

```python
def __exit__(exc_type: Any, exc_val: Any, exc_tb: Any) -> None
```

Exit the workspace context and cleanup resources.

Default implementation performs no cleanup. Subclasses should override
to add cleanup logic (e.g., stopping containers, closing connections).

**Arguments**:

- `exc_type` - Exception type if an exception occurred
- `exc_val` - Exception value if an exception occurred
- `exc_tb` - Exception traceback if an exception occurred

<a id="openhands.sdk.workspace.base.BaseWorkspace.execute_command"></a>

#### execute\_command

```python
@abstractmethod
def execute_command(command: str,
                    cwd: str | Path | None = None,
                    timeout: float = 30.0) -> CommandResult
```

Execute a bash command on the system.

**Arguments**:

- `command` - The bash command to execute
- `cwd` - Working directory for the command (optional)
- `timeout` - Timeout in seconds (defaults to 30.0)
  

**Returns**:

- `CommandResult` - Result containing stdout, stderr, exit_code, and other
  metadata
  

**Raises**:

- `Exception` - If command execution fails

<a id="openhands.sdk.workspace.base.BaseWorkspace.file_upload"></a>

#### file\_upload

```python
@abstractmethod
def file_upload(source_path: str | Path,
                destination_path: str | Path) -> FileOperationResult
```

Upload a file to the system.

**Arguments**:

- `source_path` - Path to the source file
- `destination_path` - Path where the file should be uploaded
  

**Returns**:

- `FileOperationResult` - Result containing success status and metadata
  

**Raises**:

- `Exception` - If file upload fails

<a id="openhands.sdk.workspace.base.BaseWorkspace.file_download"></a>

#### file\_download

```python
@abstractmethod
def file_download(source_path: str | Path,
                  destination_path: str | Path) -> FileOperationResult
```

Download a file from the system.

**Arguments**:

- `source_path` - Path to the source file on the system
- `destination_path` - Path where the file should be downloaded
  

**Returns**:

- `FileOperationResult` - Result containing success status and metadata
  

**Raises**:

- `Exception` - If file download fails

<a id="openhands.sdk.workspace.base.BaseWorkspace.git_changes"></a>

#### git\_changes

```python
@abstractmethod
def git_changes(path: str | Path) -> list[GitChange]
```

Get the git changes for the repository at the path given.

**Arguments**:

- `path` - Path to the git repository
  

**Returns**:

- `list[GitChange]` - List of changes
  

**Raises**:

- `Exception` - If path is not a git repository or getting changes failed

<a id="openhands.sdk.workspace.base.BaseWorkspace.git_diff"></a>

#### git\_diff

```python
@abstractmethod
def git_diff(path: str | Path) -> GitDiff
```

Get the git diff for the file at the path given.

**Arguments**:

- `path` - Path to the file
  

**Returns**:

- `GitDiff` - Git diff
  

**Raises**:

- `Exception` - If path is not a git repository or getting diff failed

<a id="openhands.sdk.workspace.models"></a>

# openhands.sdk.workspace.models

Pydantic models for workspace operation results.

<a id="openhands.sdk.workspace.models.CommandResult"></a>

## CommandResult Objects

```python
class CommandResult(BaseModel)
```

Result of executing a command in the workspace.

<a id="openhands.sdk.workspace.models.FileOperationResult"></a>

## FileOperationResult Objects

```python
class FileOperationResult(BaseModel)
```

Result of a file upload or download operation.

<a id="openhands.sdk.workspace"></a>

# openhands.sdk.workspace

<a id="openhands.sdk.workspace.local"></a>

# openhands.sdk.workspace.local

<a id="openhands.sdk.workspace.local.LocalWorkspace"></a>

## LocalWorkspace Objects

```python
class LocalWorkspace(BaseWorkspace)
```

Mixin providing local workspace operations.

<a id="openhands.sdk.workspace.local.LocalWorkspace.execute_command"></a>

#### execute\_command

```python
def execute_command(command: str,
                    cwd: str | Path | None = None,
                    timeout: float = 30.0) -> CommandResult
```

Execute a bash command locally.

Uses the shared shell execution utility to run commands with proper
timeout handling, output streaming, and error management.

**Arguments**:

- `command` - The bash command to execute
- `cwd` - Working directory (optional)
- `timeout` - Timeout in seconds
  

**Returns**:

- `CommandResult` - Result with stdout, stderr, exit_code, command, and
  timeout_occurred

<a id="openhands.sdk.workspace.local.LocalWorkspace.file_upload"></a>

#### file\_upload

```python
def file_upload(source_path: str | Path,
                destination_path: str | Path) -> FileOperationResult
```

Upload (copy) a file locally.

For local systems, file upload is implemented as a file copy operation
using shutil.copy2 to preserve metadata.

**Arguments**:

- `source_path` - Path to the source file
- `destination_path` - Path where the file should be copied
  

**Returns**:

- `FileOperationResult` - Result with success status and file information

<a id="openhands.sdk.workspace.local.LocalWorkspace.file_download"></a>

#### file\_download

```python
def file_download(source_path: str | Path,
                  destination_path: str | Path) -> FileOperationResult
```

Download (copy) a file locally.

For local systems, file download is implemented as a file copy operation
using shutil.copy2 to preserve metadata.

**Arguments**:

- `source_path` - Path to the source file
- `destination_path` - Path where the file should be copied
  

**Returns**:

- `FileOperationResult` - Result with success status and file information

<a id="openhands.sdk.workspace.local.LocalWorkspace.git_changes"></a>

#### git\_changes

```python
def git_changes(path: str | Path) -> list[GitChange]
```

Get the git changes for the repository at the path given.

**Arguments**:

- `path` - Path to the git repository
  

**Returns**:

- `list[GitChange]` - List of changes
  

**Raises**:

- `Exception` - If path is not a git repository or getting changes failed

<a id="openhands.sdk.workspace.local.LocalWorkspace.git_diff"></a>

#### git\_diff

```python
def git_diff(path: str | Path) -> GitDiff
```

Get the git diff for the file at the path given.

**Arguments**:

- `path` - Path to the file
  

**Returns**:

- `GitDiff` - Git diff
  

**Raises**:

- `Exception` - If path is not a git repository or getting diff failed

<a id="openhands.sdk.workspace.workspace"></a>

# openhands.sdk.workspace.workspace

<a id="openhands.sdk.workspace.workspace.Workspace"></a>

## Workspace Objects

```python
class Workspace()
```

Factory entrypoint that returns a LocalWorkspace or RemoteWorkspace.

Usage:
    - Workspace(working_dir=...) -> LocalWorkspace
    - Workspace(working_dir=..., host="http://...") -> RemoteWorkspace

<a id="openhands.sdk.workspace.remote.remote_workspace_mixin"></a>

# openhands.sdk.workspace.remote.remote\_workspace\_mixin

<a id="openhands.sdk.workspace.remote.remote_workspace_mixin.RemoteWorkspaceMixin"></a>

## RemoteWorkspaceMixin Objects

```python
class RemoteWorkspaceMixin(BaseModel)
```

Mixin providing remote workspace operations.
This allows the same code to be used for sync and async.

<a id="openhands.sdk.workspace.remote.base"></a>

# openhands.sdk.workspace.remote.base

<a id="openhands.sdk.workspace.remote.base.RemoteWorkspace"></a>

## RemoteWorkspace Objects

```python
class RemoteWorkspace(RemoteWorkspaceMixin, BaseWorkspace)
```

Remote Workspace Implementation.

<a id="openhands.sdk.workspace.remote.base.RemoteWorkspace.execute_command"></a>

#### execute\_command

```python
def execute_command(command: str,
                    cwd: str | Path | None = None,
                    timeout: float = 30.0) -> CommandResult
```

Execute a bash command on the remote system.

This method starts a bash command via the remote agent server API,
then polls for the output until the command completes.

**Arguments**:

- `command` - The bash command to execute
- `cwd` - Working directory (optional)
- `timeout` - Timeout in seconds
  

**Returns**:

- `CommandResult` - Result with stdout, stderr, exit_code, and other metadata

<a id="openhands.sdk.workspace.remote.base.RemoteWorkspace.file_upload"></a>

#### file\_upload

```python
def file_upload(source_path: str | Path,
                destination_path: str | Path) -> FileOperationResult
```

Upload a file to the remote system.

Reads the local file and sends it to the remote system via HTTP API.

**Arguments**:

- `source_path` - Path to the local source file
- `destination_path` - Path where the file should be uploaded on remote system
  

**Returns**:

- `FileOperationResult` - Result with success status and metadata

<a id="openhands.sdk.workspace.remote.base.RemoteWorkspace.file_download"></a>

#### file\_download

```python
def file_download(source_path: str | Path,
                  destination_path: str | Path) -> FileOperationResult
```

Download a file from the remote system.

Requests the file from the remote system via HTTP API and saves it locally.

**Arguments**:

- `source_path` - Path to the source file on remote system
- `destination_path` - Path where the file should be saved locally
  

**Returns**:

- `FileOperationResult` - Result with success status and metadata

<a id="openhands.sdk.workspace.remote.base.RemoteWorkspace.git_changes"></a>

#### git\_changes

```python
def git_changes(path: str | Path) -> list[GitChange]
```

Get the git changes for the repository at the path given.

**Arguments**:

- `path` - Path to the git repository
  

**Returns**:

- `list[GitChange]` - List of changes
  

**Raises**:

- `Exception` - If path is not a git repository or getting changes failed

<a id="openhands.sdk.workspace.remote.base.RemoteWorkspace.git_diff"></a>

#### git\_diff

```python
def git_diff(path: str | Path) -> GitDiff
```

Get the git diff for the file at the path given.

**Arguments**:

- `path` - Path to the file
  

**Returns**:

- `GitDiff` - Git diff
  

**Raises**:

- `Exception` - If path is not a git repository or getting diff failed

<a id="openhands.sdk.workspace.remote"></a>

# openhands.sdk.workspace.remote

Remote workspace implementations.

<a id="openhands.sdk.workspace.remote.async_remote_workspace"></a>

# openhands.sdk.workspace.remote.async\_remote\_workspace

<a id="openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace"></a>

## AsyncRemoteWorkspace Objects

```python
class AsyncRemoteWorkspace(RemoteWorkspaceMixin)
```

Async Remote Workspace Implementation.

<a id="openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.execute_command"></a>

#### execute\_command

```python
async def execute_command(command: str,
                          cwd: str | Path | None = None,
                          timeout: float = 30.0) -> CommandResult
```

Execute a bash command on the remote system.

This method starts a bash command via the remote agent server API,
then polls for the output until the command completes.

**Arguments**:

- `command` - The bash command to execute
- `cwd` - Working directory (optional)
- `timeout` - Timeout in seconds
  

**Returns**:

- `CommandResult` - Result with stdout, stderr, exit_code, and other metadata

<a id="openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.file_upload"></a>

#### file\_upload

```python
async def file_upload(source_path: str | Path,
                      destination_path: str | Path) -> FileOperationResult
```

Upload a file to the remote system.

Reads the local file and sends it to the remote system via HTTP API.

**Arguments**:

- `source_path` - Path to the local source file
- `destination_path` - Path where the file should be uploaded on remote system
  

**Returns**:

- `FileOperationResult` - Result with success status and metadata

<a id="openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.file_download"></a>

#### file\_download

```python
async def file_download(source_path: str | Path,
                        destination_path: str | Path) -> FileOperationResult
```

Download a file from the remote system.

Requests the file from the remote system via HTTP API and saves it locally.

**Arguments**:

- `source_path` - Path to the source file on remote system
- `destination_path` - Path where the file should be saved locally
  

**Returns**:

- `FileOperationResult` - Result with success status and metadata

<a id="openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.git_changes"></a>

#### git\_changes

```python
async def git_changes(path: str | Path) -> list[GitChange]
```

Get the git changes for the repository at the path given.

**Arguments**:

- `path` - Path to the git repository
  

**Returns**:

- `list[GitChange]` - List of changes
  

**Raises**:

- `Exception` - If path is not a git repository or getting changes failed

<a id="openhands.sdk.workspace.remote.async_remote_workspace.AsyncRemoteWorkspace.git_diff"></a>

#### git\_diff

```python
async def git_diff(path: str | Path) -> GitDiff
```

Get the git diff for the file at the path given.

**Arguments**:

- `path` - Path to the file
  

**Returns**:

- `GitDiff` - Git diff
  

**Raises**:

- `Exception` - If path is not a git repository or getting diff failed

<a id="openhands.sdk.utils.visualize"></a>

# openhands.sdk.utils.visualize

<a id="openhands.sdk.utils.visualize.display_dict"></a>

#### display\_dict

```python
def display_dict(d) -> Text
```

Create a Rich Text representation of a dictionary.

<a id="openhands.sdk.utils.models"></a>

# openhands.sdk.utils.models

<a id="openhands.sdk.utils.models.rebuild_all"></a>

#### rebuild\_all

```python
def rebuild_all()
```

Rebuild all polymorphic classes.

<a id="openhands.sdk.utils.models.kind_of"></a>

#### kind\_of

```python
def kind_of(obj) -> str
```

Get the string value for the kind tag

<a id="openhands.sdk.utils.models.get_known_concrete_subclasses"></a>

#### get\_known\_concrete\_subclasses

```python
def get_known_concrete_subclasses(cls) -> list[type]
```

Recursively returns all concrete subclasses in a stable order,
without deduping classes that share the same (module, name).

<a id="openhands.sdk.utils.models.OpenHandsModel"></a>

## OpenHandsModel Objects

```python
class OpenHandsModel(BaseModel)
```

Tags a class where the which may be a discriminated union or contain fields
which contain a discriminated union. The first time an instance is initialized,
the schema is loaded, or a model is validated after a subclass is defined we
regenerate all the polymorphic mappings.

<a id="openhands.sdk.utils.models.OpenHandsModel.__init_subclass__"></a>

#### \_\_init\_subclass\_\_

```python
def __init_subclass__(cls, **kwargs)
```

When a new subclass is defined, mark that we will need
to rebuild everything

<a id="openhands.sdk.utils.models.DiscriminatedUnionMixin"></a>

## DiscriminatedUnionMixin Objects

```python
class DiscriminatedUnionMixin(OpenHandsModel, ABC)
```

A Base class for members of tagged unions discriminated by the class name.

This class provides automatic subclass registration and discriminated union
functionality. Each subclass is automatically registered when defined and
can be used for polymorphic serialization/deserialization.

Child classes will automatically have a type field defined, which is used as a
discriminator for union types.

<a id="openhands.sdk.utils.models.DiscriminatedUnionMixin.kind"></a>

#### kind

We dynamically update on a per class basis

<a id="openhands.sdk.utils.models.DiscriminatedUnionMixin.__get_pydantic_core_schema__"></a>

#### \_\_get\_pydantic\_core\_schema\_\_

```python
@classmethod
def __get_pydantic_core_schema__(cls, source_type, handler)
```

Generate discriminated union schema for TypeAdapter compatibility.

<a id="openhands.sdk.utils.models.DiscriminatedUnionMixin.__get_pydantic_json_schema__"></a>

#### \_\_get\_pydantic\_json\_schema\_\_

```python
@classmethod
def __get_pydantic_json_schema__(cls, core_schema, handler)
```

Add discriminator to OpenAPI schema and ensure component generation.

<a id="openhands.sdk.utils.models.DiscriminatedUnionMixin.get_serializable_type"></a>

#### get\_serializable\_type

```python
@classmethod
def get_serializable_type(cls) -> type
```

Custom method to get the union of all currently loaded
non absract subclasses

<a id="openhands.sdk.utils.truncate"></a>

# openhands.sdk.utils.truncate

Utility functions for truncating text content.

<a id="openhands.sdk.utils.truncate.maybe_truncate"></a>

#### maybe\_truncate

```python
def maybe_truncate(content: str,
                   truncate_after: int | None = None,
                   truncate_notice: str = DEFAULT_TRUNCATE_NOTICE) -> str
```

Truncate the middle of content if it exceeds the specified length.

Keeps the head and tail of the content to preserve context at both ends.

**Arguments**:

- `content` - The text content to potentially truncate
- `truncate_after` - Maximum length before truncation. If None, no truncation occurs
- `truncate_notice` - Notice to insert in the middle when content is truncated
  

**Returns**:

  Original content if under limit, or truncated content with head and tail
  preserved

<a id="openhands.sdk.utils"></a>

# openhands.sdk.utils

Utility functions for the OpenHands SDK.

<a id="openhands.sdk.utils.async_executor"></a>

# openhands.sdk.utils.async\_executor

Reusable async-to-sync execution utility.

<a id="openhands.sdk.utils.async_executor.AsyncExecutor"></a>

## AsyncExecutor Objects

```python
class AsyncExecutor()
```

Manages a background event loop for executing async code from sync contexts.

This provides a robust async-to-sync bridge with proper resource management,
timeout support, and thread safety.

<a id="openhands.sdk.utils.async_executor.AsyncExecutor.run_async"></a>

#### run\_async

```python
def run_async(awaitable_or_fn: Callable[..., Any] | Any,
              *args,
              timeout: float = 300.0,
              **kwargs) -> Any
```

Run a coroutine or async function on the background loop from sync code.

**Arguments**:

- `awaitable_or_fn` - Coroutine or async function to execute
- `*args` - Arguments to pass to the function
- `timeout` - Timeout in seconds (default: 300)
- `**kwargs` - Keyword arguments to pass to the function
  

**Returns**:

  The result of the async operation
  

**Raises**:

- `TypeError` - If awaitable_or_fn is not a coroutine or async function
- `asyncio.TimeoutError` - If the operation times out

<a id="openhands.sdk.utils.async_executor.AsyncExecutor.close"></a>

#### close

```python
def close()
```

Close the async executor and cleanup resources.

<a id="openhands.sdk.utils.async_executor.AsyncExecutor.__del__"></a>

#### \_\_del\_\_

```python
def __del__()
```

Cleanup on deletion.

<a id="openhands.sdk.utils.cipher"></a>

# openhands.sdk.utils.cipher

Cipher utility for preventing accidental secret disclosure in serialized data

SECURITY WARNINGS:
- The secret key is a string for ease of use but should contain at least 256
  bits of entropy

<a id="openhands.sdk.utils.cipher.Cipher"></a>

## Cipher Objects

```python
class Cipher()
```

Simple encryption utility for preventing accidental secret disclosure.

<a id="openhands.sdk.utils.cipher.Cipher.decrypt"></a>

#### decrypt

```python
def decrypt(secret: str | None) -> SecretStr | None
```

Decrypt a secret value, returning None if decryption fails.

This handles cases where existing conversations were serialized with different
encryption keys or contain invalid encrypted data. A warning is logged when
decryption fails and a None is returned. This mimics the case where
no cipher was defined so secrets where redacted.

<a id="openhands.sdk.utils.pydantic_secrets"></a>

# openhands.sdk.utils.pydantic\_secrets

<a id="openhands.sdk.utils.pydantic_secrets.serialize_secret"></a>

#### serialize\_secret

```python
def serialize_secret(v: SecretStr | None, info)
```

Serialize secret fields with encryption or redaction.

- If a cipher is provided in context, encrypts the secret value
- If expose_secrets flag is True in context, exposes the actual value
- Otherwise, lets Pydantic handle default masking (redaction)
- This prevents accidental secret disclosure

<a id="openhands.sdk.utils.pydantic_secrets.validate_secret"></a>

#### validate\_secret

```python
def validate_secret(v: SecretStr | None, info)
```

Deserialize secret fields, handling encryption and empty values.

- Empty secrets are converted to None
- If a cipher is provided in context, attempts to decrypt the value
- If decryption fails, the cipher returns None and a warning is logged
- This gracefully handles conversations encrypted with different keys or were redacted

<a id="openhands.sdk.utils.command"></a>

# openhands.sdk.utils.command

<a id="openhands.sdk.utils.async_utils"></a>

# openhands.sdk.utils.async\_utils

Async utilities for OpenHands SDK.

This module provides utilities for working with async callbacks in the context
of synchronous conversation handling.

<a id="openhands.sdk.utils.async_utils.AsyncCallbackWrapper"></a>

## AsyncCallbackWrapper Objects

```python
class AsyncCallbackWrapper()
```

Wrapper that executes async callbacks in a different thread's event loop.

This class implements the ConversationCallbackType interface (synchronous)
but internally executes an async callback in an event loop running in a
different thread. This allows async callbacks to be used in synchronous
conversation contexts.

<a id="openhands.sdk.utils.json"></a>

# openhands.sdk.utils.json

<a id="openhands.sdk.utils.json.OpenHandsJSONEncoder"></a>

## OpenHandsJSONEncoder Objects

```python
class OpenHandsJSONEncoder(json.JSONEncoder)
```

Custom JSON encoder that handles datetime and other OH objects

<a id="openhands.sdk.utils.json.dumps"></a>

#### dumps

```python
def dumps(obj, **kwargs)
```

Serialize an object to str format

<a id="openhands.sdk.utils.json.loads"></a>

#### loads

```python
def loads(json_str, **kwargs)
```

Create a JSON object from str

<a id="openhands.sdk.utils.pydantic_diff"></a>

# openhands.sdk.utils.pydantic\_diff

<a id="openhands.sdk.logger"></a>

# openhands.sdk.logger

<a id="openhands.sdk.logger.logger"></a>

# openhands.sdk.logger.logger

Minimal logger setup that encourages per-module loggers,
with Rich for humans and JSON for machines.

Usage:
    from openhands.sdk.logger import get_logger
    logger = get_logger(__name__)
    logger.info("Hello from this module!")

<a id="openhands.sdk.logger.logger.disable_logger"></a>

#### disable\_logger

```python
def disable_logger(name: str, level: int = logging.CRITICAL) -> None
```

Disable or quiet down a specific logger by name.

<a id="openhands.sdk.logger.logger.setup_logging"></a>

#### setup\_logging

```python
def setup_logging(level: int | None = None,
                  log_to_file: bool | None = None,
                  log_dir: str | None = None,
                  fmt: str | None = None,
                  when: str | None = None,
                  backup_count: int | None = None) -> None
```

Configure the root logger. All child loggers inherit this setup.

<a id="openhands.sdk.logger.logger.get_logger"></a>

#### get\_logger

```python
def get_logger(name: str) -> logging.Logger
```

Return a logger for the given module name.

<a id="openhands.sdk.logger.rolling"></a>

# openhands.sdk.logger.rolling

<a id="openhands.sdk.logger.rolling.rolling_log_view"></a>

#### rolling\_log\_view

```python
@contextmanager
def rolling_log_view(logger: logging.Logger,
                     max_lines: int = 60,
                     level: int = logging.INFO,
                     propagate: bool = False,
                     header: str | None = None,
                     footer: str | None = None,
                     *,
                     json_flush_level: int
                     | None = None)
```

Temporarily attach a rolling view handler that renders the last N log lines.

- Local TTY & not CI & not JSON: pretty, live-updating view (Rich.Live)
- CI / non-TTY: plain line-by-line (no terminal control)
- JSON mode: buffer only; on exit emit ONE large log record with the full snapshot.

<a id="openhands.sdk.llm.mixins.fn_call_converter"></a>

# openhands.sdk.llm.mixins.fn\_call\_converter

Convert function calling messages to non-function calling messages and vice versa.

This will inject prompts so that models that doesn't support function calling
can still be used with function calling agents.

We follow format from: https://docs.litellm.ai/docs/completion/function_call

<a id="openhands.sdk.llm.mixins.fn_call_converter.system_message_suffix_TEMPLATE"></a>

#### system\_message\_suffix\_TEMPLATE

noqa: E501

<a id="openhands.sdk.llm.mixins.fn_call_converter.get_example_for_tools"></a>

#### get\_example\_for\_tools

```python
def get_example_for_tools(tools: list[ChatCompletionToolParam]) -> str
```

Generate an in-context learning example based on available tools.

<a id="openhands.sdk.llm.mixins.fn_call_converter.IN_CONTEXT_LEARNING_EXAMPLE_SUFFIX"></a>

#### IN\_CONTEXT\_LEARNING\_EXAMPLE\_SUFFIX

noqa: E501

<a id="openhands.sdk.llm.mixins.fn_call_converter.convert_tool_call_to_string"></a>

#### convert\_tool\_call\_to\_string

```python
def convert_tool_call_to_string(tool_call: dict) -> str
```

Convert tool call to content in string format.

<a id="openhands.sdk.llm.mixins.fn_call_converter.convert_fncall_messages_to_non_fncall_messages"></a>

#### convert\_fncall\_messages\_to\_non\_fncall\_messages

```python
def convert_fncall_messages_to_non_fncall_messages(
        messages: list[dict],
        tools: list[ChatCompletionToolParam],
        add_in_context_learning_example: bool = True) -> list[dict]
```

Convert function calling messages to non-function calling messages.

<a id="openhands.sdk.llm.mixins.fn_call_converter.convert_non_fncall_messages_to_fncall_messages"></a>

#### convert\_non\_fncall\_messages\_to\_fncall\_messages

```python
def convert_non_fncall_messages_to_fncall_messages(
        messages: list[dict],
        tools: list[ChatCompletionToolParam]) -> list[dict]
```

Convert non-function calling messages back to function calling messages.

<a id="openhands.sdk.llm.mixins.fn_call_converter.convert_from_multiple_tool_calls_to_single_tool_call_messages"></a>

#### convert\_from\_multiple\_tool\_calls\_to\_single\_tool\_call\_messages

```python
def convert_from_multiple_tool_calls_to_single_tool_call_messages(
        messages: list[dict],
        ignore_final_tool_result: bool = False) -> list[dict]
```

Break one message with multiple tool calls into multiple messages.

<a id="openhands.sdk.llm.mixins.non_native_fc"></a>

# openhands.sdk.llm.mixins.non\_native\_fc

<a id="openhands.sdk.llm.mixins.non_native_fc.NonNativeToolCallingMixin"></a>

## NonNativeToolCallingMixin Objects

```python
class NonNativeToolCallingMixin()
```

Mixin providing prompt-mocked tool-calling support when native FC is off.

Host requirements:
- self.model: str
- self.disable_stop_word: bool | None
- self.native_tool_calling -> bool

<a id="openhands.sdk.llm.mixins.non_native_fc.NonNativeToolCallingMixin.pre_request_prompt_mock"></a>

#### pre\_request\_prompt\_mock

```python
def pre_request_prompt_mock(messages: list[dict],
                            tools: list[ChatCompletionToolParam],
                            kwargs: dict) -> tuple[list[dict], dict]
```

Convert to non-fncall prompting when native tool-calling is off.

<a id="openhands.sdk.llm.llm_response"></a>

# openhands.sdk.llm.llm\_response

LLMResponse type for LLM completion responses.

This module provides the LLMResponse type that wraps LLM completion responses
with OpenHands-native types, eliminating the need for consumers to work directly
with LiteLLM types.

<a id="openhands.sdk.llm.llm_response.LLMResponse"></a>

## LLMResponse Objects

```python
class LLMResponse(BaseModel)
```

Result of an LLM completion request.

This type provides a clean interface for LLM completion results, exposing
only OpenHands-native types to consumers while preserving access to the
raw LiteLLM response for internal use.

**Attributes**:

- `message` - The completion message converted to OpenHands Message type
- `metrics` - Snapshot of metrics from the completion request
- `raw_response` - The original LiteLLM response (ModelResponse or
  ResponsesAPIResponse) for internal use

<a id="openhands.sdk.llm.llm_response.LLMResponse.id"></a>

#### id

```python
@property
def id() -> str
```

Get the response ID from the underlying LLM response.

This property provides a clean interface to access the response ID,
supporting both completion mode (ModelResponse) and response API modes
(ResponsesAPIResponse).

**Returns**:

  The response ID from the LLM response

<a id="openhands.sdk.llm"></a>

# openhands.sdk.llm

<a id="openhands.sdk.llm.llm"></a>

# openhands.sdk.llm.llm

<a id="openhands.sdk.llm.llm.LLM"></a>

## LLM Objects

```python
class LLM(BaseModel, RetryMixin, NonNativeToolCallingMixin)
```

Refactored LLM: simple `completion()`, centralized Telemetry, tiny helpers.

<a id="openhands.sdk.llm.llm.LLM.completion"></a>

#### completion

```python
def completion(messages: list[Message],
               tools: Sequence[ToolBase] | None = None,
               _return_metrics: bool = False,
               add_security_risk_prediction: bool = False,
               **kwargs) -> LLMResponse
```

Single entry point for LLM completion.

Normalize  (maybe) mock tools  transport  postprocess.

<a id="openhands.sdk.llm.llm.LLM.responses"></a>

#### responses

```python
def responses(messages: list[Message],
              tools: Sequence[ToolBase] | None = None,
              include: list[str] | None = None,
              store: bool | None = None,
              _return_metrics: bool = False,
              add_security_risk_prediction: bool = False,
              **kwargs) -> LLMResponse
```

Alternative invocation path using OpenAI Responses API via LiteLLM.

Maps Message[] -> (instructions, input[]) and returns LLMResponse.
Non-stream only for v1.

<a id="openhands.sdk.llm.llm.LLM.is_caching_prompt_active"></a>

#### is\_caching\_prompt\_active

```python
def is_caching_prompt_active() -> bool
```

Check if prompt caching is supported and enabled for current model.

**Returns**:

- `boolean` - True if prompt caching is supported and enabled for the given
  model.

<a id="openhands.sdk.llm.llm.LLM.uses_responses_api"></a>

#### uses\_responses\_api

```python
def uses_responses_api() -> bool
```

Whether this model uses the OpenAI Responses API path.

<a id="openhands.sdk.llm.llm.LLM.model_info"></a>

#### model\_info

```python
@property
def model_info() -> dict | None
```

Returns the model info dictionary.

<a id="openhands.sdk.llm.llm.LLM.format_messages_for_llm"></a>

#### format\_messages\_for\_llm

```python
def format_messages_for_llm(messages: list[Message]) -> list[dict]
```

Formats Message objects for LLM consumption.

<a id="openhands.sdk.llm.llm.LLM.format_messages_for_responses"></a>

#### format\_messages\_for\_responses

```python
def format_messages_for_responses(
        messages: list[Message]) -> tuple[str | None, list[dict[str, Any]]]
```

Prepare (instructions, input[]) for the OpenAI Responses API.

- Skips prompt caching flags and string serializer concerns
- Uses Message.to_responses_value to get either instructions (system)
 or input items (others)
- Concatenates system instructions into a single instructions string

<a id="openhands.sdk.llm.llm.LLM.resolve_diff_from_deserialized"></a>

#### resolve\_diff\_from\_deserialized

```python
def resolve_diff_from_deserialized(persisted: LLM) -> LLM
```

Resolve differences between a deserialized LLM and the current instance.

This is due to fields like api_key being serialized to "****" in dumps,
and we want to ensure that when loading from a file, we still use the
runtime-provided api_key in the self instance.

Return a new LLM instance equivalent to `persisted` but with
explicitly whitelisted fields (e.g. api_key) taken from `self`.

<a id="openhands.sdk.llm.llm.LLM.is_context_window_exceeded_exception"></a>

#### is\_context\_window\_exceeded\_exception

```python
@staticmethod
def is_context_window_exceeded_exception(exception: Exception) -> bool
```

Check if the exception indicates a context window exceeded error.

Context window exceeded errors vary by provider, and LiteLLM does not do a
consistent job of identifying and wrapping them.

<a id="openhands.sdk.llm.utils.verified_models"></a>

# openhands.sdk.llm.utils.verified\_models

<a id="openhands.sdk.llm.utils.metrics"></a>

# openhands.sdk.llm.utils.metrics

<a id="openhands.sdk.llm.utils.metrics.ResponseLatency"></a>

## ResponseLatency Objects

```python
class ResponseLatency(BaseModel)
```

Metric tracking the round-trip time per completion call.

<a id="openhands.sdk.llm.utils.metrics.TokenUsage"></a>

## TokenUsage Objects

```python
class TokenUsage(BaseModel)
```

Metric tracking detailed token usage per completion call.

<a id="openhands.sdk.llm.utils.metrics.TokenUsage.__add__"></a>

#### \_\_add\_\_

```python
def __add__(other: "TokenUsage") -> "TokenUsage"
```

Add two TokenUsage instances together.

<a id="openhands.sdk.llm.utils.metrics.MetricsSnapshot"></a>

## MetricsSnapshot Objects

```python
class MetricsSnapshot(BaseModel)
```

A snapshot of metrics at a point in time.

Does not include lists of individual costs, latencies, or token usages.

<a id="openhands.sdk.llm.utils.metrics.Metrics"></a>

## Metrics Objects

```python
@final
class Metrics(MetricsSnapshot)
```

Metrics class can record various metrics during running and evaluation.
We track:
  - accumulated_cost and costs
  - max_budget_per_task (budget limit)
  - A list of ResponseLatency
  - A list of TokenUsage (one per call).

<a id="openhands.sdk.llm.utils.metrics.Metrics.get_snapshot"></a>

#### get\_snapshot

```python
def get_snapshot() -> MetricsSnapshot
```

Get a snapshot of the current metrics without the detailed lists.

<a id="openhands.sdk.llm.utils.metrics.Metrics.add_token_usage"></a>

#### add\_token\_usage

```python
def add_token_usage(prompt_tokens: int,
                    completion_tokens: int,
                    cache_read_tokens: int,
                    cache_write_tokens: int,
                    context_window: int,
                    response_id: str,
                    reasoning_tokens: int = 0) -> None
```

Add a single usage record.

<a id="openhands.sdk.llm.utils.metrics.Metrics.merge"></a>

#### merge

```python
def merge(other: "Metrics") -> None
```

Merge 'other' metrics into this one.

<a id="openhands.sdk.llm.utils.metrics.Metrics.get"></a>

#### get

```python
def get() -> dict
```

Return the metrics in a dictionary.

<a id="openhands.sdk.llm.utils.metrics.Metrics.log"></a>

#### log

```python
def log() -> str
```

Log the metrics.

<a id="openhands.sdk.llm.utils.metrics.Metrics.deep_copy"></a>

#### deep\_copy

```python
def deep_copy() -> "Metrics"
```

Create a deep copy of the Metrics object.

<a id="openhands.sdk.llm.utils.metrics.Metrics.diff"></a>

#### diff

```python
def diff(baseline: "Metrics") -> "Metrics"
```

Calculate the difference between current metrics and a baseline.

This is useful for tracking metrics for specific operations like delegates.

**Arguments**:

- `baseline` - A metrics object representing the baseline state
  

**Returns**:

  A new Metrics object containing only the differences since the baseline

<a id="openhands.sdk.llm.utils.model_features"></a>

# openhands.sdk.llm.utils.model\_features

<a id="openhands.sdk.llm.utils.model_features.model_matches"></a>

#### model\_matches

```python
def model_matches(model: str, patterns: list[str]) -> bool
```

Return True if any pattern appears as a substring in the raw model name.

Matching semantics:
- Case-insensitive substring search on full raw model string

<a id="openhands.sdk.llm.utils.model_features.get_features"></a>

#### get\_features

```python
def get_features(model: str) -> ModelFeatures
```

Get model features.

<a id="openhands.sdk.llm.utils.retry_mixin"></a>

# openhands.sdk.llm.utils.retry\_mixin

<a id="openhands.sdk.llm.utils.retry_mixin.RetryMixin"></a>

## RetryMixin Objects

```python
class RetryMixin()
```

Mixin class for retry logic.

<a id="openhands.sdk.llm.utils.retry_mixin.RetryMixin.retry_decorator"></a>

#### retry\_decorator

```python
def retry_decorator(
    num_retries: int = 5,
    retry_exceptions: tuple[type[BaseException], ...] = (LLMNoResponseError, ),
    retry_min_wait: int = 8,
    retry_max_wait: int = 64,
    retry_multiplier: float = 2.0,
    retry_listener: RetryListener | None = None
) -> Callable[[Callable[..., Any]], Callable[..., Any]]
```

Create a LLM retry decorator with customizable parameters.
This is used for 429 errors, and a few other exceptions in LLM classes.

<a id="openhands.sdk.llm.utils.retry_mixin.RetryMixin.log_retry_attempt"></a>

#### log\_retry\_attempt

```python
def log_retry_attempt(retry_state: RetryCallState) -> None
```

Log retry attempts.

<a id="openhands.sdk.llm.utils.unverified_models"></a>

# openhands.sdk.llm.utils.unverified\_models

<a id="openhands.sdk.llm.utils.unverified_models.get_supported_llm_models"></a>

#### get\_supported\_llm\_models

```python
def get_supported_llm_models(
        aws_region_name: str | None = None,
        aws_access_key_id: SecretStr | None = None,
        aws_secret_access_key: SecretStr | None = None) -> list[str]
```

Get all models supported by LiteLLM.

This function combines models from litellm and Bedrock, removing any
error-prone Bedrock models.

**Returns**:

- `list[str]` - A sorted list of unique model names.

<a id="openhands.sdk.llm.utils.unverified_models.get_unverified_models"></a>

#### get\_unverified\_models

```python
def get_unverified_models(
        aws_region_name: str | None = None,
        aws_access_key_id: SecretStr | None = None,
        aws_secret_access_key: SecretStr | None = None
) -> dict[str, list[str]]
```

Organize a mapping of unverified model identifiers by provider.

<a id="openhands.sdk.llm.utils.telemetry"></a>

# openhands.sdk.llm.utils.telemetry

<a id="openhands.sdk.llm.utils.telemetry.Telemetry"></a>

## Telemetry Objects

```python
class Telemetry(BaseModel)
```

Handles latency, token/cost accounting, and optional logging.
All runtime state (like start times) lives in private attrs.

<a id="openhands.sdk.llm.utils.telemetry.Telemetry.on_response"></a>

#### on\_response

```python
def on_response(resp: ModelResponse | ResponsesAPIResponse,
                raw_resp: ModelResponse | None = None) -> Metrics
```

Side-effects:
  - records latency, tokens, cost into Metrics
  - optionally writes a JSON log file

<a id="openhands.sdk.llm.message"></a>

# openhands.sdk.llm.message

<a id="openhands.sdk.llm.message.MessageToolCall"></a>

## MessageToolCall Objects

```python
class MessageToolCall(BaseModel)
```

Transport-agnostic tool call representation.

One canonical id is used for linking across actions/observations and
for Responses function_call_output call_id.

<a id="openhands.sdk.llm.message.MessageToolCall.from_chat_tool_call"></a>

#### from\_chat\_tool\_call

```python
@classmethod
def from_chat_tool_call(
        cls, tool_call: ChatCompletionMessageToolCall) -> "MessageToolCall"
```

Create a MessageToolCall from a Chat Completions tool call.

<a id="openhands.sdk.llm.message.MessageToolCall.from_responses_function_call"></a>

#### from\_responses\_function\_call

```python
@classmethod
def from_responses_function_call(
    cls, item: ResponseFunctionToolCall | OutputFunctionToolCall
) -> "MessageToolCall"
```

Create a MessageToolCall from a typed OpenAI Responses function_call item.

Note: OpenAI Responses function_call.arguments is already a JSON string.

<a id="openhands.sdk.llm.message.MessageToolCall.to_chat_dict"></a>

#### to\_chat\_dict

```python
def to_chat_dict() -> dict[str, Any]
```

Serialize to OpenAI Chat Completions tool_calls format.

<a id="openhands.sdk.llm.message.MessageToolCall.to_responses_dict"></a>

#### to\_responses\_dict

```python
def to_responses_dict() -> dict[str, Any]
```

Serialize to OpenAI Responses 'function_call' input item format.

<a id="openhands.sdk.llm.message.ThinkingBlock"></a>

## ThinkingBlock Objects

```python
class ThinkingBlock(BaseModel)
```

Anthropic thinking block for extended thinking feature.

This represents the raw thinking blocks returned by Anthropic models
when extended thinking is enabled. These blocks must be preserved
and passed back to the API for tool use scenarios.

<a id="openhands.sdk.llm.message.RedactedThinkingBlock"></a>

## RedactedThinkingBlock Objects

```python
class RedactedThinkingBlock(BaseModel)
```

Redacted thinking block for previous responses without extended thinking.

This is used as a placeholder for assistant messages that were generated
before extended thinking was enabled.

<a id="openhands.sdk.llm.message.ReasoningItemModel"></a>

## ReasoningItemModel Objects

```python
class ReasoningItemModel(BaseModel)
```

OpenAI Responses reasoning item (non-stream, subset we consume).

Do not log or render encrypted_content.

<a id="openhands.sdk.llm.message.BaseContent"></a>

## BaseContent Objects

```python
class BaseContent(BaseModel)
```

<a id="openhands.sdk.llm.message.BaseContent.to_llm_dict"></a>

#### to\_llm\_dict

```python
@abstractmethod
def to_llm_dict() -> list[dict[str, str | dict[str, str]]]
```

Convert to LLM API format. Always returns a list of dictionaries.

Subclasses should implement this method to return a list of dictionaries,
even if they only have a single item.

<a id="openhands.sdk.llm.message.TextContent"></a>

## TextContent Objects

```python
class TextContent(BaseContent)
```

<a id="openhands.sdk.llm.message.TextContent.to_llm_dict"></a>

#### to\_llm\_dict

```python
def to_llm_dict() -> list[dict[str, str | dict[str, str]]]
```

Convert to LLM API format.

<a id="openhands.sdk.llm.message.ImageContent"></a>

## ImageContent Objects

```python
class ImageContent(BaseContent)
```

<a id="openhands.sdk.llm.message.ImageContent.to_llm_dict"></a>

#### to\_llm\_dict

```python
def to_llm_dict() -> list[dict[str, str | dict[str, str]]]
```

Convert to LLM API format.

<a id="openhands.sdk.llm.message.Message"></a>

## Message Objects

```python
class Message(BaseModel)
```

<a id="openhands.sdk.llm.message.Message.name"></a>

#### name

name of the tool

<a id="openhands.sdk.llm.message.Message.to_chat_dict"></a>

#### to\_chat\_dict

```python
def to_chat_dict() -> dict[str, Any]
```

Serialize message for OpenAI Chat Completions.

Chooses the appropriate content serializer and then injects threading keys:
- Assistant tool call turn: role == "assistant" and self.tool_calls
- Tool result turn: role == "tool" and self.tool_call_id (with name)

<a id="openhands.sdk.llm.message.Message.to_responses_value"></a>

#### to\_responses\_value

```python
def to_responses_value(*, vision_enabled: bool) -> str | list[dict[str, Any]]
```

Return serialized form.

Either an instructions string (for system) or input items (for other roles).

<a id="openhands.sdk.llm.message.Message.to_responses_dict"></a>

#### to\_responses\_dict

```python
def to_responses_dict(*, vision_enabled: bool) -> list[dict[str, Any]]
```

Serialize message for OpenAI Responses (input parameter).

Produces a list of "input" items for the Responses API:
- system: returns [], system content is expected in 'instructions'
- user: one 'message' item with content parts -> input_text / input_image
(when vision enabled)
- assistant: emits prior assistant content as input_text,
and function_call items for tool_calls
- tool: emits function_call_output items (one per TextContent)
with matching call_id

<a id="openhands.sdk.llm.message.Message.from_llm_chat_message"></a>

#### from\_llm\_chat\_message

```python
@classmethod
def from_llm_chat_message(cls, message: LiteLLMMessage) -> "Message"
```

Convert a LiteLLMMessage (Chat Completions) to our Message class.

Provider-agnostic mapping for reasoning:
- Prefer `message.reasoning_content` if present (LiteLLM normalized field)
- Extract `thinking_blocks` from content array (Anthropic-specific)

<a id="openhands.sdk.llm.message.Message.from_llm_responses_output"></a>

#### from\_llm\_responses\_output

```python
@classmethod
def from_llm_responses_output(cls, output: Any) -> "Message"
```

Convert OpenAI Responses API output items into a single assistant Message.

Policy (non-stream):
- Collect assistant text by concatenating output_text parts from message items
- Normalize function_call items to MessageToolCall list

<a id="openhands.sdk.llm.message.content_to_str"></a>

#### content\_to\_str

```python
def content_to_str(
        contents: Sequence[TextContent | ImageContent]) -> list[str]
```

Convert a list of TextContent and ImageContent to a list of strings.

This is primarily used for display purposes.

<a id="openhands.sdk.llm.exceptions"></a>

# openhands.sdk.llm.exceptions

<a id="openhands.sdk.llm.exceptions.LLMError"></a>

## LLMError Objects

```python
class LLMError(Exception)
```

Base class for all LLM-related exceptions.

<a id="openhands.sdk.llm.exceptions.LLMMalformedActionError"></a>

## LLMMalformedActionError Objects

```python
class LLMMalformedActionError(LLMError)
```

Exception raised when the LLM response is malformed or does not conform to the expected format.

<a id="openhands.sdk.llm.exceptions.LLMNoActionError"></a>

## LLMNoActionError Objects

```python
class LLMNoActionError(LLMError)
```

Exception raised when the LLM response does not include an action.

<a id="openhands.sdk.llm.exceptions.LLMResponseError"></a>

## LLMResponseError Objects

```python
class LLMResponseError(LLMError)
```

Exception raised when the LLM response does not include an action or the action is not of the expected type.

<a id="openhands.sdk.llm.exceptions.LLMNoResponseError"></a>

## LLMNoResponseError Objects

```python
class LLMNoResponseError(LLMError)
```

Exception raised when the LLM does not return a response, typically seen in
Gemini models.

This exception should be retried
Typically, after retry with a non-zero temperature, the LLM will return a response

<a id="openhands.sdk.llm.exceptions.FunctionCallConversionError"></a>

## FunctionCallConversionError Objects

```python
class FunctionCallConversionError(LLMError)
```

Exception raised when FunctionCallingConverter failed to convert a non-function
call message to a function call message.

This typically happens when there's a malformed message (e.g., missing
<function=...> tags). But not due to LLM output.

<a id="openhands.sdk.llm.exceptions.FunctionCallValidationError"></a>

## FunctionCallValidationError Objects

```python
class FunctionCallValidationError(LLMError)
```

Exception raised when FunctionCallingConverter failed to validate a function
call message.

This typically happens when the LLM outputs unrecognized function call /
parameter names / values.

<a id="openhands.sdk.llm.exceptions.FunctionCallNotExistsError"></a>

## FunctionCallNotExistsError Objects

```python
class FunctionCallNotExistsError(LLMError)
```

Exception raised when an LLM call a tool that is not registered.

<a id="openhands.sdk.llm.exceptions.OperationCancelled"></a>

## OperationCancelled Objects

```python
class OperationCancelled(Exception)
```

Exception raised when an operation is cancelled (e.g. by a keyboard interrupt).

<a id="openhands.sdk.llm.llm_registry"></a>

# openhands.sdk.llm.llm\_registry

<a id="openhands.sdk.llm.llm_registry.LLMRegistry"></a>

## LLMRegistry Objects

```python
class LLMRegistry()
```

A minimal LLM registry for managing LLM instances by usage ID.

This registry provides a simple way to manage multiple LLM instances,
avoiding the need to recreate LLMs with the same configuration.

<a id="openhands.sdk.llm.llm_registry.LLMRegistry.__init__"></a>

#### \_\_init\_\_

```python
def __init__(retry_listener: Callable[[int, int], None] | None = None)
```

Initialize the LLM registry.

**Arguments**:

- `retry_listener` - Optional callback for retry events.

<a id="openhands.sdk.llm.llm_registry.LLMRegistry.subscribe"></a>

#### subscribe

```python
def subscribe(callback: Callable[[RegistryEvent], None]) -> None
```

Subscribe to registry events.

**Arguments**:

- `callback` - Function to call when LLMs are created or updated.

<a id="openhands.sdk.llm.llm_registry.LLMRegistry.notify"></a>

#### notify

```python
def notify(event: RegistryEvent) -> None
```

Notify subscribers of registry events.

**Arguments**:

- `event` - The registry event to notify about.

<a id="openhands.sdk.llm.llm_registry.LLMRegistry.usage_to_llm"></a>

#### usage\_to\_llm

```python
@property
def usage_to_llm() -> dict[str, LLM]
```

Access the internal usage-ID-to-LLM mapping.

<a id="openhands.sdk.llm.llm_registry.LLMRegistry.add"></a>

#### add

```python
def add(llm: LLM) -> None
```

Add an LLM instance to the registry.

**Arguments**:

- `llm` - The LLM instance to register.
  

**Raises**:

- `ValueError` - If llm.usage_id already exists in the registry.

<a id="openhands.sdk.llm.llm_registry.LLMRegistry.get"></a>

#### get

```python
def get(usage_id: str) -> LLM
```

Get an LLM instance from the registry.

**Arguments**:

- `usage_id` - Unique identifier for the LLM usage slot.
  

**Returns**:

  The LLM instance.
  

**Raises**:

- `KeyError` - If usage_id is not found in the registry.

<a id="openhands.sdk.llm.llm_registry.LLMRegistry.list_usage_ids"></a>

#### list\_usage\_ids

```python
def list_usage_ids() -> list[str]
```

List all registered usage IDs.

<a id="openhands.sdk.llm.llm_registry.LLMRegistry.list_services"></a>

#### list\_services

```python
def list_services() -> list[str]
```

Deprecated alias for :meth:`list_usage_ids`.

<a id="openhands.sdk.llm.options.common"></a>

# openhands.sdk.llm.options.common

<a id="openhands.sdk.llm.options.common.apply_defaults_if_absent"></a>

#### apply\_defaults\_if\_absent

```python
def apply_defaults_if_absent(user_kwargs: dict[str, Any],
                             defaults: dict[str, Any]) -> dict[str, Any]
```

Return a new dict with defaults applied when keys are absent.

- Pure and deterministic; does not mutate inputs
- Only applies defaults when the key is missing and default is not None
- Does not alter user-provided values

<a id="openhands.sdk.llm.options"></a>

# openhands.sdk.llm.options

<a id="openhands.sdk.llm.options.chat_options"></a>

# openhands.sdk.llm.options.chat\_options

<a id="openhands.sdk.llm.options.chat_options.select_chat_options"></a>

#### select\_chat\_options

```python
def select_chat_options(llm, user_kwargs: dict[str, Any],
                        has_tools: bool) -> dict[str, Any]
```

Behavior-preserving extraction of _normalize_call_kwargs.

This keeps the exact provider-aware mappings and precedence.

<a id="openhands.sdk.llm.options.responses_options"></a>

# openhands.sdk.llm.options.responses\_options

<a id="openhands.sdk.llm.options.responses_options.select_responses_options"></a>

#### select\_responses\_options

```python
def select_responses_options(llm, user_kwargs: dict[str, Any], *,
                             include: list[str] | None,
                             store: bool | None) -> dict[str, Any]
```

Behavior-preserving extraction of _normalize_responses_kwargs.

<a id="openhands.sdk.llm.router.impl.random"></a>

# openhands.sdk.llm.router.impl.random

<a id="openhands.sdk.llm.router.impl.random.RandomRouter"></a>

## RandomRouter Objects

```python
class RandomRouter(RouterLLM)
```

A simple implementation of RouterLLM that randomly selects an LLM from
llms_for_routing for each completion request.

<a id="openhands.sdk.llm.router.impl.multimodal"></a>

# openhands.sdk.llm.router.impl.multimodal

<a id="openhands.sdk.llm.router.impl.multimodal.MultimodalRouter"></a>

## MultimodalRouter Objects

```python
class MultimodalRouter(RouterLLM)
```

A RouterLLM implementation that routes requests based on multimodal content
(e.g., images) and token limits. If any message contains multimodal content
or if the token limit of the secondary model is exceeded, it routes to the
primary model. Otherwise, it routes to the secondary model.

Note: The primary model is expected to support multimodal content, while
the secondary model is typically a text-only model with a lower context window.

<a id="openhands.sdk.llm.router.impl.multimodal.MultimodalRouter.select_llm"></a>

#### select\_llm

```python
def select_llm(messages: list[Message]) -> str
```

Select LLM based on multimodal content and token limits.

<a id="openhands.sdk.llm.router.base"></a>

# openhands.sdk.llm.router.base

<a id="openhands.sdk.llm.router.base.RouterLLM"></a>

## RouterLLM Objects

```python
class RouterLLM(LLM)
```

Base class for multiple LLM acting as a unified LLM.
This class provides a foundation for implementing model routing by
inheriting from LLM, allowing routers to work with multiple underlying
LLM models while presenting a unified LLM interface to consumers.
Key features:
- Works with multiple LLMs configured via llms_for_routing
- Delegates all other operations/properties to the selected LLM
- Provides routing interface through select_llm() method

<a id="openhands.sdk.llm.router.base.RouterLLM.llms_for_routing"></a>

#### llms\_for\_routing

Mapping of LLM name to LLM instance for routing

<a id="openhands.sdk.llm.router.base.RouterLLM.completion"></a>

#### completion

```python
def completion(messages: list[Message],
               tools: Sequence[ToolBase] | None = None,
               return_metrics: bool = False,
               add_security_risk_prediction: bool = False,
               **kwargs) -> LLMResponse
```

This method intercepts completion calls and routes them to the appropriate
underlying LLM based on the routing logic implemented in select_llm().

<a id="openhands.sdk.llm.router.base.RouterLLM.select_llm"></a>

#### select\_llm

```python
@abstractmethod
def select_llm(messages: list[Message]) -> str
```

Select which LLM to use based on messages and events.

This method implements the core routing logic for the RouterLLM.
Subclasses should analyze the provided messages to determine which
LLM from llms_for_routing is most appropriate for handling the request.

**Arguments**:

- `messages` - List of messages in the conversation that can be used
  to inform the routing decision.
  

**Returns**:

  The key/name of the LLM to use from llms_for_routing dictionary.

<a id="openhands.sdk.llm.router.base.RouterLLM.__getattr__"></a>

#### \_\_getattr\_\_

```python
def __getattr__(name)
```

Delegate other attributes/methods to the active LLM.

<a id="openhands.sdk.llm.router.base.RouterLLM.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

String representation of the router.

<a id="openhands.sdk.llm.router.base.RouterLLM.set_placeholder_model"></a>

#### set\_placeholder\_model

```python
@model_validator(mode="before")
@classmethod
def set_placeholder_model(cls, data)
```

Guarantee `model` exists before LLM base validation runs.

<a id="openhands.sdk.llm.router"></a>

# openhands.sdk.llm.router

<a id="openhands.sdk.security.llm_analyzer"></a>

# openhands.sdk.security.llm\_analyzer

<a id="openhands.sdk.security.llm_analyzer.LLMSecurityAnalyzer"></a>

## LLMSecurityAnalyzer Objects

```python
class LLMSecurityAnalyzer(SecurityAnalyzerBase)
```

LLM-based security analyzer.

This analyzer respects the security_risk attribute that can be set by the LLM
when generating actions, similar to OpenHands' LLMRiskAnalyzer.

It provides a lightweight security analysis approach that leverages the LLM's
understanding of action context and potential risks.

<a id="openhands.sdk.security.llm_analyzer.LLMSecurityAnalyzer.security_risk"></a>

#### security\_risk

```python
def security_risk(action: ActionEvent) -> SecurityRisk
```

Evaluate security risk based on LLM-provided assessment.

This method checks if the action has a security_risk attribute set by the LLM
and returns it. The LLM may not always provide this attribute but it defaults to
UNKNOWN if not explicitly set.

<a id="openhands.sdk.security.analyzer"></a>

# openhands.sdk.security.analyzer

<a id="openhands.sdk.security.analyzer.SecurityAnalyzerBase"></a>

## SecurityAnalyzerBase Objects

```python
class SecurityAnalyzerBase(DiscriminatedUnionMixin, ABC)
```

Abstract base class for security analyzers.

Security analyzers evaluate the risk of actions before they are executed
and can influence the conversation flow based on security policies.

This is adapted from OpenHands SecurityAnalyzer but designed to work
with the agent-sdk's conversation-based architecture.

<a id="openhands.sdk.security.analyzer.SecurityAnalyzerBase.security_risk"></a>

#### security\_risk

```python
@abstractmethod
def security_risk(action: ActionEvent) -> SecurityRisk
```

Evaluate the security risk of an ActionEvent.

This is the core method that analyzes an ActionEvent and returns its risk level.
Implementations should examine the action's content, context, and potential
impact to determine the appropriate risk level.

**Arguments**:

- `action` - The ActionEvent to analyze for security risks
  

**Returns**:

  ActionSecurityRisk enum indicating the risk level

<a id="openhands.sdk.security.analyzer.SecurityAnalyzerBase.analyze_event"></a>

#### analyze\_event

```python
def analyze_event(event: Event) -> SecurityRisk | None
```

Analyze an event for security risks.

This is a convenience method that checks if the event is an action
and calls security_risk() if it is. Non-action events return None.

**Arguments**:

- `event` - The event to analyze
  

**Returns**:

  ActionSecurityRisk if event is an action, None otherwise

<a id="openhands.sdk.security.analyzer.SecurityAnalyzerBase.should_require_confirmation"></a>

#### should\_require\_confirmation

```python
def should_require_confirmation(risk: SecurityRisk,
                                confirmation_mode: bool = False) -> bool
```

Determine if an action should require user confirmation.

This implements the default confirmation logic based on risk level
and confirmation mode settings.

**Arguments**:

- `risk` - The security risk level of the action
- `confirmation_mode` - Whether confirmation mode is enabled
  

**Returns**:

  True if confirmation is required, False otherwise

<a id="openhands.sdk.security.analyzer.SecurityAnalyzerBase.analyze_pending_actions"></a>

#### analyze\_pending\_actions

```python
def analyze_pending_actions(
    pending_actions: list[ActionEvent]
) -> list[tuple[ActionEvent, SecurityRisk]]
```

Analyze all pending actions in a conversation.

This method gets all unmatched actions from the conversation state
and analyzes each one for security risks.

**Arguments**:

- `conversation` - The conversation to analyze
  

**Returns**:

  List of tuples containing (action, risk_level) for each pending action

<a id="openhands.sdk.security.confirmation_policy"></a>

# openhands.sdk.security.confirmation\_policy

<a id="openhands.sdk.security.confirmation_policy.ConfirmationPolicyBase"></a>

## ConfirmationPolicyBase Objects

```python
class ConfirmationPolicyBase(DiscriminatedUnionMixin, ABC)
```

<a id="openhands.sdk.security.confirmation_policy.ConfirmationPolicyBase.should_confirm"></a>

#### should\_confirm

```python
@abstractmethod
def should_confirm(risk: SecurityRisk = SecurityRisk.UNKNOWN) -> bool
```

Determine if an action with the given risk level requires confirmation.

This method defines the core logic for determining whether user confirmation
is required before executing an action based on its security risk level.

**Arguments**:

- `risk` - The security risk level of the action to be evaluated.
  Defaults to SecurityRisk.UNKNOWN if not specified.
  

**Returns**:

  True if the action requires user confirmation before execution,
  False if the action can proceed without confirmation.

<a id="openhands.sdk.security"></a>

# openhands.sdk.security

<a id="openhands.sdk.security.risk"></a>

# openhands.sdk.security.risk

<a id="openhands.sdk.security.risk.SecurityRisk"></a>

## SecurityRisk Objects

```python
class SecurityRisk(str, Enum)
```

Security risk levels for actions.

Based on OpenHands security risk levels but adapted for agent-sdk.
Integer values allow for easy comparison and ordering.

<a id="openhands.sdk.security.risk.SecurityRisk.description"></a>

#### description

```python
@property
def description() -> str
```

Get a human-readable description of the risk level.

<a id="openhands.sdk.security.risk.SecurityRisk.get_color"></a>

#### get\_color

```python
def get_color() -> str
```

Get the color for displaying this risk level in Rich text.

<a id="openhands.sdk.security.risk.SecurityRisk.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this risk level.

<a id="openhands.sdk.security.risk.SecurityRisk.is_riskier"></a>

#### is\_riskier

```python
def is_riskier(other: SecurityRisk, reflexive: bool = True) -> bool
```

Check if this risk level is riskier than another.

Risk levels follow the natural ordering: LOW is less risky than MEDIUM, which is
less risky than HIGH. UNKNOWN is not comparable to any other level.

To make this act like a standard well-ordered domain, we reflexively consider
risk levels to be riskier than themselves. That is:

for risk_level in list(SecurityRisk):
assert risk_level.is_riskier(risk_level)

# More concretely:
assert SecurityRisk.HIGH.is_riskier(SecurityRisk.HIGH)
assert SecurityRisk.MEDIUM.is_riskier(SecurityRisk.MEDIUM)
assert SecurityRisk.LOW.is_riskier(SecurityRisk.LOW)

This can be disabled by setting the `reflexive` parameter to False.

**Arguments**:

- `other` _SecurityRisk_ - The other risk level to compare against.
- `reflexive` _bool_ - Whether the relationship is reflexive.
  

**Raises**:

- `ValueError` - If either risk level is UNKNOWN.

<a id="openhands.sdk.context"></a>

# openhands.sdk.context

<a id="openhands.sdk.context.agent_context"></a>

# openhands.sdk.context.agent\_context

<a id="openhands.sdk.context.agent_context.AgentContext"></a>

## AgentContext Objects

```python
class AgentContext(BaseModel)
```

Central structure for managing prompt extension.

AgentContext unifies all the contextual inputs that shape how the system
extends and interprets user prompts. It combines both static environment
details and dynamic, user-activated extensions from skills.

Specifically, it provides:
- **Repository context / Repo Skills**: Information about the active codebase,
  branches, and repo-specific instructions contributed by repo skills.
- **Runtime context**: Current execution environment (hosts, working
  directory, secrets, date, etc.).
- **Conversation instructions**: Optional task- or channel-specific rules
  that constrain or guide the agents behavior across the session.
- **Knowledge Skills**: Extensible components that can be triggered by user input
  to inject knowledge or domain-specific guidance.

Together, these elements make AgentContext the primary container responsible
for assembling, formatting, and injecting all prompt-relevant context into
LLM interactions.

<a id="openhands.sdk.context.agent_context.AgentContext.get_system_message_suffix"></a>

#### get\_system\_message\_suffix

```python
def get_system_message_suffix() -> str | None
```

Get the system message with repo skill content and custom suffix.

Custom suffix can typically includes:
- Repository information (repo name, branch name, PR number, etc.)
- Runtime information (e.g., available hosts, current date)
- Conversation instructions (e.g., user preferences, task details)
- Repository-specific instructions (collected from repo skills)

<a id="openhands.sdk.context.agent_context.AgentContext.get_user_message_suffix"></a>

#### get\_user\_message\_suffix

```python
def get_user_message_suffix(
        user_message: Message,
        skip_skill_names: list[str]) -> tuple[TextContent, list[str]] | None
```

Augment the users message with knowledge recalled from skills.

This works by:
- Extracting the text content of the user message
- Matching skill triggers against the query
- Returning formatted knowledge and triggered skill names if relevant skills were triggered

<a id="openhands.sdk.context.view"></a>

# openhands.sdk.context.view

<a id="openhands.sdk.context.view.View"></a>

## View Objects

```python
class View(BaseModel)
```

Linearly ordered view of events.

Produced by a condenser to indicate the included events are ready to process as LLM
input. Also contains fields with information from the condensation process to aid
in deciding whether further condensation is needed.

<a id="openhands.sdk.context.view.View.unhandled_condensation_request"></a>

#### unhandled\_condensation\_request

Whether there is an unhandled condensation request in the view.

<a id="openhands.sdk.context.view.View.condensations"></a>

#### condensations

A list of condensations that were processed to produce the view.

<a id="openhands.sdk.context.view.View.most_recent_condensation"></a>

#### most\_recent\_condensation

```python
@property
def most_recent_condensation() -> Condensation | None
```

Return the most recent condensation, or None if no condensations exist.

<a id="openhands.sdk.context.view.View.summary_event_index"></a>

#### summary\_event\_index

```python
@property
def summary_event_index() -> int | None
```

Return the index of the summary event, or None if no summary exists.

<a id="openhands.sdk.context.view.View.summary_event"></a>

#### summary\_event

```python
@property
def summary_event() -> CondensationSummaryEvent | None
```

Return the summary event, or None if no summary exists.

<a id="openhands.sdk.context.view.View.filter_unmatched_tool_calls"></a>

#### filter\_unmatched\_tool\_calls

```python
@staticmethod
def filter_unmatched_tool_calls(
        events: list[LLMConvertibleEvent]) -> list[LLMConvertibleEvent]
```

Filter out unmatched tool call events.

Removes ActionEvents and ObservationEvents that have tool_call_ids
but don't have matching pairs.

<a id="openhands.sdk.context.view.View.from_events"></a>

#### from\_events

```python
@staticmethod
def from_events(events: Sequence[Event]) -> "View"
```

Create a view from a list of events, respecting the semantics of any
condensation events.

<a id="openhands.sdk.context.prompts"></a>

# openhands.sdk.context.prompts

<a id="openhands.sdk.context.prompts.prompt"></a>

# openhands.sdk.context.prompts.prompt

<a id="openhands.sdk.context.prompts.prompt.render_template"></a>

#### render\_template

```python
def render_template(prompt_dir: str, template_name: str, **ctx) -> str
```

Render a Jinja2 template.

**Arguments**:

- `prompt_dir` - The base directory for relative template paths.
- `template_name` - The template filename. Can be either:
  - A relative filename (e.g., "system_prompt.j2") loaded from prompt_dir
  - An absolute path (e.g., "/path/to/custom_prompt.j2")
- `**ctx` - Template context variables.
  

**Returns**:

  Rendered template string.
  

**Raises**:

- `FileNotFoundError` - If the template file cannot be found.

<a id="openhands.sdk.context.condenser.no_op_condenser"></a>

# openhands.sdk.context.condenser.no\_op\_condenser

<a id="openhands.sdk.context.condenser.no_op_condenser.NoOpCondenser"></a>

## NoOpCondenser Objects

```python
class NoOpCondenser(CondenserBase)
```

Simple condenser that returns a view un-manipulated.

Primarily intended for testing purposes.

<a id="openhands.sdk.context.condenser.llm_summarizing_condenser"></a>

# openhands.sdk.context.condenser.llm\_summarizing\_condenser

<a id="openhands.sdk.context.condenser.base"></a>

# openhands.sdk.context.condenser.base

<a id="openhands.sdk.context.condenser.base.CondenserBase"></a>

## CondenserBase Objects

```python
class CondenserBase(DiscriminatedUnionMixin, ABC)
```

Abstract condenser interface.

Condensers take a list of `Event` objects and reduce them into a potentially smaller
list.

Agents can use condensers to reduce the amount of events they need to consider when
deciding which action to take. To use a condenser, agents can call the
`condensed_history` method on the current `State` being considered and use the
results instead of the full history.

If the condenser returns a `Condensation` instead of a `View`, the agent should
return `Condensation.action` instead of producing its own action. On the next agent
step the condenser will use that condensation event to produce a new `View`.

<a id="openhands.sdk.context.condenser.base.CondenserBase.condense"></a>

#### condense

```python
@abstractmethod
def condense(view: View) -> View | Condensation
```

Condense a sequence of events into a potentially smaller list.

New condenser strategies should override this method to implement their own
condensation logic. Call `self.add_metadata` in the implementation to record any
relevant per-condensation diagnostic information.

**Arguments**:

- `view` - A view of the history containing all events that should be condensed.
  

**Returns**:

  View | Condensation: A condensed view of the events or an event indicating
  the history has been condensed.

<a id="openhands.sdk.context.condenser.base.CondenserBase.handles_condensation_requests"></a>

#### handles\_condensation\_requests

```python
def handles_condensation_requests() -> bool
```

Whether this condenser handles explicit condensation requests.

If this returns True, the agent will trigger the condenser whenever a
CondensationRequest event is added to the history. If False, the condenser will
only be triggered when the agent's own logic decides to do so (e.g. context
window exceeded).

**Returns**:

- `bool` - True if the condenser handles explicit condensation requests, False
  otherwise.

<a id="openhands.sdk.context.condenser.base.PipelinableCondenserBase"></a>

## PipelinableCondenserBase Objects

```python
class PipelinableCondenserBase(CondenserBase)
```

Abstract condenser interface which may be pipelined. (Since a pipeline
condenser should not nest another pipeline condenser)

<a id="openhands.sdk.context.condenser.base.RollingCondenser"></a>

## RollingCondenser Objects

```python
class RollingCondenser(PipelinableCondenserBase, ABC)
```

Base class for a specialized condenser strategy that applies condensation to a
rolling history.

The rolling history is generated by `View.from_events`, which analyzes all events in
the history and produces a `View` object representing what will be sent to the LLM.

If `should_condense` says so, the condenser is then responsible for generating a
`Condensation` object from the `View` object. This will be added to the event
history which should -- when given to `get_view` -- produce the condensed `View` to
be passed to the LLM.

<a id="openhands.sdk.context.condenser.base.RollingCondenser.should_condense"></a>

#### should\_condense

```python
@abstractmethod
def should_condense(view: View) -> bool
```

Determine if a view should be condensed.

<a id="openhands.sdk.context.condenser.base.RollingCondenser.get_condensation"></a>

#### get\_condensation

```python
@abstractmethod
def get_condensation(view: View) -> Condensation
```

Get the condensation from a view.

<a id="openhands.sdk.context.condenser"></a>

# openhands.sdk.context.condenser

<a id="openhands.sdk.context.condenser.pipeline_condenser"></a>

# openhands.sdk.context.condenser.pipeline\_condenser

<a id="openhands.sdk.context.condenser.pipeline_condenser.PipelineCondenser"></a>

## PipelineCondenser Objects

```python
class PipelineCondenser(CondenserBase)
```

A condenser that applies a sequence of condensers in order.

All condensers are defined primarily by their `condense` method, which takes a
`View` and returns either a new `View` or a `Condensation` event. That means we can
chain multiple condensers together by passing `View`s along and exiting early if any
condenser returns a `Condensation`.

For example:

    # Use the pipeline condenser to chain multiple other condensers together
    condenser = PipelineCondenser(condensers=[
        CondenserA(...),
        CondenserB(...),
        CondenserC(...),
    ])

    result = condenser.condense(view)

    # Doing the same thing without the pipeline condenser requires more boilerplate
    # for the monadic chaining
    other_result = view

    if isinstance(other_result, View):
        other_result = CondenserA(...).condense(other_result)

    if isinstance(other_result, View):
        other_result = CondenserB(...).condense(other_result)

    if isinstance(other_result, View):
        other_result = CondenserC(...).condense(other_result)

    assert result == other_result

<a id="openhands.sdk.context.condenser.pipeline_condenser.PipelineCondenser.condensers"></a>

#### condensers

The list of condensers to apply in order.

<a id="openhands.sdk.context.skills.types"></a>

# openhands.sdk.context.skills.types

<a id="openhands.sdk.context.skills.types.InputMetadata"></a>

## InputMetadata Objects

```python
class InputMetadata(BaseModel)
```

Metadata for task skill inputs.

<a id="openhands.sdk.context.skills.types.SkillKnowledge"></a>

## SkillKnowledge Objects

```python
class SkillKnowledge(BaseModel)
```

Represents knowledge from a triggered skill.

<a id="openhands.sdk.context.skills.types.SkillResponse"></a>

## SkillResponse Objects

```python
class SkillResponse(BaseModel)
```

Response model for skills endpoint.

Note: This model only includes basic metadata that can be determined
without parsing skill content. Use the separate content API
to get detailed skill information.

<a id="openhands.sdk.context.skills.types.SkillContentResponse"></a>

## SkillContentResponse Objects

```python
class SkillContentResponse(BaseModel)
```

Response model for individual skill content endpoint.

<a id="openhands.sdk.context.skills.trigger"></a>

# openhands.sdk.context.skills.trigger

Trigger types for skills.

This module defines different trigger types that determine when a skill
should be activated.

<a id="openhands.sdk.context.skills.trigger.BaseTrigger"></a>

## BaseTrigger Objects

```python
class BaseTrigger(BaseModel, ABC)
```

Base class for all trigger types.

<a id="openhands.sdk.context.skills.trigger.KeywordTrigger"></a>

## KeywordTrigger Objects

```python
class KeywordTrigger(BaseTrigger)
```

Trigger for keyword-based skills.

These skills are activated when specific keywords appear in the user's query.

<a id="openhands.sdk.context.skills.trigger.TaskTrigger"></a>

## TaskTrigger Objects

```python
class TaskTrigger(BaseTrigger)
```

Trigger for task-specific skills.

These skills are activated for specific task types and can modify prompts.

<a id="openhands.sdk.context.skills"></a>

# openhands.sdk.context.skills

<a id="openhands.sdk.context.skills.skill"></a>

# openhands.sdk.context.skills.skill

<a id="openhands.sdk.context.skills.skill.Skill"></a>

## Skill Objects

```python
class Skill(BaseModel)
```

A skill provides specialized knowledge or functionality.

Skills use triggers to determine when they should be activated:
- None: Always active, for repository-specific guidelines
- KeywordTrigger: Activated when keywords appear in user messages
- TaskTrigger: Activated for specific tasks, may require user input

<a id="openhands.sdk.context.skills.skill.Skill.load"></a>

#### load

```python
@classmethod
def load(cls,
         path: str | Path,
         skill_dir: Path | None = None,
         file_content: str | None = None) -> "Skill"
```

Load a skill from a markdown file with frontmatter.

The agent's name is derived from its path relative to the skill_dir.

<a id="openhands.sdk.context.skills.skill.Skill.match_trigger"></a>

#### match\_trigger

```python
def match_trigger(message: str) -> str | None
```

Match a trigger in the message.

Returns the first trigger that matches the message, or None if no match.
Only applies to KeywordTrigger and TaskTrigger types.

<a id="openhands.sdk.context.skills.skill.Skill.extract_variables"></a>

#### extract\_variables

```python
def extract_variables(content: str) -> list[str]
```

Extract variables from the content.

Variables are in the format ${variable_name}.

<a id="openhands.sdk.context.skills.skill.Skill.requires_user_input"></a>

#### requires\_user\_input

```python
def requires_user_input() -> bool
```

Check if this skill requires user input.

Returns True if the content contains variables in the format ${variable_name}.

<a id="openhands.sdk.context.skills.skill.load_skills_from_dir"></a>

#### load\_skills\_from\_dir

```python
def load_skills_from_dir(
        skill_dir: str | Path) -> tuple[dict[str, Skill], dict[str, Skill]]
```

Load all skills from the given directory.

Note, legacy repo instructions will not be loaded here.

**Arguments**:

- `skill_dir` - Path to the skills directory (e.g. .openhands/skills)
  

**Returns**:

  Tuple of (repo_skills, knowledge_skills) dictionaries.
  repo_skills have trigger=None, knowledge_skills have KeywordTrigger
  or TaskTrigger.

<a id="openhands.sdk.context.skills.exceptions"></a>

# openhands.sdk.context.skills.exceptions

<a id="openhands.sdk.context.skills.exceptions.SkillError"></a>

## SkillError Objects

```python
class SkillError(Exception)
```

Base exception for all skill errors.

<a id="openhands.sdk.context.skills.exceptions.SkillValidationError"></a>

## SkillValidationError Objects

```python
class SkillValidationError(SkillError)
```

Raised when there's a validation error in skill metadata.

<a id="openhands.sdk.agent.base"></a>

# openhands.sdk.agent.base

<a id="openhands.sdk.agent.base.AgentBase"></a>

## AgentBase Objects

```python
class AgentBase(DiscriminatedUnionMixin, ABC)
```

Abstract base class for agents.
Agents are stateless and should be fully defined by their configuration.

<a id="openhands.sdk.agent.base.AgentBase.prompt_dir"></a>

#### prompt\_dir

```python
@property
def prompt_dir() -> str
```

Returns the directory where this class's module file is located.

<a id="openhands.sdk.agent.base.AgentBase.name"></a>

#### name

```python
@property
def name() -> str
```

Returns the name of the Agent.

<a id="openhands.sdk.agent.base.AgentBase.system_message"></a>

#### system\_message

```python
@property
def system_message() -> str
```

Compute system message on-demand to maintain statelessness.

<a id="openhands.sdk.agent.base.AgentBase.init_state"></a>

#### init\_state

```python
def init_state(state: "ConversationState",
               on_event: "ConversationCallbackType") -> None
```

Initialize the empty conversation state to prepare the agent for user
messages.

Typically this involves adding system message

NOTE: state will be mutated in-place.

<a id="openhands.sdk.agent.base.AgentBase.step"></a>

#### step

```python
@abstractmethod
def step(conversation: "LocalConversation",
         on_event: "ConversationCallbackType") -> None
```

Taking a step in the conversation.

Typically this involves:
1. Making a LLM call
2. Executing the tool
3. Updating the conversation state with
    LLM calls (role="assistant") and tool results (role="tool")
4.1 If conversation is finished, set state.agent_status to FINISHED
4.2 Otherwise, just return, Conversation will kick off the next step

NOTE: state will be mutated in-place.

<a id="openhands.sdk.agent.base.AgentBase.resolve_diff_from_deserialized"></a>

#### resolve\_diff\_from\_deserialized

```python
def resolve_diff_from_deserialized(persisted: "AgentBase") -> "AgentBase"
```

Return a new AgentBase instance equivalent to `persisted` but with
explicitly whitelisted fields (e.g. api_key, security_analyzer) taken from
`self`.

<a id="openhands.sdk.agent.base.AgentBase.model_dump_succint"></a>

#### model\_dump\_succint

```python
def model_dump_succint(**kwargs)
```

Like model_dump, but excludes None fields by default.

<a id="openhands.sdk.agent.base.AgentBase.get_all_llms"></a>

#### get\_all\_llms

```python
def get_all_llms() -> Generator[LLM, None, None]
```

Recursively yield unique *base-class* LLM objects reachable from `self`.

- Returns actual object references (not copies).
- De-dupes by `id(LLM)`.
- Cycle-safe via a visited set for *all* traversed objects.
- Only yields objects whose type is exactly `LLM` (no subclasses).
- Does not handle dataclasses.

<a id="openhands.sdk.agent.base.AgentBase.tools_map"></a>

#### tools\_map

```python
@property
def tools_map() -> dict[str, ToolDefinition]
```

Get the initialized tools map.

**Raises**:

- `RuntimeError` - If the agent has not been initialized.

<a id="openhands.sdk.agent"></a>

# openhands.sdk.agent

<a id="openhands.sdk.agent.agent"></a>

# openhands.sdk.agent.agent

<a id="openhands.sdk.mcp.tool"></a>

# openhands.sdk.mcp.tool

Utility functions for MCP integration.

<a id="openhands.sdk.mcp.tool.MCPToolExecutor"></a>

## MCPToolExecutor Objects

```python
class MCPToolExecutor(ToolExecutor)
```

Executor for MCP tools.

<a id="openhands.sdk.mcp.tool.MCPToolExecutor.__call__"></a>

#### \_\_call\_\_

```python
def __call__(
        action: MCPToolAction,
        conversation: "LocalConversation | None" = None) -> MCPToolObservation
```

Execute an MCP tool call.

<a id="openhands.sdk.mcp.tool.MCPToolDefinition"></a>

## MCPToolDefinition Objects

```python
class MCPToolDefinition(ToolDefinition[MCPToolAction, MCPToolObservation])
```

MCP Tool that wraps an MCP client and provides tool functionality.

<a id="openhands.sdk.mcp.tool.MCPToolDefinition.__call__"></a>

#### \_\_call\_\_

```python
def __call__(action: Action,
             conversation: "LocalConversation | None" = None) -> Observation
```

Execute the tool action using the MCP client.

We dynamically create a new MCPToolAction class with
the tool's input schema to validate the action.

**Arguments**:

- `action` - The action to execute.
  

**Returns**:

  The observation result from executing the action.

<a id="openhands.sdk.mcp.tool.MCPToolDefinition.action_from_arguments"></a>

#### action\_from\_arguments

```python
def action_from_arguments(arguments: dict[str, Any]) -> MCPToolAction
```

Create an MCPToolAction from parsed arguments with early validation.

We validate the raw arguments against the MCP tool's input schema here so
Agent._get_action_event can catch ValidationError and surface an
AgentErrorEvent back to the model instead of crashing later during tool
execution. On success, we return MCPToolAction with sanitized arguments.

**Arguments**:

- `arguments` - The parsed arguments from the tool call.
  

**Returns**:

  The MCPToolAction instance with data populated from the arguments.
  

**Raises**:

- `ValidationError` - If the arguments do not conform to the tool schema.

<a id="openhands.sdk.mcp.tool.MCPToolDefinition.to_openai_tool"></a>

#### to\_openai\_tool

```python
def to_openai_tool(
        add_security_risk_prediction: bool = False,
        action_type: type[Schema] | None = None) -> ChatCompletionToolParam
```

Convert a Tool to an OpenAI tool.

For MCP, we dynamically create the action_type (type: Schema)
from the MCP tool input schema, and pass it to the parent method.
It will use the .model_fields from this pydantic model to
generate the OpenAI-compatible tool schema.

**Arguments**:

- `add_security_risk_prediction` - Whether to add a `security_risk` field
  to the action schema for LLM to predict. This is useful for
  tools that may have safety risks, so the LLM can reason about
  the risk level before calling the tool.

<a id="openhands.sdk.mcp"></a>

# openhands.sdk.mcp

MCP (Model Context Protocol) integration for agent-sdk.

<a id="openhands.sdk.mcp.definition"></a>

# openhands.sdk.mcp.definition

MCPTool definition and implementation.

<a id="openhands.sdk.mcp.definition.MCPToolAction"></a>

## MCPToolAction Objects

```python
class MCPToolAction(Action)
```

Schema for MCP input action.

It is just a thin wrapper around raw JSON and does
not do any validation.

Validation will be performed by MCPTool.__call__
by constructing dynamically created Pydantic model
from the MCP tool input schema.

<a id="openhands.sdk.mcp.definition.MCPToolAction.to_mcp_arguments"></a>

#### to\_mcp\_arguments

```python
def to_mcp_arguments() -> dict
```

Return the data field as MCP tool call arguments.

This is used to convert this action to MCP tool call arguments.
The data field contains the dynamic fields from the tool call.

<a id="openhands.sdk.mcp.definition.MCPToolObservation"></a>

## MCPToolObservation Objects

```python
class MCPToolObservation(Observation)
```

Observation from MCP tool execution.

<a id="openhands.sdk.mcp.definition.MCPToolObservation.from_call_tool_result"></a>

#### from\_call\_tool\_result

```python
@classmethod
def from_call_tool_result(
        cls, tool_name: str,
        result: mcp.types.CallToolResult) -> "MCPToolObservation"
```

Create an MCPToolObservation from a CallToolResult.

<a id="openhands.sdk.mcp.definition.MCPToolObservation.to_llm_content"></a>

#### to\_llm\_content

```python
@property
def to_llm_content() -> Sequence[TextContent | ImageContent]
```

Format the observation for agent display.

<a id="openhands.sdk.mcp.definition.MCPToolObservation.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this observation.

<a id="openhands.sdk.mcp.utils"></a>

# openhands.sdk.mcp.utils

Utility functions for MCP integration.

<a id="openhands.sdk.mcp.utils.log_handler"></a>

#### log\_handler

```python
async def log_handler(message: LogMessage)
```

Handles incoming logs from the MCP server and forwards them
to the standard Python logging system.

<a id="openhands.sdk.mcp.utils.create_mcp_tools"></a>

#### create\_mcp\_tools

```python
def create_mcp_tools(config: dict | MCPConfig,
                     timeout: float = 30.0) -> list[MCPToolDefinition]
```

Create MCP tools from MCP configuration.

<a id="openhands.sdk.mcp.client"></a>

# openhands.sdk.mcp.client

Minimal sync helpers on top of fastmcp.Client, preserving original behavior.

<a id="openhands.sdk.mcp.client.MCPClient"></a>

## MCPClient Objects

```python
class MCPClient(AsyncMCPClient)
```

Behaves exactly like fastmcp.Client (same constructor & async API),
but owns a background event loop and offers:
  - call_async_from_sync(awaitable_or_fn, *args, timeout=None, **kwargs)
  - call_sync_from_async(fn, *args, **kwargs)  # await this from async code

<a id="openhands.sdk.mcp.client.MCPClient.call_async_from_sync"></a>

#### call\_async\_from\_sync

```python
def call_async_from_sync(awaitable_or_fn: Callable[..., Any] | Any, *args,
                         timeout: float, **kwargs) -> Any
```

Run a coroutine or async function on this client's loop from sync code.

Usage:
    mcp.call_async_from_sync(async_fn, arg1, kw=...)
    mcp.call_async_from_sync(coro)

<a id="openhands.sdk.mcp.client.MCPClient.call_sync_from_async"></a>

#### call\_sync\_from\_async

```python
async def call_sync_from_async(fn: Callable[..., Any], *args, **kwargs) -> Any
```

Await running a blocking function in the default threadpool from async code.

<a id="openhands.sdk.mcp.client.MCPClient.sync_close"></a>

#### sync\_close

```python
def sync_close() -> None
```

Synchronously close the MCP client and cleanup resources.

This will attempt to call the async close() method if available,
then shutdown the background event loop.

<a id="openhands.sdk.mcp.client.MCPClient.__del__"></a>

#### \_\_del\_\_

```python
def __del__()
```

Cleanup on deletion.

<a id="openhands.sdk.git.models"></a>

# openhands.sdk.git.models

<a id="openhands.sdk.git.git_diff"></a>

# openhands.sdk.git.git\_diff

Get git diff in a single git file for the closest git repo in the file system

<a id="openhands.sdk.git.git_diff.MAX_FILE_SIZE_FOR_GIT_DIFF"></a>

#### MAX\_FILE\_SIZE\_FOR\_GIT\_DIFF

1 Mb

<a id="openhands.sdk.git.git_diff.get_closest_git_repo"></a>

#### get\_closest\_git\_repo

```python
def get_closest_git_repo(path: Path) -> Path | None
```

Find the closest git repository by walking up the directory tree.

**Arguments**:

- `path` - Starting path to search from
  

**Returns**:

  Path to the git repository root, or None if not found

<a id="openhands.sdk.git.git_diff.get_git_diff"></a>

#### get\_git\_diff

```python
def get_git_diff(relative_file_path: str | Path) -> GitDiff
```

Get git diff for a single file.

**Arguments**:

- `relative_file_path` - Path to the file relative to current working directory
  

**Returns**:

  GitDiff object containing diff information
  

**Raises**:

- `GitPathError` - If file is too large or doesn't exist
- `GitRepositoryError` - If not in a git repository
- `GitCommandError` - If git commands fail

<a id="openhands.sdk.git.utils"></a>

# openhands.sdk.git.utils

<a id="openhands.sdk.git.utils.run_git_command"></a>

#### run\_git\_command

```python
def run_git_command(args: list[str], cwd: str | Path) -> str
```

Run a git command safely without shell injection vulnerabilities.

**Arguments**:

- `args` - List of command arguments (e.g., ['git', 'status', '--porcelain'])
- `cwd` - Working directory to run the command in
  

**Returns**:

  Command output as string
  

**Raises**:

- `GitCommandError` - If the git command fails

<a id="openhands.sdk.git.utils.get_valid_ref"></a>

#### get\_valid\_ref

```python
def get_valid_ref(repo_dir: str | Path) -> str | None
```

Get a valid git reference to compare against.

Tries multiple strategies to find a valid reference:
1. Current branch's origin (e.g., origin/main)
2. Default branch (e.g., origin/main, origin/master)
3. Merge base with default branch
4. Empty tree (for new repositories)

**Arguments**:

- `repo_dir` - Path to the git repository
  

**Returns**:

  Valid git reference hash, or None if no valid reference found

<a id="openhands.sdk.git.utils.validate_git_repository"></a>

#### validate\_git\_repository

```python
def validate_git_repository(repo_dir: str | Path) -> Path
```

Validate that the given directory is a git repository.

**Arguments**:

- `repo_dir` - Path to check
  

**Returns**:

  Validated Path object
  

**Raises**:

- `GitRepositoryError` - If not a valid git repository

<a id="openhands.sdk.git.exceptions"></a>

# openhands.sdk.git.exceptions

Git-related exceptions for OpenHands SDK.

<a id="openhands.sdk.git.exceptions.GitError"></a>

## GitError Objects

```python
class GitError(Exception)
```

Base exception for git-related errors.

<a id="openhands.sdk.git.exceptions.GitRepositoryError"></a>

## GitRepositoryError Objects

```python
class GitRepositoryError(GitError)
```

Exception raised when git repository operations fail.

<a id="openhands.sdk.git.exceptions.GitCommandError"></a>

## GitCommandError Objects

```python
class GitCommandError(GitError)
```

Exception raised when git command execution fails.

<a id="openhands.sdk.git.exceptions.GitPathError"></a>

## GitPathError Objects

```python
class GitPathError(GitError)
```

Exception raised when git path operations fail.

<a id="openhands.sdk.git.git_changes"></a>

# openhands.sdk.git.git\_changes

Get git changes in the current working directory relative to the remote origin
if possible.

<a id="openhands.sdk.git.git_changes.get_changes_in_repo"></a>

#### get\_changes\_in\_repo

```python
def get_changes_in_repo(repo_dir: str | Path) -> list[GitChange]
```

Get git changes in a repository relative to the origin default branch.

This is different from `git status` as it compares against the remote branch
rather than the staging area.

**Arguments**:

- `repo_dir` - Path to the git repository
  

**Returns**:

  List of GitChange objects representing the changes
  

**Raises**:

- `GitRepositoryError` - If the directory is not a valid git repository
- `GitCommandError` - If git commands fail

<a id="openhands.sdk.io.base"></a>

# openhands.sdk.io.base

<a id="openhands.sdk.io.base.FileStore"></a>

## FileStore Objects

```python
class FileStore(ABC)
```

Abstract base class for file storage operations.

This class defines the interface for file storage backends that can
handle basic file operations like reading, writing, listing, and deleting files.

<a id="openhands.sdk.io.base.FileStore.write"></a>

#### write

```python
@abstractmethod
def write(path: str, contents: str | bytes) -> None
```

Write contents to a file at the specified path.

**Arguments**:

- `path` - The file path where contents should be written.
- `contents` - The data to write, either as string or bytes.

<a id="openhands.sdk.io.base.FileStore.read"></a>

#### read

```python
@abstractmethod
def read(path: str) -> str
```

Read and return the contents of a file as a string.

**Arguments**:

- `path` - The file path to read from.
  

**Returns**:

  The file contents as a string.

<a id="openhands.sdk.io.base.FileStore.list"></a>

#### list

```python
@abstractmethod
def list(path: str) -> list[str]
```

List all files and directories at the specified path.

**Arguments**:

- `path` - The directory path to list contents from.
  

**Returns**:

  A list of file and directory names in the specified path.

<a id="openhands.sdk.io.base.FileStore.delete"></a>

#### delete

```python
@abstractmethod
def delete(path: str) -> None
```

Delete the file or directory at the specified path.

**Arguments**:

- `path` - The file or directory path to delete.

<a id="openhands.sdk.io"></a>

# openhands.sdk.io

<a id="openhands.sdk.io.local"></a>

# openhands.sdk.io.local

<a id="openhands.sdk.io.memory"></a>

# openhands.sdk.io.memory

<a id="openhands.sdk.event.condenser"></a>

# openhands.sdk.event.condenser

<a id="openhands.sdk.event.condenser.Condensation"></a>

## Condensation Objects

```python
class Condensation(Event)
```

This action indicates a condensation of the conversation history is happening.

<a id="openhands.sdk.event.condenser.CondensationRequest"></a>

## CondensationRequest Objects

```python
class CondensationRequest(Event)
```

This action is used to request a condensation of the conversation history.

**Attributes**:

- `action` _str_ - The action type, namely ActionType.CONDENSATION_REQUEST.

<a id="openhands.sdk.event.condenser.CondensationSummaryEvent"></a>

## CondensationSummaryEvent Objects

```python
class CondensationSummaryEvent(LLMConvertibleEvent)
```

This event represents a summary generated by a condenser.

<a id="openhands.sdk.event.condenser.CondensationSummaryEvent.summary"></a>

#### summary

The summary text.

<a id="openhands.sdk.event.types"></a>

# openhands.sdk.event.types

<a id="openhands.sdk.event.types.EventID"></a>

#### EventID

Type alias for event IDs.

<a id="openhands.sdk.event.types.ToolCallID"></a>

#### ToolCallID

Type alias for tool call IDs.

<a id="openhands.sdk.event.base"></a>

# openhands.sdk.event.base

<a id="openhands.sdk.event.base.Event"></a>

## Event Objects

```python
class Event(DiscriminatedUnionMixin, ABC)
```

Base class for all events.

<a id="openhands.sdk.event.base.Event.timestamp"></a>

#### timestamp

consistent with V1

<a id="openhands.sdk.event.base.Event.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

<a id="openhands.sdk.event.base.Event.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation for display.

<a id="openhands.sdk.event.base.Event.__repr__"></a>

#### \_\_repr\_\_

```python
def __repr__() -> str
```

Developer-friendly representation.

<a id="openhands.sdk.event.base.LLMConvertibleEvent"></a>

## LLMConvertibleEvent Objects

```python
class LLMConvertibleEvent(Event, ABC)
```

Base class for events that can be converted to LLM messages.

<a id="openhands.sdk.event.base.LLMConvertibleEvent.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation showing LLM message content.

<a id="openhands.sdk.event.base.LLMConvertibleEvent.events_to_messages"></a>

#### events\_to\_messages

```python
@staticmethod
def events_to_messages(events: list["LLMConvertibleEvent"]) -> list[Message]
```

Convert event stream to LLM message stream, handling multi-action batches

<a id="openhands.sdk.event"></a>

# openhands.sdk.event

<a id="openhands.sdk.event.llm_convertible.action"></a>

# openhands.sdk.event.llm\_convertible.action

<a id="openhands.sdk.event.llm_convertible.action.ActionEvent"></a>

## ActionEvent Objects

```python
class ActionEvent(LLMConvertibleEvent)
```

<a id="openhands.sdk.event.llm_convertible.action.ActionEvent.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this action event.

<a id="openhands.sdk.event.llm_convertible.action.ActionEvent.to_llm_message"></a>

#### to\_llm\_message

```python
def to_llm_message() -> Message
```

Individual message - may be incomplete for multi-action batches

<a id="openhands.sdk.event.llm_convertible.action.ActionEvent.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation for ActionEvent.

<a id="openhands.sdk.event.llm_convertible"></a>

# openhands.sdk.event.llm\_convertible

<a id="openhands.sdk.event.llm_convertible.observation"></a>

# openhands.sdk.event.llm\_convertible.observation

<a id="openhands.sdk.event.llm_convertible.observation.ObservationBaseEvent"></a>

## ObservationBaseEvent Objects

```python
class ObservationBaseEvent(LLMConvertibleEvent)
```

Base class for anything as a response to a tool call.

Examples include tool execution, error, user reject.

<a id="openhands.sdk.event.llm_convertible.observation.ObservationEvent"></a>

## ObservationEvent Objects

```python
class ObservationEvent(ObservationBaseEvent)
```

<a id="openhands.sdk.event.llm_convertible.observation.ObservationEvent.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this observation event.

<a id="openhands.sdk.event.llm_convertible.observation.ObservationEvent.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation for ObservationEvent.

<a id="openhands.sdk.event.llm_convertible.observation.UserRejectObservation"></a>

## UserRejectObservation Objects

```python
class UserRejectObservation(ObservationBaseEvent)
```

Observation when user rejects an action in confirmation mode.

<a id="openhands.sdk.event.llm_convertible.observation.UserRejectObservation.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this user rejection event.

<a id="openhands.sdk.event.llm_convertible.observation.UserRejectObservation.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation for UserRejectObservation.

<a id="openhands.sdk.event.llm_convertible.observation.AgentErrorEvent"></a>

## AgentErrorEvent Objects

```python
class AgentErrorEvent(ObservationBaseEvent)
```

Error triggered by the agent.

Note: This event should not contain model "thought" or "reasoning_content". It
represents an error produced by the agent/scaffold, not model output.

<a id="openhands.sdk.event.llm_convertible.observation.AgentErrorEvent.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this agent error event.

<a id="openhands.sdk.event.llm_convertible.observation.AgentErrorEvent.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation for AgentErrorEvent.

<a id="openhands.sdk.event.llm_convertible.message"></a>

# openhands.sdk.event.llm\_convertible.message

<a id="openhands.sdk.event.llm_convertible.message.MessageEvent"></a>

## MessageEvent Objects

```python
class MessageEvent(LLMConvertibleEvent)
```

Message from either agent or user.

This is originally the "MessageAction", but it suppose not to be tool call.

<a id="openhands.sdk.event.llm_convertible.message.MessageEvent.thinking_blocks"></a>

#### thinking\_blocks

```python
@property
def thinking_blocks() -> Sequence[ThinkingBlock | RedactedThinkingBlock]
```

Return the Anthropic thinking blocks from the LLM message.

<a id="openhands.sdk.event.llm_convertible.message.MessageEvent.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this message event.

<a id="openhands.sdk.event.llm_convertible.message.MessageEvent.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation for MessageEvent.

<a id="openhands.sdk.event.llm_convertible.system"></a>

# openhands.sdk.event.llm\_convertible.system

<a id="openhands.sdk.event.llm_convertible.system.SystemPromptEvent"></a>

## SystemPromptEvent Objects

```python
class SystemPromptEvent(LLMConvertibleEvent)
```

System prompt added by the agent.

<a id="openhands.sdk.event.llm_convertible.system.SystemPromptEvent.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this system prompt event.

<a id="openhands.sdk.event.llm_convertible.system.SystemPromptEvent.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation for SystemPromptEvent.

<a id="openhands.sdk.event.conversation_state"></a>

# openhands.sdk.event.conversation\_state

Events related to conversation state updates.

<a id="openhands.sdk.event.conversation_state.ConversationStateUpdateEvent"></a>

## ConversationStateUpdateEvent Objects

```python
class ConversationStateUpdateEvent(Event)
```

Event that contains conversation state updates.

This event is sent via websocket whenever the conversation state changes,
allowing remote clients to stay in sync without making REST API calls.

All fields are serialized versions of the corresponding ConversationState fields
to ensure compatibility with websocket transmission.

<a id="openhands.sdk.event.conversation_state.ConversationStateUpdateEvent.from_conversation_state"></a>

#### from\_conversation\_state

```python
@classmethod
def from_conversation_state(
        cls, state: "ConversationState") -> "ConversationStateUpdateEvent"
```

Create a state update event from a ConversationState object.

This creates an event containing a snapshot of important state fields.

**Arguments**:

- `state` - The ConversationState to serialize
- `conversation_id` - The conversation ID for the event
  

**Returns**:

  A ConversationStateUpdateEvent with serialized state data

<a id="openhands.sdk.event.user_action"></a>

# openhands.sdk.event.user\_action

<a id="openhands.sdk.event.user_action.PauseEvent"></a>

## PauseEvent Objects

```python
class PauseEvent(Event)
```

Event indicating that the agent execution was paused by user request.

<a id="openhands.sdk.event.user_action.PauseEvent.visualize"></a>

#### visualize

```python
@property
def visualize() -> Text
```

Return Rich Text representation of this pause event.

<a id="openhands.sdk.event.user_action.PauseEvent.__str__"></a>

#### \_\_str\_\_

```python
def __str__() -> str
```

Plain text string representation for PauseEvent.

