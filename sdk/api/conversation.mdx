---
title: Conversation
description: API reference for openhands.sdk.conversation
---

# Conversation

**Source:** [`openhands/sdk/conversation/`](https://github.com/OpenHands/software-agent-sdk/tree/main/openhands-sdk/openhands/sdk/conversation/)

---

## Classes

### `ConversationStateProtocol`

Protocol defining the interface for conversation state objects.

#### Methods

##### `id(self) -> ConversationID`

The conversation ID.

##### `events(self) -> EventsListBase`

Access to the events list.

##### `agent_status(self) -> 'AgentExecutionStatus'`

The current agent execution status.

##### `confirmation_policy(self) -> ConfirmationPolicyBase`

The confirmation policy.

##### `activated_knowledge_skills(self) -> list[str]`

List of activated knowledge skills.

##### `workspace(self) -> BaseWorkspace`

The workspace for agent operations and tool execution.

##### `persistence_dir(self) -> str | None`

The persistence directory from the FileStore.

If None, it means the conversation is not being persisted.

##### `agent(self) -> 'AgentBase'`

The agent running in the conversation.

---

### `BaseConversation`

#### Methods

##### `id(self) -> ConversationID`

##### `state(self) -> ConversationStateProtocol`

##### `conversation_stats(self) -> ConversationStats`

##### `send_message(self, message: str | Message) -> None`

##### `run(self) -> None`

##### `set_confirmation_policy(self, policy: ConfirmationPolicyBase) -> None`

##### `confirmation_policy_active(self) -> bool`

##### `is_confirmation_mode_active(self) -> bool`

Check if confirmation mode is active.

Returns True if BOTH conditions are met:
1. The agent has a security analyzer set (not None)
2. The confirmation policy is active

##### `reject_pending_actions(self, reason: str) -> None`

##### `pause(self) -> None`

##### `update_secrets(self, secrets: Mapping[str, SecretValue]) -> None`

##### `close(self) -> None`

##### `generate_title(self, llm: LLM | None, max_length: int) -> str`

Generate a title for the conversation based on the first user message.


**Parameters:**

llm: Optional LLM to use for title generation. If not provided,
uses the agent's LLM.
max_length: Maximum length of the generated title.


**Returns:**

A generated title for the conversation.


**Raises:**

ValueError: If no user messages are found in the conversation.

##### `get_persistence_dir(persistence_base_dir: str, conversation_id: ConversationID) -> str`

Get the persistence directory for the conversation.

##### `compose_callbacks(callbacks: Iterable[ConversationCallbackType]) -> ConversationCallbackType`

Compose multiple callbacks into a single callback function.


**Parameters:**

callbacks: An iterable of callback functions


**Returns:**

A single callback function that calls all provided callbacks

---

### `Conversation`

Factory entrypoint that returns a LocalConversation or RemoteConversation.

Usage:
- Conversation(agent=...) -> LocalConversation
- Conversation(agent=..., host="http://...") -> RemoteConversation

---

### `ConversationStats`

Track per-LLM usage metrics observed during conversations.

#### Methods

##### `service_to_metrics(self) -> dict[str, Metrics]`

##### `service_to_metrics(self, value: dict[str, Metrics]) -> None`

##### `get_combined_metrics(self) -> Metrics`

##### `get_metrics_for_usage(self, usage_id: str) -> Metrics`

##### `get_metrics_for_service(self, service_id: str) -> Metrics`

##### `register_llm(self, event: RegistryEvent)`

---

### `EventLog`

#### Methods

##### `__init__(self, fs: FileStore, dir_path: str) -> None`

##### `get_index(self, event_id: EventID) -> int`

Return the integer index for a given event_id.

##### `get_id(self, idx: int) -> EventID`

Return the event_id for a given index.

##### `append(self, event: Event) -> None`

---

### `EventsListBase`

Abstract base class for event lists that can be appended to.

This provides a common interface for both local EventLog and remote
RemoteEventsList implementations, avoiding circular imports in protocols.

#### Methods

##### `append(self, event: Event) -> None`

Add a new event to the list.

---

### `ConversationRunError`

Raised when a conversation run fails.

Carries the conversation_id to make resuming/debugging easier while
preserving the original exception via exception chaining.

#### Methods

##### `__init__(self, conversation_id: ConversationID, original_exception: BaseException, message: str | None) -> None`

---

### `FIFOLock`

A reentrant lock that guarantees FIFO (first-in-first-out) access ordering.

Unlike Python's standard RLock, this lock ensures that threads acquire
the lock in the exact order they requested it, providing fairness and
preventing lock starvation.

Features:
- Reentrant: Same thread can acquire multiple times
- FIFO ordering: Threads get lock in request order
- Context manager support: Use with 'with' statement
- Thread-safe: Safe for concurrent access

#### Methods

##### `__init__(self) -> None`

##### `acquire(self, blocking: bool, timeout: float) -> bool`

Acquire the lock.


**Parameters:**

blocking: If True, block until lock is acquired. If False, return
immediately.
timeout: Maximum time to wait for lock (ignored if blocking=False).
-1 means wait indefinitely.


**Returns:**

True if lock was acquired, False otherwise.

##### `release(self) -> None`

Release the lock.


**Raises:**

RuntimeError: If the current thread doesn't own the lock.

##### `locked(self) -> bool`

Return True if the lock is currently held by any thread.

##### `owned(self) -> bool`

Return True if the lock is currently held by the calling thread.

---

### `SecretRegistry`

Manages secrets and injects them into bash commands when needed.

The secret registry stores a mapping of secret keys to SecretSources
that retrieve the actual secret values. When a bash command is about to be
executed, it scans the command for any secret keys and injects the corresponding
environment variables.

Secret sources will redact / encrypt their sensitive values as appropriate when
serializing, depending on the content of the context. If a context is present
and contains a 'cipher' object, this is used for encryption. If it contains a
boolean 'expose_secrets' flag set to True, secrets are dunped in plain text.
Otherwise secrets are redacted.

Additionally, it tracks the latest exported values to enable consistent masking
even when callable secrets fail on subsequent calls.

#### Methods

##### `update_secrets(self, secrets: Mapping[str, SecretValue]) -> None`

Add or update secrets in the manager.


**Parameters:**

secrets: Dictionary mapping secret keys to either string values
or callable functions that return string values

##### `find_secrets_in_text(self, text: str) -> set[str]`

Find all secret keys mentioned in the given text.


**Parameters:**

text: The text to search for secret keys


**Returns:**

Set of secret keys found in the text

##### `get_secrets_as_env_vars(self, command: str) -> dict[str, str]`

Get secrets that should be exported as environment variables for a command.


**Parameters:**

command: The bash command to check for secret references


**Returns:**

Dictionary of environment variables to export (key -> value)

##### `mask_secrets_in_output(self, text: str) -> str`

Mask secret values in the given text.

This method uses both the current exported values and attempts to get
fresh values from callables to ensure comprehensive masking.


**Parameters:**

text: The text to mask secrets in


**Returns:**

Text with secret values replaced by <secret-hidden>

---

### `SecretSource`

Source for a named secret which may be obtained dynamically

#### Methods

##### `get_value(self) -> str | None`

Get the value of a secret in plain text

---

### `StaticSecret`

A secret stored locally

#### Methods

##### `get_value(self)`

---

### `LookupSecret`

A secret looked up from some external url

#### Methods

##### `get_value(self)`

---

### `AgentExecutionStatus`

Enum representing the current execution state of the agent.

---

### `ConversationState`

#### Methods

##### `events(self) -> EventLog`

##### `set_on_state_change(self, callback: ConversationCallbackType | None) -> None`

Set a callback to be called when state changes.


**Parameters:**

callback: A function that takes an Event (ConversationStateUpdateEvent)
or None to remove the callback

##### `create(cls: type['ConversationState'], id: ConversationID, agent: AgentBase, workspace: BaseWorkspace, persistence_dir: str | None, max_iterations: int, stuck_detection: bool) -> 'ConversationState'`

If base_state.json exists: resume (attach EventLog,
reconcile agent, enforce id).
Else: create fresh (agent required), persist base, and return.

##### `get_unmatched_actions(events: Sequence[Event]) -> list[ActionEvent]`

Find actions in the event history that don't have matching observations.

This method identifies ActionEvents that don't have corresponding
ObservationEvents or UserRejectObservations, which typically indicates
actions that are pending confirmation or execution.


**Parameters:**

events: List of events to search through


**Returns:**

List of ActionEvent objects that don't have corresponding observations,
in chronological order

##### `acquire(self, blocking: bool, timeout: float) -> bool`

Acquire the lock.


**Parameters:**

blocking: If True, block until lock is acquired. If False, return
immediately.
timeout: Maximum time to wait for lock (ignored if blocking=False).
-1 means wait indefinitely.


**Returns:**

True if lock was acquired, False otherwise.

##### `release(self) -> None`

Release the lock.


**Raises:**

RuntimeError: If the current thread doesn't own the lock.

##### `locked(self) -> bool`

Return True if the lock is currently held by any thread.

##### `owned(self) -> bool`

Return True if the lock is currently held by the calling thread.

---

### `StuckDetector`

Detects when an agent is stuck in repetitive or unproductive patterns.

This detector analyzes the conversation history to identify various stuck patterns:
1. Repeating action-observation cycles
2. Repeating action-error cycles
3. Agent monologue (repeated messages without user input)
4. Repeating alternating action-observation patterns
5. Context window errors indicating memory issues

#### Methods

##### `__init__(self, state: ConversationState)`

##### `is_stuck(self) -> bool`

Check if the agent is currently stuck.

---

### `ConversationVisualizer`

Handles visualization of conversation events with Rich formatting.

Provides Rich-formatted output with panels and complete content display.

#### Methods

##### `__init__(self, highlight_regex: dict[str, str] | None, skip_user_messages: bool, conversation_stats: 'ConversationStats | None', name_for_visualization: str | None)`

Initialize the visualizer.


**Parameters:**

highlight_regex: Dictionary mapping regex patterns to Rich color styles
for highlighting keywords in the visualizer.
For example: {"Reasoning:": "bold blue",
"Thought:": "bold green"}
skip_user_messages: If True, skip displaying user messages. Useful for
scenarios where user input is not relevant to show.
conversation_stats: ConversationStats object to display metrics information.
name_for_visualization: Optional name to prefix in panel titles to identify
which agent/conversation is speaking.

##### `on_event(self, event: Event) -> None`

Main event handler that displays events with Rich formatting.

---

## Functions

### `get_agent_final_response(events: Sequence[Event]) -> str`

Extract the final response from the agent.

An agent can end a conversation in two ways:
1. By calling the finish tool
2. By returning a text message with no tool calls


**Parameters:**

events: List of conversation events to search through.


**Returns:**

The final response message from the agent, or empty string if not found.

---

### `extract_first_user_message(events: Sequence[Event]) -> str | None`

Extract the first user message from conversation events.


**Parameters:**

events: List of conversation events.


**Returns:**

The first user message text, or None if no user message is found.

---

### `generate_title_with_llm(message: str, llm: LLM, max_length: int) -> str | None`

Generate a conversation title using LLM.


**Parameters:**

message: The first user message to generate title from.
llm: The LLM to use for title generation.
max_length: Maximum length of the generated title.


**Returns:**

Generated title, or None if LLM fails or returns empty response.

---

### `generate_fallback_title(message: str, max_length: int) -> str`

Generate a fallback title by truncating the first user message.


**Parameters:**

message: The first user message.
max_length: Maximum length of the title.


**Returns:**

A truncated title.

---

### `generate_conversation_title(events: Sequence[Event], llm: LLM | None, max_length: int) -> str`

Generate a title for a conversation based on the first user message.

This is the main utility function that orchestrates the title generation process:
1. Extract the first user message from events
2. Try to generate title using LLM
3. Fall back to simple truncation if LLM fails


**Parameters:**

events: List of conversation events.
llm: Optional LLM to use for title generation.
max_length: Maximum length of the generated title.


**Returns:**

A generated title for the conversation.


**Raises:**

ValueError: If no user messages are found in the conversation events.

---

### `create_default_visualizer(highlight_regex: dict[str, str] | None, conversation_stats: 'ConversationStats | None', name_for_visualization: str | None) -> ConversationVisualizer`

Create a default conversation visualizer instance.


**Parameters:**

highlight_regex: Dictionary mapping regex patterns to Rich color styles
for highlighting keywords in the visualizer.
For example: {"Reasoning:": "bold blue",
"Thought:": "bold green"}
conversation_stats: ConversationStats object to display metrics information.
name_for_visualization: Optional name to prefix in panel titles to identify
which agent/conversation is speaking.

---

