---
title: Tool
description: API reference for openhands.sdk.tool
---

# Tool

OpenHands runtime package.

**Source:** [`openhands/sdk/tool/`](https://github.com/OpenHands/software-agent-sdk/tree/main/openhands-sdk/openhands/sdk/tool/)

---

## Classes

### `Schema`

Base schema for input action / output observation.

#### Methods

##### `to_mcp_schema(cls) -> dict[str, Any]`

Convert to JSON schema format compatible with MCP.

##### `from_mcp_schema(cls: type[S], model_name: str, schema: dict[str, Any]) -> type['S']`

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

---

### `Action`

Base schema for input action.

#### Methods

##### `visualize(self) -> Text`

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

---

### `Observation`

Base schema for output observation.

#### Methods

##### `to_llm_content(self) -> Sequence[TextContent | ImageContent]`

Get the observation string to show to the agent.

##### `visualize(self) -> Text`

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

---

### `Tool`

Defines a tool to be initialized for the agent.

This is only used in agent-sdk for type schema for server use.

#### Methods

##### `validate_name(cls, v: str) -> str`

Validate that name is not empty.

##### `validate_params(cls, v: dict[str, Any] | None) -> dict[str, Any]`

Convert None params to empty dict.

---

### `ToolAnnotations`

Annotations to provide hints about the tool's behavior.

Based on Model Context Protocol (MCP) spec:
https://github.com/modelcontextprotocol/modelcontextprotocol/blob/caf3424488b10b4a7b1f8cb634244a450a1f4400/schema/2025-06-18/schema.ts#L838

---

### `ToolExecutor`

Executor function type for a Tool.

#### Methods

##### `close(self) -> None`

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

---

### `ExecutableTool`

Protocol for tools that are guaranteed to have a non-None executor.

This eliminates the need for runtime None checks and type narrowing
when working with tools that are known to be executable.

---

### `ToolBase`

Tool that wraps an executor function with input/output validation and schema.

- Normalize input/output schemas (class or dict) into both model+schema.
- Validate inputs before execute.
- Coerce outputs only if an output model is defined; else return vanilla JSON.
- Export MCP tool description.

#### Methods

##### `create(cls) -> Sequence[Self]`

Create a sequence of Tool instances. Placeholder for subclasses.

This can be overridden in subclasses to provide custom initialization logic
(e.g., typically initializing the executor with parameters).


**Returns:**

A sequence of Tool instances. Even single tools are returned as a sequence
to provide a consistent interface and eliminate union return types.

##### `title(self) -> str`

##### `set_executor(self, executor: ToolExecutor) -> Self`

Create a new Tool instance with the given executor.

##### `as_executable(self) -> ExecutableTool`

Return this tool as an ExecutableTool, ensuring it has an executor.

This method eliminates the need for runtime None checks by guaranteeing
that the returned tool has a non-None executor.


**Returns:**

This tool instance, typed as ExecutableTool.


**Raises:**

NotImplementedError: If the tool has no executor.

##### `action_from_arguments(self, arguments: dict[str, Any]) -> Action`

Create an action from parsed arguments.

This method can be overridden by subclasses to provide custom logic
for creating actions from arguments (e.g., for MCP tools).


**Parameters:**

arguments: The parsed arguments from the tool call.


**Returns:**

The action instance created from the arguments.

##### `to_mcp_tool(self, input_schema: dict[str, Any] | None, output_schema: dict[str, Any] | None) -> dict[str, Any]`

Convert a Tool to an MCP tool definition.

Allow overriding input/output schemas (usually by subclasses).


**Parameters:**

input_schema: Optionally override the input schema.
output_schema: Optionally override the output schema.

##### `to_openai_tool(self, add_security_risk_prediction: bool, action_type: type[Schema] | None) -> ChatCompletionToolParam`

Convert a Tool to an OpenAI tool.


**Parameters:**

add_security_risk_prediction: Whether to add a `security_risk` field
to the action schema for LLM to predict. This is useful for
tools that may have safety risks, so the LLM can reason about
the risk level before calling the tool.
action_type: Optionally override the action_type to use for the schema.
This is useful for MCPTool to use a dynamically created action type
based on the tool's input schema.

##### `to_responses_tool(self, add_security_risk_prediction: bool, action_type: type[Schema] | None) -> FunctionToolParam`

Convert a Tool to a Responses API function tool (LiteLLM typed).

For Responses API, function tools expect top-level keys:
{ "type": "function", "name": ..., "description": ..., "parameters": ... }

##### `resolve_kind(cls, kind: str) -> type`

---

### `ToolDefinition`

Concrete tool class that inherits from ToolBase.

This class serves as a concrete implementation of ToolBase for cases where
you want to create a tool instance directly without implementing a custom
subclass. Built-in tools (like FinishTool, ThinkTool) are instantiated
directly from this class, while more complex tools (like BashTool,
FileEditorTool) inherit from this class and provide their own create()
method implementations.

#### Methods

##### `create(cls) -> Sequence[Self]`

Create a sequence of ToolDefinition instances.

TODO https://github.com/OpenHands/agent-sdk/issues/493
Refactor this - the ToolDefinition class should not have a concrete create()
implementation. Built-in tools should be refactored to not rely on this
method, and then this should be made abstract with @abstractmethod.

---

## Functions

### `register_tool(name: str, factory: ToolDefinition | type[ToolBase] | Callable[..., Sequence[ToolDefinition]]) -> None`

---

### `resolve_tool(tool_spec: Tool, conv_state: 'ConversationState') -> Sequence[ToolDefinition]`

---

### `list_registered_tools() -> list[str]`

---

### `py_type(spec: dict[str, Any]) -> Any`

Map JSON schema types to Python types.

---

