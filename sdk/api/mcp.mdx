---
title: Mcp
description: API reference for openhands.sdk.mcp
---

# Mcp

MCP (Model Context Protocol) integration for agent-sdk.

**Source:** [`openhands/sdk/mcp/`](https://github.com/OpenHands/software-agent-sdk/tree/main/openhands-sdk/openhands/sdk/mcp/)

---

## Classes

### `MCPClient`

Behaves exactly like fastmcp.Client (same constructor & async API),
but owns a background event loop and offers:
- call_async_from_sync(awaitable_or_fn, *args, timeout=None, **kwargs)
- call_sync_from_async(fn, *args, **kwargs)  # await this from async code

#### Methods

##### `__init__(self)`

##### `call_async_from_sync(self, awaitable_or_fn: Callable[..., Any] | Any) -> Any`

Run a coroutine or async function on this client's loop from sync code.

Usage:
mcp.call_async_from_sync(async_fn, arg1, kw=...)
mcp.call_async_from_sync(coro)

##### `sync_close(self) -> None`

Synchronously close the MCP client and cleanup resources.

This will attempt to call the async close() method if available,
then shutdown the background event loop.

---

### `MCPToolAction`

Schema for MCP input action.

It is just a thin wrapper around raw JSON and does
not do any validation.

Validation will be performed by MCPTool.__call__
by constructing dynamically created Pydantic model
from the MCP tool input schema.

#### Methods

##### `to_mcp_arguments(self) -> dict`

Return the data field as MCP tool call arguments.

This is used to convert this action to MCP tool call arguments.
The data field contains the dynamic fields from the tool call.

---

### `MCPToolObservation`

Observation from MCP tool execution.

#### Methods

##### `from_call_tool_result(cls, tool_name: str, result: mcp.types.CallToolResult) -> 'MCPToolObservation'`

Create an MCPToolObservation from a CallToolResult.

##### `to_llm_content(self) -> Sequence[TextContent | ImageContent]`

Format the observation for agent display.

##### `visualize(self) -> Text`

Return Rich Text representation of this observation.

---

### `MCPToolExecutor`

Executor for MCP tools.

#### Methods

##### `__init__(self, tool_name: str, client: MCPClient)`

---

### `MCPToolDefinition`

MCP Tool that wraps an MCP client and provides tool functionality.

#### Methods

##### `action_from_arguments(self, arguments: dict[str, Any]) -> MCPToolAction`

Create an MCPToolAction from parsed arguments with early validation.

We validate the raw arguments against the MCP tool's input schema here so
Agent._get_action_event can catch ValidationError and surface an
AgentErrorEvent back to the model instead of crashing later during tool
execution. On success, we return MCPToolAction with sanitized arguments.


**Parameters:**

arguments: The parsed arguments from the tool call.


**Returns:**

The MCPToolAction instance with data populated from the arguments.


**Raises:**

ValidationError: If the arguments do not conform to the tool schema.

##### `create(cls, mcp_tool: mcp.types.Tool, mcp_client: MCPClient) -> Sequence['MCPToolDefinition']`

##### `to_mcp_tool(self, input_schema: dict[str, Any] | None, output_schema: dict[str, Any] | None) -> dict[str, Any]`

##### `to_openai_tool(self, add_security_risk_prediction: bool, action_type: type[Schema] | None) -> ChatCompletionToolParam`

Convert a Tool to an OpenAI tool.

For MCP, we dynamically create the action_type (type: Schema)
from the MCP tool input schema, and pass it to the parent method.
It will use the .model_fields from this pydantic model to
generate the OpenAI-compatible tool schema.


**Parameters:**

add_security_risk_prediction: Whether to add a `security_risk` field
to the action schema for LLM to predict. This is useful for
tools that may have safety risks, so the LLM can reason about
the risk level before calling the tool.

---

## Functions

### `to_camel_case(s: str) -> str`

---

### `create_mcp_tools(config: dict | MCPConfig, timeout: float) -> list[MCPToolDefinition]`

Create MCP tools from MCP configuration.

---

