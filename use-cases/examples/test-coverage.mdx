---
title: "Test Coverage"
sidebarTitle: "Test Coverage"
description: "Using OpenHands to improve test coverage"
---

# Improving Test Coverage

OpenHands can systematically add tests to your codebase, improving reliability and enabling safe refactoring.

## When to Use This

- **Legacy code** without tests
- **New features** needing test coverage
- **Critical paths** requiring additional verification
- **Pre-refactoring** to ensure behavior is captured

## Test Types

### Unit Tests

Test individual functions or methods in isolation.

```markdown
Add unit tests for the validateEmail() function in src/utils/validation.js

Test cases:
1. Valid email formats (user@domain.com)
2. Invalid formats (missing @, invalid TLD)
3. Edge cases (empty string, null, undefined)
4. International characters
```

### Integration Tests

Test component interactions.

```markdown
Add integration tests for the user registration flow.

Test the complete path:
1. POST /api/register with valid data
2. Verify user created in database
3. Verify welcome email sent
4. Verify response structure
```

### Component Tests (Frontend)

Test UI components.

```markdown
Add tests for the LoginForm component.

Test:
1. Renders all required fields
2. Shows validation errors on submit with empty fields
3. Calls onSubmit with form data when valid
4. Disables submit button while loading
```

## Instruction Templates

### Unit Test Template

```markdown
Add unit tests for [function/class] in [file].

Location: [test file path]
Framework: [jest/pytest/etc]
Follow pattern in: [example test file]

Test cases:
1. [Happy path description]
2. [Error case 1]
3. [Error case 2]
4. [Edge case]

Coverage target: [X]%
```

### Integration Test Template

```markdown
Add integration tests for [feature/endpoint].

Location: [test file path]
Setup: [database/mocks needed]

Test scenarios:
1. [Scenario 1 - expected flow]
2. [Scenario 2 - error handling]
3. [Scenario 3 - edge case]

Assertions:
- [What to verify]
```

## Example: Adding Unit Tests

### Task

```markdown
Add unit tests for the OrderCalculator class.

File: tests/unit/test_order_calculator.py
Class: src/services/order_calculator.py

Test cases for calculate_total():
1. Single item order
2. Multiple items
3. Empty order (should return 0)
4. Order with discount code
5. Order with quantity > 1 of same item

Test cases for apply_discount():
1. Valid percentage discount
2. Valid fixed amount discount
3. Invalid discount code (should raise)
4. Expired discount (should raise)

Use pytest fixtures from conftest.py for test data.
Mock the DiscountService for discount tests.
```

### Output

```python
import pytest
from unittest.mock import Mock, patch
from src.services.order_calculator import OrderCalculator
from src.models import Order, OrderItem


class TestOrderCalculator:
    @pytest.fixture
    def calculator(self):
        return OrderCalculator()

    @pytest.fixture
    def sample_items(self):
        return [
            OrderItem(product_id=1, price=10.00, quantity=1),
            OrderItem(product_id=2, price=25.00, quantity=2),
        ]

    def test_calculate_total_single_item(self, calculator):
        items = [OrderItem(product_id=1, price=10.00, quantity=1)]
        assert calculator.calculate_total(items) == 10.00

    def test_calculate_total_multiple_items(self, calculator, sample_items):
        # 10 + (25 * 2) = 60
        assert calculator.calculate_total(sample_items) == 60.00

    def test_calculate_total_empty_order(self, calculator):
        assert calculator.calculate_total([]) == 0.00

    @patch('src.services.order_calculator.DiscountService')
    def test_apply_discount_percentage(self, mock_discount, calculator):
        mock_discount.get_discount.return_value = {
            'type': 'percentage',
            'value': 10
        }
        result = calculator.apply_discount(100.00, 'SAVE10')
        assert result == 90.00

    @patch('src.services.order_calculator.DiscountService')
    def test_apply_discount_invalid_code(self, mock_discount, calculator):
        mock_discount.get_discount.side_effect = ValueError('Invalid code')
        with pytest.raises(ValueError, match='Invalid code'):
            calculator.apply_discount(100.00, 'INVALID')
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Match Existing Patterns" icon="copy">
    Follow the testing patterns already in the codebase
  </Card>
  <Card title="Test Behavior, Not Implementation" icon="check">
    Focus on what the code does, not how it does it
  </Card>
  <Card title="Include Edge Cases" icon="border-all">
    Test boundaries, empty inputs, and error conditions
  </Card>
  <Card title="Use Meaningful Names" icon="tag">
    Test names should describe the scenario being tested
  </Card>
</CardGroup>

## Coverage Strategies

### By Module

```markdown
Week 1: src/services/ (critical business logic)
Week 2: src/api/ (endpoint handlers)
Week 3: src/utils/ (helper functions)
```

### By Criticality

1. Payment processing
2. Authentication
3. Data validation
4. Business rules
5. UI components

<Card title="Tutorial: Adding Test Coverage" icon="graduation-cap" href="/use-cases/tutorials/test-coverage">
  Follow a step-by-step tutorial
</Card>
