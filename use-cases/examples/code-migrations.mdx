---
title: "Code Migrations"
sidebarTitle: "Code Migrations"
description: "Using OpenHands for language and framework migrations"
---

# Code Migrations

OpenHands excels at systematic code transformations, making it ideal for migration projects.

## Common Migration Types

### Language Migrations

- JavaScript → TypeScript
- Python 2 → Python 3
- Java 8 → Java 17+
- CoffeeScript → JavaScript

### Framework Migrations

- React Class Components → Hooks
- Angular.js → Angular
- Express → Fastify
- jQuery → Vanilla JS

### Pattern Migrations

- Callbacks → Promises/Async-Await
- REST → GraphQL
- Monolith → Microservices patterns

## Migration Workflow

<Steps>
  <Step title="Analyze">
    Identify all files that need migration and any dependencies
  </Step>
  <Step title="Plan">
    Order files by dependency graph (migrate dependencies first)
  </Step>
  <Step title="Execute">
    Migrate files one at a time with verification
  </Step>
  <Step title="Verify">
    Run tests and manual verification after each migration
  </Step>
</Steps>

## Example: JavaScript to TypeScript

### Instruction Template

```markdown
Migrate [filename].js to TypeScript.

## Requirements
1. Rename file to .ts/.tsx
2. Add type annotations to all:
   - Function parameters
   - Return types
   - Variables where inference isn't clear
3. Create interfaces for object shapes
4. Fix any type errors

## Reference
See [example-file].ts for the pattern to follow

## Verification
- [ ] npx tsc --noEmit passes
- [ ] All tests pass
- [ ] No 'any' types except where explicitly needed
```

### Before

```javascript
// src/utils/format.js
export function formatCurrency(amount, currency) {
  const formatter = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency,
  });
  return formatter.format(amount);
}

export function formatDate(date, options) {
  return new Date(date).toLocaleDateString('en-US', options);
}
```

### After

```typescript
// src/utils/format.ts
interface CurrencyFormatOptions {
  currency: string;
  locale?: string;
}

interface DateFormatOptions {
  year?: 'numeric' | '2-digit';
  month?: 'numeric' | '2-digit' | 'long' | 'short' | 'narrow';
  day?: 'numeric' | '2-digit';
}

export function formatCurrency(
  amount: number,
  currency: string,
  locale: string = 'en-US'
): string {
  const formatter = new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
  });
  return formatter.format(amount);
}

export function formatDate(
  date: Date | string,
  options?: DateFormatOptions,
  locale: string = 'en-US'
): string {
  return new Date(date).toLocaleDateString(locale, options);
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Migrate in Dependency Order">
    Start with files that have no internal dependencies, then work up the dependency tree.
  </Accordion>
  <Accordion title="Keep Changes Minimal">
    Focus only on the migration. Don't refactor or add features simultaneously.
  </Accordion>
  <Accordion title="Verify After Each File">
    Run type checking and tests after each file to catch issues early.
  </Accordion>
  <Accordion title="Preserve Behavior">
    The goal is equivalent functionality, not improvement.
  </Accordion>
</AccordionGroup>

## Parallel Migration

For large codebases, migrate independent files in parallel:

```markdown
# Run these in parallel sessions:
Session 1: Migrate src/utils/string.js
Session 2: Migrate src/utils/number.js
Session 3: Migrate src/utils/date.js
```

<Card title="See More Examples" icon="code" href="/use-cases/tutorials/getting-started">
  Follow step-by-step migration tutorials
</Card>
